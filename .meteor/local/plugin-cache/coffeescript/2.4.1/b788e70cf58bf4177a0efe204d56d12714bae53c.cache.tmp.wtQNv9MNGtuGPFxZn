{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nmodule.export({\n  TAPi18nClient: () => TAPi18nClient\n});\nlet TAPi18nBase;\nmodule.link(\"./tap_i18n-common\", {\n  TAPi18nBase(v) {\n    TAPi18nBase = v;\n  }\n\n}, 0);\nlet globals;\nmodule.link(\"./globals\", {\n  globals(v) {\n    globals = v;\n  }\n\n}, 1);\nvar indexOf = [].indexOf;\n\nvar TAPi18nClient = function () {\n  class TAPi18nClient extends TAPi18nBase {\n    _getLanguageFilePath(lang_tag) {\n      var path;\n\n      if (!this._enabled()) {\n        return null;\n      }\n\n      path = this.conf.cdn_path != null ? this.conf.cdn_path : this.conf.i18n_files_route;\n      path = path.replace(/\\/$/, \"\");\n\n      if (Meteor.isCordova && path[0] === \"/\") {\n        path = Meteor.absoluteUrl().replace(/\\/+$/, \"\") + path;\n      }\n\n      return \"\".concat(path, \"/\").concat(lang_tag, \".json\");\n    }\n\n    _loadLanguage(languageTag) {\n      var dependencyLoadDfd, dfd, directDependencyLanguageTag, loadLanguageTag, project_languages; // Load languageTag and its dependencies languages to TAPi18next if we\n      // haven't loaded them already.\n      // languageTag dependencies languages are:\n      // * The base language if languageTag is a dialect.\n      // * The fallback language (en) if we haven't loaded it already.\n      // Returns a deferred object that resolves with no arguments if all files\n      // loaded successfully to TAPi18next and rejects with array of error\n      // messages otherwise\n      // Example:\n      // TAPi18n._loadLanguage(\"pt-BR\")\n      //   .done(function () {\n      //     console.log(\"languageLoaded successfully\");\n      //   })\n      //   .fail(function (messages) {\n      //     console.log(\"Couldn't load languageTag\", messages);\n      //   })\n      // The above example will attempt to load pt-BR, pt and en\n\n      dfd = new $.Deferred();\n\n      if (!this._enabled()) {\n        return dfd.reject(\"tap-i18n is not enabled in the project level, check tap-i18n README\");\n      }\n\n      project_languages = this._getProjectLanguages();\n\n      if (indexOf.call(project_languages, languageTag) >= 0) {\n        if (indexOf.call(this._loaded_languages, languageTag) < 0) {\n          loadLanguageTag = () => {\n            var jqXHR;\n            jqXHR = $.getJSON(this._getLanguageFilePath(languageTag));\n            jqXHR.done(data => {\n              this._loadLangFileObject(languageTag, data);\n\n              this._loaded_languages.push(languageTag);\n\n              return dfd.resolve();\n            });\n            return jqXHR.fail((xhr, error_code) => {\n              return dfd.reject(\"Couldn't load language '\".concat(languageTag, \"' JSON: \").concat(error_code));\n            });\n          };\n\n          directDependencyLanguageTag = indexOf.call(languageTag, \"-\") >= 0 ? languageTag.replace(/-.*/, \"\") : this._fallback_language; // load dependency language if it is part of the project and not the fallback language\n\n          if (languageTag !== this._fallback_language && indexOf.call(project_languages, directDependencyLanguageTag) >= 0) {\n            dependencyLoadDfd = this._loadLanguage(directDependencyLanguageTag);\n            dependencyLoadDfd.done(() => {\n              // All dependencies loaded successfully\n              return loadLanguageTag();\n            });\n            dependencyLoadDfd.fail(message => {\n              return dfd.reject(\"Loading process failed since dependency language '\".concat(directDependencyLanguageTag, \"' failed to load: \") + message);\n            });\n          } else {\n            loadLanguageTag();\n          }\n        } else {\n          // languageTag loaded already\n          dfd.resolve();\n        }\n      } else {\n        dfd.reject([\"Language \".concat(languageTag, \" is not supported\")]);\n      }\n\n      return dfd.promise();\n    }\n\n    _registerHelpers(package_name, template) {\n      var helpers, tapI18nextProxy, underscore_helper;\n\n      if (package_name !== globals.project_translations_domain) {\n        tapI18nextProxy = this._getPackageI18nextProxy(this.packages[package_name].namespace);\n      } else {\n        tapI18nextProxy = this._getPackageI18nextProxy(globals.project_translations_domain);\n      }\n\n      underscore_helper = function (key) {\n        var options;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        options = args.pop().hash;\n\n        if (!_.isEmpty(args)) {\n          options.sprintf = args;\n        }\n\n        return tapI18nextProxy(key, options);\n      }; // template specific helpers\n\n\n      if (package_name !== globals.project_translations_domain) {\n        // {{_ }}\n        if (Template[template] != null && Template[template].helpers != null) {\n          helpers = {};\n          helpers[this.packages[package_name].helper_name] = underscore_helper;\n          Template[template].helpers(helpers);\n        }\n      } else {\n        // {{_ }}\n        // global helpers\n        UI.registerHelper(this.conf.helper_name, underscore_helper); // {{languageTag}}\n\n        UI.registerHelper(\"languageTag\", () => {\n          return this.getLanguage();\n        });\n      }\n    }\n\n    _getRegisterHelpersProxy(package_name) {\n      // A proxy to _registerHelpers where the package_name is fixed to package_name\n      return template => {\n        return this._registerHelpers(package_name, template);\n      };\n    }\n\n    _prepareLanguageSpecificTranslator(lang_tag) {\n      var dfd;\n      dfd = new $.Deferred().resolve().promise();\n\n      if (lang_tag in this._languageSpecificTranslatorsTrackers) {\n        return dfd;\n      }\n\n      this._languageSpecificTranslatorsTrackers[lang_tag] = new Tracker.Dependency();\n\n      if (!(lang_tag in this._languageSpecificTranslators)) {\n        dfd = this._loadLanguage(lang_tag).done(() => {\n          this._languageSpecificTranslators[lang_tag] = this._getSpecificLangTranslator(lang_tag);\n          return this._languageSpecificTranslatorsTrackers[lang_tag].changed();\n        });\n      }\n\n      return dfd;\n    }\n\n    _getPackageI18nextProxy(package_name) {\n      var _this = this;\n\n      // A proxy to TAPi18next.t where the namespace is preset to the package's\n      return function (key, options) {\n        let lang_tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        // Devs get confused and use lang option instead of lng option, make lang\n        // alias of lng\n        if ((options != null ? options.lang : void 0) != null && (options != null ? options.lng : void 0) == null) {\n          options.lng = options.lang;\n        }\n\n        if ((options != null ? options.lng : void 0) != null && lang_tag == null) {\n          lang_tag = options.lng; // Remove options.lng so we won't pass it to the regular TAPi18next\n          // before the language specific translator is ready to keep behavior\n          // consistent.\n          // If lang is actually ready before the language specifc translator is\n          // ready, TAPi18next will translate to lang_tag if we won't remove\n          // options.lng.\n\n          delete options.lng;\n        }\n\n        if (lang_tag != null) {\n          _this._prepareLanguageSpecificTranslator(lang_tag);\n\n          _this._languageSpecificTranslatorsTrackers[lang_tag].depend();\n\n          if (lang_tag in _this._languageSpecificTranslators) {\n            return _this._languageSpecificTranslators[lang_tag](\"\".concat(_this._getPackageDomain(package_name), \":\").concat(key), options);\n          } else {\n            return TAPi18next.t(\"\".concat(_this._getPackageDomain(package_name), \":\").concat(key), options);\n          }\n        } // If inside a reactive computation, we want to invalidate the computation if the client lang changes\n\n\n        _this._language_changed_tracker.depend();\n\n        return TAPi18next.t(\"\".concat(_this._getPackageDomain(package_name), \":\").concat(key), options);\n      };\n    }\n\n    _onceEnabled() {\n      return this._registerHelpers(globals.project_translations_domain);\n    }\n\n    setLanguage(lang_tag) {\n      var isAborted, self;\n      self = this;\n\n      if (typeof this._abortPreviousSetLang === \"function\") {\n        this._abortPreviousSetLang();\n      }\n\n      isAborted = false;\n\n      this._abortPreviousSetLang = function () {\n        return isAborted = true;\n      };\n\n      return this._loadLanguage(lang_tag).then(() => {\n        if (!isAborted) {\n          TAPi18next.setLng(lang_tag);\n\n          this._language_changed_tracker.changed();\n\n          return Session.set(this._loaded_lang_session_key, lang_tag);\n        }\n      });\n    }\n\n    getLanguage() {\n      var session_lang;\n\n      if (!this._enabled()) {\n        return null;\n      }\n\n      session_lang = Session.get(this._loaded_lang_session_key);\n\n      if (session_lang != null) {\n        return session_lang;\n      } else {\n        return this._fallback_language;\n      }\n    }\n\n  }\n\n  ;\n  TAPi18nClient.prototype._languageSpecificTranslators = null;\n  TAPi18nClient.prototype._languageSpecificTranslatorsTrackers = null;\n  TAPi18nClient.prototype._abortPreviousSetLang = null;\n  return TAPi18nClient;\n}.call(this);","sourceMap":{"version":3,"sources":["/packages/rocketchat_tap-i18n/lib/tap_i18n/tap_i18n-client.coffee","/lib/tap_i18n/tap_i18n-client.coffee"],"names":["module","export","TAPi18nClient","TAPi18nBase","link","v","globals","indexOf","_getLanguageFilePath","lang_tag","path","_enabled","conf","cdn_path","i18n_files_route","replace","Meteor","isCordova","absoluteUrl","_loadLanguage","languageTag","dependencyLoadDfd","dfd","directDependencyLanguageTag","loadLanguageTag","project_languages","$","Deferred","reject","_getProjectLanguages","call","_loaded_languages","jqXHR","getJSON","done","data","_loadLangFileObject","push","resolve","fail","xhr","error_code","_fallback_language","message","promise","_registerHelpers","package_name","template","helpers","tapI18nextProxy","underscore_helper","project_translations_domain","_getPackageI18nextProxy","packages","namespace","key","options","args","pop","hash","_","isEmpty","sprintf","Template","helper_name","UI","registerHelper","getLanguage","_getRegisterHelpersProxy","_prepareLanguageSpecificTranslator","_languageSpecificTranslatorsTrackers","Tracker","Dependency","_languageSpecificTranslators","_getSpecificLangTranslator","changed","lang","lng","depend","_getPackageDomain","TAPi18next","t","_language_changed_tracker","_onceEnabled","setLanguage","isAborted","self","_abortPreviousSetLang","then","setLng","Session","set","_loaded_lang_session_key","session_lang","get","prototype"],"mappings":"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","file":"packages/rocketchat:tap-i18n/lib/tap_i18n/tap_i18n-client.coffee.map","sourcesContent":["import { TAPi18nBase } from './tap_i18n-common';\nimport { globals } from './globals';\n\nexport class TAPi18nClient extends TAPi18nBase\n  _languageSpecificTranslators: null\n  _languageSpecificTranslatorsTrackers: null\n\n  _getLanguageFilePath: (lang_tag) ->\n    if not @_enabled()\n      return null\n\n    path = if @.conf.cdn_path? then @.conf.cdn_path else @.conf.i18n_files_route\n    path = path.replace /\\/$/, \"\"\n    if Meteor.isCordova and path[0] == \"/\"\n      path = Meteor.absoluteUrl().replace(/\\/+$/, \"\") + path\n\n    \"#{path}/#{lang_tag}.json\"\n\n  _loadLanguage: (languageTag) ->\n    # Load languageTag and its dependencies languages to TAPi18next if we\n    # haven't loaded them already.\n    #\n    # languageTag dependencies languages are:\n    # * The base language if languageTag is a dialect.\n    # * The fallback language (en) if we haven't loaded it already.\n    #\n    # Returns a deferred object that resolves with no arguments if all files\n    # loaded successfully to TAPi18next and rejects with array of error\n    # messages otherwise\n    #\n    # Example:\n    # TAPi18n._loadLanguage(\"pt-BR\")\n    #   .done(function () {\n    #     console.log(\"languageLoaded successfully\");\n    #   })\n    #   .fail(function (messages) {\n    #     console.log(\"Couldn't load languageTag\", messages);\n    #   })\n    #\n    # The above example will attempt to load pt-BR, pt and en\n\n    dfd = new $.Deferred()\n\n    if not @_enabled()\n      return dfd.reject \"tap-i18n is not enabled in the project level, check tap-i18n README\"\n\n    project_languages = @_getProjectLanguages()\n\n    if languageTag in project_languages\n      if languageTag not in @_loaded_languages\n        loadLanguageTag = =>\n          jqXHR = $.getJSON(@_getLanguageFilePath(languageTag))\n\n          jqXHR.done (data) =>\n            @_loadLangFileObject(languageTag, data)\n\n            @_loaded_languages.push languageTag\n\n            dfd.resolve()\n\n          jqXHR.fail (xhr, error_code) =>\n            dfd.reject(\"Couldn't load language '#{languageTag}' JSON: #{error_code}\")\n\n        directDependencyLanguageTag = if \"-\" in languageTag then languageTag.replace(/-.*/, \"\") else @._fallback_language\n\n        # load dependency language if it is part of the project and not the fallback language\n        if languageTag != @._fallback_language and directDependencyLanguageTag in project_languages\n          dependencyLoadDfd = @_loadLanguage directDependencyLanguageTag\n\n          dependencyLoadDfd.done =>\n            # All dependencies loaded successfully\n            loadLanguageTag()\n\n          dependencyLoadDfd.fail (message) =>\n            dfd.reject(\"Loading process failed since dependency language\n              '#{directDependencyLanguageTag}' failed to load: \" + message)\n        else\n          loadLanguageTag()\n      else\n        # languageTag loaded already\n        dfd.resolve()\n    else\n      dfd.reject([\"Language #{languageTag} is not supported\"])\n\n    return dfd.promise()\n\n  _registerHelpers: (package_name, template) ->\n    if package_name != globals.project_translations_domain\n      tapI18nextProxy = @_getPackageI18nextProxy(@packages[package_name].namespace)\n    else\n      tapI18nextProxy = @_getPackageI18nextProxy(globals.project_translations_domain)\n\n    underscore_helper = (key, args...) ->\n      options = (args.pop()).hash\n      if not _.isEmpty(args)\n        options.sprintf = args\n\n      tapI18nextProxy(key, options)\n\n    # template specific helpers\n    if package_name != globals.project_translations_domain\n      # {{_ }}\n      if Template[template]? and Template[template].helpers?\n        helpers = {}\n        helpers[@packages[package_name].helper_name] = underscore_helper\n        Template[template].helpers(helpers)\n\n    # global helpers\n    else\n      # {{_ }}\n      UI.registerHelper @conf.helper_name, underscore_helper\n\n      # {{languageTag}}\n      UI.registerHelper \"languageTag\", () => @getLanguage()\n\n    return\n\n  _getRegisterHelpersProxy: (package_name) ->\n    # A proxy to _registerHelpers where the package_name is fixed to package_name\n    (template) =>\n      @_registerHelpers(package_name, template)\n\n  _prepareLanguageSpecificTranslator: (lang_tag) ->\n    dfd = (new $.Deferred()).resolve().promise()\n\n    if lang_tag of @_languageSpecificTranslatorsTrackers\n      return dfd\n\n    @_languageSpecificTranslatorsTrackers[lang_tag] = new Tracker.Dependency\n\n    if not(lang_tag of @_languageSpecificTranslators)\n      dfd = @_loadLanguage(lang_tag)\n        .done =>\n          @_languageSpecificTranslators[lang_tag] = @_getSpecificLangTranslator(lang_tag)\n\n          @_languageSpecificTranslatorsTrackers[lang_tag].changed()\n\n    return dfd\n\n  _getPackageI18nextProxy: (package_name) ->\n    # A proxy to TAPi18next.t where the namespace is preset to the package's\n\n    (key, options, lang_tag=null) =>\n      # Devs get confused and use lang option instead of lng option, make lang\n      # alias of lng\n      if options?.lang? and not options?.lng?\n        options.lng = options.lang\n\n      if options?.lng? and not lang_tag?\n        lang_tag = options.lng\n        # Remove options.lng so we won't pass it to the regular TAPi18next\n        # before the language specific translator is ready to keep behavior\n        # consistent.\n        #\n        # If lang is actually ready before the language specifc translator is\n        # ready, TAPi18next will translate to lang_tag if we won't remove\n        # options.lng.\n        delete options.lng\n\n      if lang_tag?\n        @_prepareLanguageSpecificTranslator(lang_tag)\n\n        @_languageSpecificTranslatorsTrackers[lang_tag].depend()\n\n        if lang_tag of @_languageSpecificTranslators\n          return @_languageSpecificTranslators[lang_tag] \"#{@_getPackageDomain(package_name)}:#{key}\", options\n        else\n          return TAPi18next.t \"#{@_getPackageDomain(package_name)}:#{key}\", options\n\n      # If inside a reactive computation, we want to invalidate the computation if the client lang changes\n      @_language_changed_tracker.depend()\n\n\n      TAPi18next.t \"#{@_getPackageDomain(package_name)}:#{key}\", options\n\n  _onceEnabled: () ->\n    @_registerHelpers globals.project_translations_domain\n\n  _abortPreviousSetLang: null\n  setLanguage: (lang_tag) ->\n    self = @\n\n    @_abortPreviousSetLang?()\n\n    isAborted = false\n    @_abortPreviousSetLang = -> isAborted = true\n\n    @_loadLanguage(lang_tag).then =>\n      if not isAborted\n        TAPi18next.setLng(lang_tag)\n\n        @_language_changed_tracker.changed()\n        Session.set @_loaded_lang_session_key, lang_tag\n\n  getLanguage: ->\n    if not @._enabled()\n      return null\n\n    session_lang = Session.get @_loaded_lang_session_key\n\n    if session_lang? then session_lang else @._fallback_language\n","var indexOf = [].indexOf;\n\nimport {\n  TAPi18nBase\n} from './tap_i18n-common';\n\nimport {\n  globals\n} from './globals';\n\nexport var TAPi18nClient = (function() {\n  class TAPi18nClient extends TAPi18nBase {\n    _getLanguageFilePath(lang_tag) {\n      var path;\n      if (!this._enabled()) {\n        return null;\n      }\n      path = this.conf.cdn_path != null ? this.conf.cdn_path : this.conf.i18n_files_route;\n      path = path.replace(/\\/$/, \"\");\n      if (Meteor.isCordova && path[0] === \"/\") {\n        path = Meteor.absoluteUrl().replace(/\\/+$/, \"\") + path;\n      }\n      return `${path}/${lang_tag}.json`;\n    }\n\n    _loadLanguage(languageTag) {\n      var dependencyLoadDfd, dfd, directDependencyLanguageTag, loadLanguageTag, project_languages;\n      // Load languageTag and its dependencies languages to TAPi18next if we\n      // haven't loaded them already.\n\n      // languageTag dependencies languages are:\n      // * The base language if languageTag is a dialect.\n      // * The fallback language (en) if we haven't loaded it already.\n\n      // Returns a deferred object that resolves with no arguments if all files\n      // loaded successfully to TAPi18next and rejects with array of error\n      // messages otherwise\n\n      // Example:\n      // TAPi18n._loadLanguage(\"pt-BR\")\n      //   .done(function () {\n      //     console.log(\"languageLoaded successfully\");\n      //   })\n      //   .fail(function (messages) {\n      //     console.log(\"Couldn't load languageTag\", messages);\n      //   })\n\n      // The above example will attempt to load pt-BR, pt and en\n      dfd = new $.Deferred();\n      if (!this._enabled()) {\n        return dfd.reject(\"tap-i18n is not enabled in the project level, check tap-i18n README\");\n      }\n      project_languages = this._getProjectLanguages();\n      if (indexOf.call(project_languages, languageTag) >= 0) {\n        if (indexOf.call(this._loaded_languages, languageTag) < 0) {\n          loadLanguageTag = () => {\n            var jqXHR;\n            jqXHR = $.getJSON(this._getLanguageFilePath(languageTag));\n            jqXHR.done((data) => {\n              this._loadLangFileObject(languageTag, data);\n              this._loaded_languages.push(languageTag);\n              return dfd.resolve();\n            });\n            return jqXHR.fail((xhr, error_code) => {\n              return dfd.reject(`Couldn't load language '${languageTag}' JSON: ${error_code}`);\n            });\n          };\n          directDependencyLanguageTag = indexOf.call(languageTag, \"-\") >= 0 ? languageTag.replace(/-.*/, \"\") : this._fallback_language;\n          // load dependency language if it is part of the project and not the fallback language\n          if (languageTag !== this._fallback_language && indexOf.call(project_languages, directDependencyLanguageTag) >= 0) {\n            dependencyLoadDfd = this._loadLanguage(directDependencyLanguageTag);\n            dependencyLoadDfd.done(() => {\n              // All dependencies loaded successfully\n              return loadLanguageTag();\n            });\n            dependencyLoadDfd.fail((message) => {\n              return dfd.reject(`Loading process failed since dependency language '${directDependencyLanguageTag}' failed to load: ` + message);\n            });\n          } else {\n            loadLanguageTag();\n          }\n        } else {\n          // languageTag loaded already\n          dfd.resolve();\n        }\n      } else {\n        dfd.reject([`Language ${languageTag} is not supported`]);\n      }\n      return dfd.promise();\n    }\n\n    _registerHelpers(package_name, template) {\n      var helpers, tapI18nextProxy, underscore_helper;\n      if (package_name !== globals.project_translations_domain) {\n        tapI18nextProxy = this._getPackageI18nextProxy(this.packages[package_name].namespace);\n      } else {\n        tapI18nextProxy = this._getPackageI18nextProxy(globals.project_translations_domain);\n      }\n      underscore_helper = function(key, ...args) {\n        var options;\n        options = (args.pop()).hash;\n        if (!_.isEmpty(args)) {\n          options.sprintf = args;\n        }\n        return tapI18nextProxy(key, options);\n      };\n      // template specific helpers\n      if (package_name !== globals.project_translations_domain) {\n        // {{_ }}\n        if ((Template[template] != null) && (Template[template].helpers != null)) {\n          helpers = {};\n          helpers[this.packages[package_name].helper_name] = underscore_helper;\n          Template[template].helpers(helpers);\n        }\n      } else {\n        // {{_ }}\n        // global helpers\n        UI.registerHelper(this.conf.helper_name, underscore_helper);\n        // {{languageTag}}\n        UI.registerHelper(\"languageTag\", () => {\n          return this.getLanguage();\n        });\n      }\n    }\n\n    _getRegisterHelpersProxy(package_name) {\n      // A proxy to _registerHelpers where the package_name is fixed to package_name\n      return (template) => {\n        return this._registerHelpers(package_name, template);\n      };\n    }\n\n    _prepareLanguageSpecificTranslator(lang_tag) {\n      var dfd;\n      dfd = (new $.Deferred()).resolve().promise();\n      if (lang_tag in this._languageSpecificTranslatorsTrackers) {\n        return dfd;\n      }\n      this._languageSpecificTranslatorsTrackers[lang_tag] = new Tracker.Dependency;\n      if (!(lang_tag in this._languageSpecificTranslators)) {\n        dfd = this._loadLanguage(lang_tag).done(() => {\n          this._languageSpecificTranslators[lang_tag] = this._getSpecificLangTranslator(lang_tag);\n          return this._languageSpecificTranslatorsTrackers[lang_tag].changed();\n        });\n      }\n      return dfd;\n    }\n\n    _getPackageI18nextProxy(package_name) {\n      // A proxy to TAPi18next.t where the namespace is preset to the package's\n      return (key, options, lang_tag = null) => {\n        // Devs get confused and use lang option instead of lng option, make lang\n        // alias of lng\n        if (((options != null ? options.lang : void 0) != null) && ((options != null ? options.lng : void 0) == null)) {\n          options.lng = options.lang;\n        }\n        if (((options != null ? options.lng : void 0) != null) && (lang_tag == null)) {\n          lang_tag = options.lng;\n          // Remove options.lng so we won't pass it to the regular TAPi18next\n          // before the language specific translator is ready to keep behavior\n          // consistent.\n\n          // If lang is actually ready before the language specifc translator is\n          // ready, TAPi18next will translate to lang_tag if we won't remove\n          // options.lng.\n          delete options.lng;\n        }\n        if (lang_tag != null) {\n          this._prepareLanguageSpecificTranslator(lang_tag);\n          this._languageSpecificTranslatorsTrackers[lang_tag].depend();\n          if (lang_tag in this._languageSpecificTranslators) {\n            return this._languageSpecificTranslators[lang_tag](`${this._getPackageDomain(package_name)}:${key}`, options);\n          } else {\n            return TAPi18next.t(`${this._getPackageDomain(package_name)}:${key}`, options);\n          }\n        }\n        // If inside a reactive computation, we want to invalidate the computation if the client lang changes\n        this._language_changed_tracker.depend();\n        return TAPi18next.t(`${this._getPackageDomain(package_name)}:${key}`, options);\n      };\n    }\n\n    _onceEnabled() {\n      return this._registerHelpers(globals.project_translations_domain);\n    }\n\n    setLanguage(lang_tag) {\n      var isAborted, self;\n      self = this;\n      if (typeof this._abortPreviousSetLang === \"function\") {\n        this._abortPreviousSetLang();\n      }\n      isAborted = false;\n      this._abortPreviousSetLang = function() {\n        return isAborted = true;\n      };\n      return this._loadLanguage(lang_tag).then(() => {\n        if (!isAborted) {\n          TAPi18next.setLng(lang_tag);\n          this._language_changed_tracker.changed();\n          return Session.set(this._loaded_lang_session_key, lang_tag);\n        }\n      });\n    }\n\n    getLanguage() {\n      var session_lang;\n      if (!this._enabled()) {\n        return null;\n      }\n      session_lang = Session.get(this._loaded_lang_session_key);\n      if (session_lang != null) {\n        return session_lang;\n      } else {\n        return this._fallback_language;\n      }\n    }\n\n  };\n\n  TAPi18nClient.prototype._languageSpecificTranslators = null;\n\n  TAPi18nClient.prototype._languageSpecificTranslatorsTrackers = null;\n\n  TAPi18nClient.prototype._abortPreviousSetLang = null;\n\n  return TAPi18nClient;\n\n}).call(this);\n"]}}