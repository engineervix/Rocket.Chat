{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nmodule.export({\n  TAPi18nClient: function () {\n    return TAPi18nClient;\n  }\n});\nvar TAPi18nBase;\nmodule.link(\"./tap_i18n-common\", {\n  TAPi18nBase: function (v) {\n    TAPi18nBase = v;\n  }\n}, 0);\nvar globals;\nmodule.link(\"./globals\", {\n  globals: function (v) {\n    globals = v;\n  }\n}, 1);\nvar indexOf = [].indexOf;\n\nvar TAPi18nClient = function () {\n  var TAPi18nClient =\n  /*#__PURE__*/\n  function (_TAPi18nBase) {\n    _inheritsLoose(TAPi18nClient, _TAPi18nBase);\n\n    function TAPi18nClient() {\n      return _TAPi18nBase.apply(this, arguments) || this;\n    }\n\n    var _proto = TAPi18nClient.prototype;\n\n    _proto._getLanguageFilePath = function () {\n      function _getLanguageFilePath(lang_tag) {\n        var path;\n\n        if (!this._enabled()) {\n          return null;\n        }\n\n        path = this.conf.cdn_path != null ? this.conf.cdn_path : this.conf.i18n_files_route;\n        path = path.replace(/\\/$/, \"\");\n\n        if (Meteor.isCordova && path[0] === \"/\") {\n          path = Meteor.absoluteUrl().replace(/\\/+$/, \"\") + path;\n        }\n\n        return path + \"/\" + lang_tag + \".json\";\n      }\n\n      return _getLanguageFilePath;\n    }();\n\n    _proto._loadLanguage = function () {\n      function _loadLanguage(languageTag) {\n        var _this = this;\n\n        var dependencyLoadDfd, dfd, directDependencyLanguageTag, loadLanguageTag, project_languages; // Load languageTag and its dependencies languages to TAPi18next if we\n        // haven't loaded them already.\n        // languageTag dependencies languages are:\n        // * The base language if languageTag is a dialect.\n        // * The fallback language (en) if we haven't loaded it already.\n        // Returns a deferred object that resolves with no arguments if all files\n        // loaded successfully to TAPi18next and rejects with array of error\n        // messages otherwise\n        // Example:\n        // TAPi18n._loadLanguage(\"pt-BR\")\n        //   .done(function () {\n        //     console.log(\"languageLoaded successfully\");\n        //   })\n        //   .fail(function (messages) {\n        //     console.log(\"Couldn't load languageTag\", messages);\n        //   })\n        // The above example will attempt to load pt-BR, pt and en\n\n        dfd = new $.Deferred();\n\n        if (!this._enabled()) {\n          return dfd.reject(\"tap-i18n is not enabled in the project level, check tap-i18n README\");\n        }\n\n        project_languages = this._getProjectLanguages();\n\n        if (indexOf.call(project_languages, languageTag) >= 0) {\n          if (indexOf.call(this._loaded_languages, languageTag) < 0) {\n            loadLanguageTag = function () {\n              var jqXHR;\n              jqXHR = $.getJSON(_this._getLanguageFilePath(languageTag));\n              jqXHR.done(function (data) {\n                _this._loadLangFileObject(languageTag, data);\n\n                _this._loaded_languages.push(languageTag);\n\n                return dfd.resolve();\n              });\n              return jqXHR.fail(function (xhr, error_code) {\n                return dfd.reject(\"Couldn't load language '\" + languageTag + \"' JSON: \" + error_code);\n              });\n            };\n\n            directDependencyLanguageTag = indexOf.call(languageTag, \"-\") >= 0 ? languageTag.replace(/-.*/, \"\") : this._fallback_language; // load dependency language if it is part of the project and not the fallback language\n\n            if (languageTag !== this._fallback_language && indexOf.call(project_languages, directDependencyLanguageTag) >= 0) {\n              dependencyLoadDfd = this._loadLanguage(directDependencyLanguageTag);\n              dependencyLoadDfd.done(function () {\n                // All dependencies loaded successfully\n                return loadLanguageTag();\n              });\n              dependencyLoadDfd.fail(function (message) {\n                return dfd.reject(\"Loading process failed since dependency language '\" + directDependencyLanguageTag + \"' failed to load: \" + message);\n              });\n            } else {\n              loadLanguageTag();\n            }\n          } else {\n            // languageTag loaded already\n            dfd.resolve();\n          }\n        } else {\n          dfd.reject([\"Language \" + languageTag + \" is not supported\"]);\n        }\n\n        return dfd.promise();\n      }\n\n      return _loadLanguage;\n    }();\n\n    _proto._registerHelpers = function () {\n      function _registerHelpers(package_name, template) {\n        var _this2 = this;\n\n        var helpers, tapI18nextProxy, underscore_helper;\n\n        if (package_name !== globals.project_translations_domain) {\n          tapI18nextProxy = this._getPackageI18nextProxy(this.packages[package_name].namespace);\n        } else {\n          tapI18nextProxy = this._getPackageI18nextProxy(globals.project_translations_domain);\n        }\n\n        underscore_helper = function (key) {\n          var options;\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          options = args.pop().hash;\n\n          if (!_.isEmpty(args)) {\n            options.sprintf = args;\n          }\n\n          return tapI18nextProxy(key, options);\n        }; // template specific helpers\n\n\n        if (package_name !== globals.project_translations_domain) {\n          // {{_ }}\n          if (Template[template] != null && Template[template].helpers != null) {\n            helpers = {};\n            helpers[this.packages[package_name].helper_name] = underscore_helper;\n            Template[template].helpers(helpers);\n          }\n        } else {\n          // {{_ }}\n          // global helpers\n          UI.registerHelper(this.conf.helper_name, underscore_helper); // {{languageTag}}\n\n          UI.registerHelper(\"languageTag\", function () {\n            return _this2.getLanguage();\n          });\n        }\n      }\n\n      return _registerHelpers;\n    }();\n\n    _proto._getRegisterHelpersProxy = function () {\n      function _getRegisterHelpersProxy(package_name) {\n        var _this3 = this;\n\n        // A proxy to _registerHelpers where the package_name is fixed to package_name\n        return function (template) {\n          return _this3._registerHelpers(package_name, template);\n        };\n      }\n\n      return _getRegisterHelpersProxy;\n    }();\n\n    _proto._prepareLanguageSpecificTranslator = function () {\n      function _prepareLanguageSpecificTranslator(lang_tag) {\n        var _this4 = this;\n\n        var dfd;\n        dfd = new $.Deferred().resolve().promise();\n\n        if (lang_tag in this._languageSpecificTranslatorsTrackers) {\n          return dfd;\n        }\n\n        this._languageSpecificTranslatorsTrackers[lang_tag] = new Tracker.Dependency();\n\n        if (!(lang_tag in this._languageSpecificTranslators)) {\n          dfd = this._loadLanguage(lang_tag).done(function () {\n            _this4._languageSpecificTranslators[lang_tag] = _this4._getSpecificLangTranslator(lang_tag);\n            return _this4._languageSpecificTranslatorsTrackers[lang_tag].changed();\n          });\n        }\n\n        return dfd;\n      }\n\n      return _prepareLanguageSpecificTranslator;\n    }();\n\n    _proto._getPackageI18nextProxy = function () {\n      function _getPackageI18nextProxy(package_name) {\n        var _this5 = this;\n\n        // A proxy to TAPi18next.t where the namespace is preset to the package's\n        return function (key, options) {\n          var lang_tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n          // Devs get confused and use lang option instead of lng option, make lang\n          // alias of lng\n          if ((options != null ? options.lang : void 0) != null && (options != null ? options.lng : void 0) == null) {\n            options.lng = options.lang;\n          }\n\n          if ((options != null ? options.lng : void 0) != null && lang_tag == null) {\n            lang_tag = options.lng; // Remove options.lng so we won't pass it to the regular TAPi18next\n            // before the language specific translator is ready to keep behavior\n            // consistent.\n            // If lang is actually ready before the language specifc translator is\n            // ready, TAPi18next will translate to lang_tag if we won't remove\n            // options.lng.\n\n            delete options.lng;\n          }\n\n          if (lang_tag != null) {\n            _this5._prepareLanguageSpecificTranslator(lang_tag);\n\n            _this5._languageSpecificTranslatorsTrackers[lang_tag].depend();\n\n            if (lang_tag in _this5._languageSpecificTranslators) {\n              return _this5._languageSpecificTranslators[lang_tag](_this5._getPackageDomain(package_name) + \":\" + key, options);\n            } else {\n              return TAPi18next.t(_this5._getPackageDomain(package_name) + \":\" + key, options);\n            }\n          } // If inside a reactive computation, we want to invalidate the computation if the client lang changes\n\n\n          _this5._language_changed_tracker.depend();\n\n          return TAPi18next.t(_this5._getPackageDomain(package_name) + \":\" + key, options);\n        };\n      }\n\n      return _getPackageI18nextProxy;\n    }();\n\n    _proto._onceEnabled = function () {\n      function _onceEnabled() {\n        return this._registerHelpers(globals.project_translations_domain);\n      }\n\n      return _onceEnabled;\n    }();\n\n    _proto.setLanguage = function () {\n      function setLanguage(lang_tag) {\n        var _this6 = this;\n\n        var isAborted, self;\n        self = this;\n\n        if (typeof this._abortPreviousSetLang === \"function\") {\n          this._abortPreviousSetLang();\n        }\n\n        isAborted = false;\n\n        this._abortPreviousSetLang = function () {\n          return isAborted = true;\n        };\n\n        return this._loadLanguage(lang_tag).then(function () {\n          if (!isAborted) {\n            TAPi18next.setLng(lang_tag);\n\n            _this6._language_changed_tracker.changed();\n\n            return Session.set(_this6._loaded_lang_session_key, lang_tag);\n          }\n        });\n      }\n\n      return setLanguage;\n    }();\n\n    _proto.getLanguage = function () {\n      function getLanguage() {\n        var session_lang;\n\n        if (!this._enabled()) {\n          return null;\n        }\n\n        session_lang = Session.get(this._loaded_lang_session_key);\n\n        if (session_lang != null) {\n          return session_lang;\n        } else {\n          return this._fallback_language;\n        }\n      }\n\n      return getLanguage;\n    }();\n\n    return TAPi18nClient;\n  }(TAPi18nBase);\n\n  ;\n  TAPi18nClient.prototype._languageSpecificTranslators = null;\n  TAPi18nClient.prototype._languageSpecificTranslatorsTrackers = null;\n  TAPi18nClient.prototype._abortPreviousSetLang = null;\n  return TAPi18nClient;\n}.call(this);","sourceMap":{"version":3,"sources":["/packages/rocketchat_tap-i18n/lib/tap_i18n/tap_i18n-client.coffee","/lib/tap_i18n/tap_i18n-client.coffee"],"names":["module","export","TAPi18nClient","TAPi18nBase","link","v","globals","indexOf","_getLanguageFilePath","lang_tag","path","_enabled","conf","cdn_path","i18n_files_route","replace","Meteor","isCordova","absoluteUrl","_loadLanguage","languageTag","dependencyLoadDfd","dfd","directDependencyLanguageTag","loadLanguageTag","project_languages","$","Deferred","reject","_getProjectLanguages","call","_loaded_languages","jqXHR","getJSON","done","data","_loadLangFileObject","push","resolve","fail","xhr","error_code","_fallback_language","message","promise","_registerHelpers","package_name","template","helpers","tapI18nextProxy","underscore_helper","project_translations_domain","_getPackageI18nextProxy","packages","namespace","key","options","args","pop","hash","_","isEmpty","sprintf","Template","helper_name","UI","registerHelper","getLanguage","_getRegisterHelpersProxy","_prepareLanguageSpecificTranslator","_languageSpecificTranslatorsTrackers","Tracker","Dependency","_languageSpecificTranslators","_getSpecificLangTranslator","changed","lang","lng","depend","_getPackageDomain","TAPi18next","t","_language_changed_tracker","_onceEnabled","setLanguage","isAborted","self","_abortPreviousSetLang","then","setLng","Session","set","_loaded_lang_session_key","session_lang","get","prototype"],"mappings":"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","file":"packages/rocketchat:tap-i18n/lib/tap_i18n/tap_i18n-client.coffee.map","sourcesContent":["import { TAPi18nBase } from './tap_i18n-common';\nimport { globals } from './globals';\n\nexport class TAPi18nClient extends TAPi18nBase\n  _languageSpecificTranslators: null\n  _languageSpecificTranslatorsTrackers: null\n\n  _getLanguageFilePath: (lang_tag) ->\n    if not @_enabled()\n      return null\n\n    path = if @.conf.cdn_path? then @.conf.cdn_path else @.conf.i18n_files_route\n    path = path.replace /\\/$/, \"\"\n    if Meteor.isCordova and path[0] == \"/\"\n      path = Meteor.absoluteUrl().replace(/\\/+$/, \"\") + path\n\n    \"#{path}/#{lang_tag}.json\"\n\n  _loadLanguage: (languageTag) ->\n    # Load languageTag and its dependencies languages to TAPi18next if we\n    # haven't loaded them already.\n    #\n    # languageTag dependencies languages are:\n    # * The base language if languageTag is a dialect.\n    # * The fallback language (en) if we haven't loaded it already.\n    #\n    # Returns a deferred object that resolves with no arguments if all files\n    # loaded successfully to TAPi18next and rejects with array of error\n    # messages otherwise\n    #\n    # Example:\n    # TAPi18n._loadLanguage(\"pt-BR\")\n    #   .done(function () {\n    #     console.log(\"languageLoaded successfully\");\n    #   })\n    #   .fail(function (messages) {\n    #     console.log(\"Couldn't load languageTag\", messages);\n    #   })\n    #\n    # The above example will attempt to load pt-BR, pt and en\n\n    dfd = new $.Deferred()\n\n    if not @_enabled()\n      return dfd.reject \"tap-i18n is not enabled in the project level, check tap-i18n README\"\n\n    project_languages = @_getProjectLanguages()\n\n    if languageTag in project_languages\n      if languageTag not in @_loaded_languages\n        loadLanguageTag = =>\n          jqXHR = $.getJSON(@_getLanguageFilePath(languageTag))\n\n          jqXHR.done (data) =>\n            @_loadLangFileObject(languageTag, data)\n\n            @_loaded_languages.push languageTag\n\n            dfd.resolve()\n\n          jqXHR.fail (xhr, error_code) =>\n            dfd.reject(\"Couldn't load language '#{languageTag}' JSON: #{error_code}\")\n\n        directDependencyLanguageTag = if \"-\" in languageTag then languageTag.replace(/-.*/, \"\") else @._fallback_language\n\n        # load dependency language if it is part of the project and not the fallback language\n        if languageTag != @._fallback_language and directDependencyLanguageTag in project_languages\n          dependencyLoadDfd = @_loadLanguage directDependencyLanguageTag\n\n          dependencyLoadDfd.done =>\n            # All dependencies loaded successfully\n            loadLanguageTag()\n\n          dependencyLoadDfd.fail (message) =>\n            dfd.reject(\"Loading process failed since dependency language\n              '#{directDependencyLanguageTag}' failed to load: \" + message)\n        else\n          loadLanguageTag()\n      else\n        # languageTag loaded already\n        dfd.resolve()\n    else\n      dfd.reject([\"Language #{languageTag} is not supported\"])\n\n    return dfd.promise()\n\n  _registerHelpers: (package_name, template) ->\n    if package_name != globals.project_translations_domain\n      tapI18nextProxy = @_getPackageI18nextProxy(@packages[package_name].namespace)\n    else\n      tapI18nextProxy = @_getPackageI18nextProxy(globals.project_translations_domain)\n\n    underscore_helper = (key, args...) ->\n      options = (args.pop()).hash\n      if not _.isEmpty(args)\n        options.sprintf = args\n\n      tapI18nextProxy(key, options)\n\n    # template specific helpers\n    if package_name != globals.project_translations_domain\n      # {{_ }}\n      if Template[template]? and Template[template].helpers?\n        helpers = {}\n        helpers[@packages[package_name].helper_name] = underscore_helper\n        Template[template].helpers(helpers)\n\n    # global helpers\n    else\n      # {{_ }}\n      UI.registerHelper @conf.helper_name, underscore_helper\n\n      # {{languageTag}}\n      UI.registerHelper \"languageTag\", () => @getLanguage()\n\n    return\n\n  _getRegisterHelpersProxy: (package_name) ->\n    # A proxy to _registerHelpers where the package_name is fixed to package_name\n    (template) =>\n      @_registerHelpers(package_name, template)\n\n  _prepareLanguageSpecificTranslator: (lang_tag) ->\n    dfd = (new $.Deferred()).resolve().promise()\n\n    if lang_tag of @_languageSpecificTranslatorsTrackers\n      return dfd\n\n    @_languageSpecificTranslatorsTrackers[lang_tag] = new Tracker.Dependency\n\n    if not(lang_tag of @_languageSpecificTranslators)\n      dfd = @_loadLanguage(lang_tag)\n        .done =>\n          @_languageSpecificTranslators[lang_tag] = @_getSpecificLangTranslator(lang_tag)\n\n          @_languageSpecificTranslatorsTrackers[lang_tag].changed()\n\n    return dfd\n\n  _getPackageI18nextProxy: (package_name) ->\n    # A proxy to TAPi18next.t where the namespace is preset to the package's\n\n    (key, options, lang_tag=null) =>\n      # Devs get confused and use lang option instead of lng option, make lang\n      # alias of lng\n      if options?.lang? and not options?.lng?\n        options.lng = options.lang\n\n      if options?.lng? and not lang_tag?\n        lang_tag = options.lng\n        # Remove options.lng so we won't pass it to the regular TAPi18next\n        # before the language specific translator is ready to keep behavior\n        # consistent.\n        #\n        # If lang is actually ready before the language specifc translator is\n        # ready, TAPi18next will translate to lang_tag if we won't remove\n        # options.lng.\n        delete options.lng\n\n      if lang_tag?\n        @_prepareLanguageSpecificTranslator(lang_tag)\n\n        @_languageSpecificTranslatorsTrackers[lang_tag].depend()\n\n        if lang_tag of @_languageSpecificTranslators\n          return @_languageSpecificTranslators[lang_tag] \"#{@_getPackageDomain(package_name)}:#{key}\", options\n        else\n          return TAPi18next.t \"#{@_getPackageDomain(package_name)}:#{key}\", options\n\n      # If inside a reactive computation, we want to invalidate the computation if the client lang changes\n      @_language_changed_tracker.depend()\n\n\n      TAPi18next.t \"#{@_getPackageDomain(package_name)}:#{key}\", options\n\n  _onceEnabled: () ->\n    @_registerHelpers globals.project_translations_domain\n\n  _abortPreviousSetLang: null\n  setLanguage: (lang_tag) ->\n    self = @\n\n    @_abortPreviousSetLang?()\n\n    isAborted = false\n    @_abortPreviousSetLang = -> isAborted = true\n\n    @_loadLanguage(lang_tag).then =>\n      if not isAborted\n        TAPi18next.setLng(lang_tag)\n\n        @_language_changed_tracker.changed()\n        Session.set @_loaded_lang_session_key, lang_tag\n\n  getLanguage: ->\n    if not @._enabled()\n      return null\n\n    session_lang = Session.get @_loaded_lang_session_key\n\n    if session_lang? then session_lang else @._fallback_language\n","var indexOf = [].indexOf;\n\nimport {\n  TAPi18nBase\n} from './tap_i18n-common';\n\nimport {\n  globals\n} from './globals';\n\nexport var TAPi18nClient = (function() {\n  class TAPi18nClient extends TAPi18nBase {\n    _getLanguageFilePath(lang_tag) {\n      var path;\n      if (!this._enabled()) {\n        return null;\n      }\n      path = this.conf.cdn_path != null ? this.conf.cdn_path : this.conf.i18n_files_route;\n      path = path.replace(/\\/$/, \"\");\n      if (Meteor.isCordova && path[0] === \"/\") {\n        path = Meteor.absoluteUrl().replace(/\\/+$/, \"\") + path;\n      }\n      return `${path}/${lang_tag}.json`;\n    }\n\n    _loadLanguage(languageTag) {\n      var dependencyLoadDfd, dfd, directDependencyLanguageTag, loadLanguageTag, project_languages;\n      // Load languageTag and its dependencies languages to TAPi18next if we\n      // haven't loaded them already.\n\n      // languageTag dependencies languages are:\n      // * The base language if languageTag is a dialect.\n      // * The fallback language (en) if we haven't loaded it already.\n\n      // Returns a deferred object that resolves with no arguments if all files\n      // loaded successfully to TAPi18next and rejects with array of error\n      // messages otherwise\n\n      // Example:\n      // TAPi18n._loadLanguage(\"pt-BR\")\n      //   .done(function () {\n      //     console.log(\"languageLoaded successfully\");\n      //   })\n      //   .fail(function (messages) {\n      //     console.log(\"Couldn't load languageTag\", messages);\n      //   })\n\n      // The above example will attempt to load pt-BR, pt and en\n      dfd = new $.Deferred();\n      if (!this._enabled()) {\n        return dfd.reject(\"tap-i18n is not enabled in the project level, check tap-i18n README\");\n      }\n      project_languages = this._getProjectLanguages();\n      if (indexOf.call(project_languages, languageTag) >= 0) {\n        if (indexOf.call(this._loaded_languages, languageTag) < 0) {\n          loadLanguageTag = () => {\n            var jqXHR;\n            jqXHR = $.getJSON(this._getLanguageFilePath(languageTag));\n            jqXHR.done((data) => {\n              this._loadLangFileObject(languageTag, data);\n              this._loaded_languages.push(languageTag);\n              return dfd.resolve();\n            });\n            return jqXHR.fail((xhr, error_code) => {\n              return dfd.reject(`Couldn't load language '${languageTag}' JSON: ${error_code}`);\n            });\n          };\n          directDependencyLanguageTag = indexOf.call(languageTag, \"-\") >= 0 ? languageTag.replace(/-.*/, \"\") : this._fallback_language;\n          // load dependency language if it is part of the project and not the fallback language\n          if (languageTag !== this._fallback_language && indexOf.call(project_languages, directDependencyLanguageTag) >= 0) {\n            dependencyLoadDfd = this._loadLanguage(directDependencyLanguageTag);\n            dependencyLoadDfd.done(() => {\n              // All dependencies loaded successfully\n              return loadLanguageTag();\n            });\n            dependencyLoadDfd.fail((message) => {\n              return dfd.reject(`Loading process failed since dependency language '${directDependencyLanguageTag}' failed to load: ` + message);\n            });\n          } else {\n            loadLanguageTag();\n          }\n        } else {\n          // languageTag loaded already\n          dfd.resolve();\n        }\n      } else {\n        dfd.reject([`Language ${languageTag} is not supported`]);\n      }\n      return dfd.promise();\n    }\n\n    _registerHelpers(package_name, template) {\n      var helpers, tapI18nextProxy, underscore_helper;\n      if (package_name !== globals.project_translations_domain) {\n        tapI18nextProxy = this._getPackageI18nextProxy(this.packages[package_name].namespace);\n      } else {\n        tapI18nextProxy = this._getPackageI18nextProxy(globals.project_translations_domain);\n      }\n      underscore_helper = function(key, ...args) {\n        var options;\n        options = (args.pop()).hash;\n        if (!_.isEmpty(args)) {\n          options.sprintf = args;\n        }\n        return tapI18nextProxy(key, options);\n      };\n      // template specific helpers\n      if (package_name !== globals.project_translations_domain) {\n        // {{_ }}\n        if ((Template[template] != null) && (Template[template].helpers != null)) {\n          helpers = {};\n          helpers[this.packages[package_name].helper_name] = underscore_helper;\n          Template[template].helpers(helpers);\n        }\n      } else {\n        // {{_ }}\n        // global helpers\n        UI.registerHelper(this.conf.helper_name, underscore_helper);\n        // {{languageTag}}\n        UI.registerHelper(\"languageTag\", () => {\n          return this.getLanguage();\n        });\n      }\n    }\n\n    _getRegisterHelpersProxy(package_name) {\n      // A proxy to _registerHelpers where the package_name is fixed to package_name\n      return (template) => {\n        return this._registerHelpers(package_name, template);\n      };\n    }\n\n    _prepareLanguageSpecificTranslator(lang_tag) {\n      var dfd;\n      dfd = (new $.Deferred()).resolve().promise();\n      if (lang_tag in this._languageSpecificTranslatorsTrackers) {\n        return dfd;\n      }\n      this._languageSpecificTranslatorsTrackers[lang_tag] = new Tracker.Dependency;\n      if (!(lang_tag in this._languageSpecificTranslators)) {\n        dfd = this._loadLanguage(lang_tag).done(() => {\n          this._languageSpecificTranslators[lang_tag] = this._getSpecificLangTranslator(lang_tag);\n          return this._languageSpecificTranslatorsTrackers[lang_tag].changed();\n        });\n      }\n      return dfd;\n    }\n\n    _getPackageI18nextProxy(package_name) {\n      // A proxy to TAPi18next.t where the namespace is preset to the package's\n      return (key, options, lang_tag = null) => {\n        // Devs get confused and use lang option instead of lng option, make lang\n        // alias of lng\n        if (((options != null ? options.lang : void 0) != null) && ((options != null ? options.lng : void 0) == null)) {\n          options.lng = options.lang;\n        }\n        if (((options != null ? options.lng : void 0) != null) && (lang_tag == null)) {\n          lang_tag = options.lng;\n          // Remove options.lng so we won't pass it to the regular TAPi18next\n          // before the language specific translator is ready to keep behavior\n          // consistent.\n\n          // If lang is actually ready before the language specifc translator is\n          // ready, TAPi18next will translate to lang_tag if we won't remove\n          // options.lng.\n          delete options.lng;\n        }\n        if (lang_tag != null) {\n          this._prepareLanguageSpecificTranslator(lang_tag);\n          this._languageSpecificTranslatorsTrackers[lang_tag].depend();\n          if (lang_tag in this._languageSpecificTranslators) {\n            return this._languageSpecificTranslators[lang_tag](`${this._getPackageDomain(package_name)}:${key}`, options);\n          } else {\n            return TAPi18next.t(`${this._getPackageDomain(package_name)}:${key}`, options);\n          }\n        }\n        // If inside a reactive computation, we want to invalidate the computation if the client lang changes\n        this._language_changed_tracker.depend();\n        return TAPi18next.t(`${this._getPackageDomain(package_name)}:${key}`, options);\n      };\n    }\n\n    _onceEnabled() {\n      return this._registerHelpers(globals.project_translations_domain);\n    }\n\n    setLanguage(lang_tag) {\n      var isAborted, self;\n      self = this;\n      if (typeof this._abortPreviousSetLang === \"function\") {\n        this._abortPreviousSetLang();\n      }\n      isAborted = false;\n      this._abortPreviousSetLang = function() {\n        return isAborted = true;\n      };\n      return this._loadLanguage(lang_tag).then(() => {\n        if (!isAborted) {\n          TAPi18next.setLng(lang_tag);\n          this._language_changed_tracker.changed();\n          return Session.set(this._loaded_lang_session_key, lang_tag);\n        }\n      });\n    }\n\n    getLanguage() {\n      var session_lang;\n      if (!this._enabled()) {\n        return null;\n      }\n      session_lang = Session.get(this._loaded_lang_session_key);\n      if (session_lang != null) {\n        return session_lang;\n      } else {\n        return this._fallback_language;\n      }\n    }\n\n  };\n\n  TAPi18nClient.prototype._languageSpecificTranslators = null;\n\n  TAPi18nClient.prototype._languageSpecificTranslatorsTrackers = null;\n\n  TAPi18nClient.prototype._abortPreviousSetLang = null;\n\n  return TAPi18nClient;\n\n}).call(this);\n"]}}