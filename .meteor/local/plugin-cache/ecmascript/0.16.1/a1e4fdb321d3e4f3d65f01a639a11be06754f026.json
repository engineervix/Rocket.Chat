{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/sodiumplus.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"imports/client/sodium-plus/lib/sodiumplus.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/sodiumplus.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/sodiumplus.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/client/sodium-plus/lib/sodiumplus.js"}},"code":"!function (module1) {\n  var _slicedToArray;\n\n  module1.link(\"@babel/runtime/helpers/slicedToArray\", {\n    default: function (v) {\n      _slicedToArray = v;\n    }\n  }, 0);\n\n  var _regeneratorRuntime;\n\n  module1.link(\"@babel/runtime/regenerator\", {\n    default: function (v) {\n      _regeneratorRuntime = v;\n    }\n  }, 1);\n\n  var Backend = require('./backend');\n\n  var CryptographyKey = require('./cryptography-key');\n\n  var Ed25519SecretKey = require('./keytypes/ed25519sk');\n\n  var Ed25519PublicKey = require('./keytypes/ed25519pk');\n\n  var LibsodiumWrappersBackend = require('./backend/libsodium-wrappers');\n\n  var SodiumError = require('./sodium-error');\n\n  var SodiumNativeBackend = require('./backend/sodiumnative');\n\n  var X25519PublicKey = require('./keytypes/x25519pk');\n\n  var X25519SecretKey = require('./keytypes/x25519sk');\n\n  var Util = require('./util');\n  /* istanbul ignore if */\n\n\n  if (typeof Buffer === 'undefined') {\n    var _Buffer = require('buffer/').Buffer;\n  }\n\n  var SodiumPlus = /*#__PURE__*/function () {\n    function SodiumPlus(backend) {\n      /* istanbul ignore if */\n      if (!(backend instanceof Backend)) {\n        throw new TypeError('Backend object must implement the backend function');\n      }\n\n      this.backend = backend;\n      Util.populateConstants(this);\n    }\n    /**\n     * Returns the name of the current active backend.\n     * This method is NOT async.\n     *\n     * @return {string}\n     */\n\n\n    var _proto = SodiumPlus.prototype;\n\n    _proto.getBackendName = function () {\n      function getBackendName() {\n        return this.backend.backendName;\n      }\n\n      return getBackendName;\n    }()\n    /**\n     * Is this powered by sodium-native?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    ;\n\n    _proto.isSodiumNative = function () {\n      function isSodiumNative() {\n        return this.backend instanceof SodiumNativeBackend;\n      }\n\n      return isSodiumNative;\n    }()\n    /**\n     * Is this powered by libsodium-wrappers?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    ;\n\n    _proto.isLibsodiumWrappers = function () {\n      function isLibsodiumWrappers() {\n        return this.backend instanceof LibsodiumWrappersBackend;\n      }\n\n      return isLibsodiumWrappers;\n    }()\n    /**\n     * Automatically select a backend.\n     *\n     * @return {Promise<SodiumPlus>}\n     */\n    ;\n\n    SodiumPlus.auto = function () {\n      function auto() {\n        var backend;\n        return _regeneratorRuntime.async(function () {\n          function auto$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return _regeneratorRuntime.awrap(SodiumNativeBackend.init());\n\n                case 3:\n                  backend = _context.sent;\n                  _context.next = 11;\n                  break;\n\n                case 6:\n                  _context.prev = 6;\n                  _context.t0 = _context[\"catch\"](0);\n                  _context.next = 10;\n                  return _regeneratorRuntime.awrap(LibsodiumWrappersBackend.init());\n\n                case 10:\n                  backend = _context.sent;\n\n                case 11:\n                  if (backend) {\n                    _context.next = 15;\n                    break;\n                  }\n\n                  _context.next = 14;\n                  return _regeneratorRuntime.awrap(LibsodiumWrappersBackend.init());\n\n                case 14:\n                  backend = _context.sent;\n\n                case 15:\n                  Util.populateConstants(backend);\n                  return _context.abrupt(\"return\", new SodiumPlus(backend));\n\n                case 17:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }\n\n          return auto$;\n        }(), null, null, [[0, 6]], Promise);\n      }\n\n      return auto;\n    }()\n    /**\n     * If our backend isn't defined, it will trigger an autoload.\n     *\n     * Mostly used internally. `await SodiumPlus.auto()` provides the same\n     * exact guarantee as this method.\n     *\n     * @return {Promise<void>}\n     */\n    ;\n\n    _proto.ensureLoaded = function () {\n      function ensureLoaded() {\n        return _regeneratorRuntime.async(function () {\n          function ensureLoaded$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(typeof this.backend === 'undefined')) {\n                    _context2.next = 11;\n                    break;\n                  }\n\n                  _context2.prev = 1;\n                  _context2.next = 4;\n                  return _regeneratorRuntime.awrap(SodiumPlus.auto());\n\n                case 4:\n                  _context2.next = 11;\n                  break;\n\n                case 6:\n                  _context2.prev = 6;\n                  _context2.t0 = _context2[\"catch\"](1);\n                  _context2.next = 10;\n                  return _regeneratorRuntime.awrap(LibsodiumWrappersBackend.init());\n\n                case 10:\n                  this.backend = _context2.sent;\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }\n\n          return ensureLoaded$;\n        }(), null, this, [[1, 6]], Promise);\n      }\n\n      return ensureLoaded;\n    }()\n    /**\n     * Decrypt a message (and optional associated data) with XChaCha20-Poly1305\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    ;\n\n    _proto.crypto_aead_xchacha20poly1305_ietf_decrypt = function () {\n      function crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, nonce, key) {\n        var assocData,\n            _args3 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_aead_xchacha20poly1305_ietf_decrypt$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  assocData = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : '';\n                  _context3.next = 3;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 3:\n                  if (!(nonce.length !== 24)) {\n                    _context3.next = 5;\n                    break;\n                  }\n\n                  throw new SodiumError('Argument 2 must be 24 bytes');\n\n                case 5:\n                  if (key instanceof CryptographyKey) {\n                    _context3.next = 7;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n\n                case 7:\n                  _context3.t0 = _regeneratorRuntime;\n                  _context3.t1 = this.backend;\n                  _context3.next = 11;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ciphertext));\n\n                case 11:\n                  _context3.t2 = _context3.sent;\n\n                  if (!(assocData.length > 0)) {\n                    _context3.next = 18;\n                    break;\n                  }\n\n                  _context3.next = 15;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(assocData));\n\n                case 15:\n                  _context3.t3 = _context3.sent;\n                  _context3.next = 19;\n                  break;\n\n                case 18:\n                  _context3.t3 = null;\n\n                case 19:\n                  _context3.t4 = _context3.t3;\n                  _context3.next = 22;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 22:\n                  _context3.t5 = _context3.sent;\n                  _context3.t6 = key;\n                  _context3.t7 = _context3.t1.crypto_aead_xchacha20poly1305_ietf_decrypt.call(_context3.t1, _context3.t2, _context3.t4, _context3.t5, _context3.t6);\n                  _context3.next = 27;\n                  return _context3.t0.awrap.call(_context3.t0, _context3.t7);\n\n                case 27:\n                  return _context3.abrupt(\"return\", _context3.sent);\n\n                case 28:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }\n\n          return crypto_aead_xchacha20poly1305_ietf_decrypt$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_aead_xchacha20poly1305_ietf_decrypt;\n    }()\n    /**\n     * Encrypt a message (and optional associated data) with XChaCha20-Poly1305.\n     *\n     * Throws a SodiumError if an invalid ciphertext/AAD is provided for this\n     * nonce and key.\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    ;\n\n    _proto.crypto_aead_xchacha20poly1305_ietf_encrypt = function () {\n      function crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, nonce, key) {\n        var assocData,\n            _args4 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_aead_xchacha20poly1305_ietf_encrypt$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  assocData = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : '';\n                  _context4.next = 3;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 3:\n                  if (!(nonce.length !== 24)) {\n                    _context4.next = 5;\n                    break;\n                  }\n\n                  throw new SodiumError('Argument 2 must be 24 bytes');\n\n                case 5:\n                  if (key instanceof CryptographyKey) {\n                    _context4.next = 7;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n\n                case 7:\n                  _context4.t0 = _regeneratorRuntime;\n                  _context4.t1 = this.backend;\n                  _context4.next = 11;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 11:\n                  _context4.t2 = _context4.sent;\n\n                  if (!(assocData.length > 0)) {\n                    _context4.next = 18;\n                    break;\n                  }\n\n                  _context4.next = 15;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(assocData));\n\n                case 15:\n                  _context4.t3 = _context4.sent;\n                  _context4.next = 19;\n                  break;\n\n                case 18:\n                  _context4.t3 = null;\n\n                case 19:\n                  _context4.t4 = _context4.t3;\n                  _context4.next = 22;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 22:\n                  _context4.t5 = _context4.sent;\n                  _context4.t6 = key;\n                  _context4.t7 = _context4.t1.crypto_aead_xchacha20poly1305_ietf_encrypt.call(_context4.t1, _context4.t2, _context4.t4, _context4.t5, _context4.t6);\n                  _context4.next = 27;\n                  return _context4.t0.awrap.call(_context4.t0, _context4.t7);\n\n                case 27:\n                  return _context4.abrupt(\"return\", _context4.sent);\n\n                case 28:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }\n\n          return crypto_aead_xchacha20poly1305_ietf_encrypt$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_aead_xchacha20poly1305_ietf_encrypt;\n    }()\n    /**\n     * Generate an XChaCha20-Poly1305 key.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_aead_xchacha20poly1305_ietf_keygen = function () {\n      function crypto_aead_xchacha20poly1305_ietf_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_aead_xchacha20poly1305_ietf_keygen$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.t0 = CryptographyKey;\n                  _context5.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(32));\n\n                case 3:\n                  _context5.t1 = _context5.sent;\n                  return _context5.abrupt(\"return\", new _context5.t0(_context5.t1));\n\n                case 5:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }\n\n          return crypto_aead_xchacha20poly1305_ietf_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_aead_xchacha20poly1305_ietf_keygen;\n    }()\n    /**\n     * Get an authenticator for a message for a given key.\n     *\n     * Algorithm: HMAC-SHA512 truncated to 32 bytes.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_auth = function () {\n      function crypto_auth(message, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_auth$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (key instanceof CryptographyKey) {\n                    _context6.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n\n                case 4:\n                  _context6.next = 6;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 6:\n                  _context6.t0 = _regeneratorRuntime;\n                  _context6.t1 = this.backend;\n                  _context6.next = 10;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 10:\n                  _context6.t2 = _context6.sent;\n                  _context6.t3 = key;\n                  _context6.t4 = _context6.t1.crypto_auth.call(_context6.t1, _context6.t2, _context6.t3);\n                  _context6.next = 15;\n                  return _context6.t0.awrap.call(_context6.t0, _context6.t4);\n\n                case 15:\n                  return _context6.abrupt(\"return\", _context6.sent);\n\n                case 16:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }\n\n          return crypto_auth$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_auth;\n    }()\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_auth_keygen = function () {\n      function crypto_auth_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_auth_keygen$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.t0 = CryptographyKey;\n                  _context7.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(32));\n\n                case 3:\n                  _context7.t1 = _context7.sent;\n                  return _context7.abrupt(\"return\", new _context7.t0(_context7.t1));\n\n                case 5:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }\n\n          return crypto_auth_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_auth_keygen;\n    }()\n    /**\n     * Verify an authenticator for a message for a given key.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} mac\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_auth_verify = function () {\n      function crypto_auth_verify(message, key, mac) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_auth_verify$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  _context8.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (key instanceof CryptographyKey) {\n                    _context8.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n\n                case 4:\n                  _context8.next = 6;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 6:\n                  _context8.t0 = _regeneratorRuntime;\n                  _context8.t1 = this.backend;\n                  _context8.next = 10;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(mac));\n\n                case 10:\n                  _context8.t2 = _context8.sent;\n                  _context8.next = 13;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 13:\n                  _context8.t3 = _context8.sent;\n                  _context8.t4 = key;\n                  _context8.t5 = _context8.t1.crypto_auth_verify.call(_context8.t1, _context8.t2, _context8.t3, _context8.t4);\n                  _context8.next = 18;\n                  return _context8.t0.awrap.call(_context8.t0, _context8.t5);\n\n                case 18:\n                  return _context8.abrupt(\"return\", _context8.sent);\n\n                case 19:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }\n\n          return crypto_auth_verify$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_auth_verify;\n    }()\n    /**\n     * Public-key authenticated encryption.\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_box = function () {\n      function crypto_box(plaintext, nonce, myPrivateKey, theirPublicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  _context9.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (myPrivateKey instanceof X25519SecretKey) {\n                    _context9.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n\n                case 4:\n                  if (theirPublicKey instanceof X25519PublicKey) {\n                    _context9.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n\n                case 6:\n                  _context9.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 8:\n                  nonce = _context9.sent;\n\n                  if (!(nonce.length !== 24)) {\n                    _context9.next = 11;\n                    break;\n                  }\n\n                  throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n\n                case 11:\n                  _context9.t0 = this.backend;\n                  _context9.next = 14;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 14:\n                  _context9.t1 = _context9.sent;\n                  _context9.next = 17;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 17:\n                  _context9.t2 = _context9.sent;\n                  _context9.t3 = myPrivateKey;\n                  _context9.t4 = theirPublicKey;\n                  return _context9.abrupt(\"return\", _context9.t0.crypto_box.call(_context9.t0, _context9.t1, _context9.t2, _context9.t3, _context9.t4));\n\n                case 21:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }\n\n          return crypto_box$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box;\n    }()\n    /**\n     * Public-key authenticated decryption.\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_box_open = function () {\n      function crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_open$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  _context10.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (myPrivateKey instanceof X25519SecretKey) {\n                    _context10.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n\n                case 4:\n                  if (theirPublicKey instanceof X25519PublicKey) {\n                    _context10.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n\n                case 6:\n                  _context10.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ciphertext));\n\n                case 8:\n                  ciphertext = _context10.sent;\n\n                  if (!(ciphertext.length < 16)) {\n                    _context10.next = 11;\n                    break;\n                  }\n\n                  throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n\n                case 11:\n                  _context10.next = 13;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 13:\n                  nonce = _context10.sent;\n\n                  if (!(nonce.length !== 24)) {\n                    _context10.next = 16;\n                    break;\n                  }\n\n                  throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n\n                case 16:\n                  return _context10.abrupt(\"return\", this.backend.crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey));\n\n                case 17:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }\n\n          return crypto_box_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_open;\n    }()\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_box_keypair = function () {\n      function crypto_box_keypair() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_keypair$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  _context11.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context11.abrupt(\"return\", this.backend.crypto_box_keypair());\n\n                case 3:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }\n\n          return crypto_box_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_keypair;\n    }()\n    /**\n     * Combine two X25519 keys (secret, public) into a keypair object.\n     *\n     * @param {X25519SecretKey} sKey\n     * @param {X25519PublicKey} pKey\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_box_keypair_from_secretkey_and_publickey = function () {\n      function crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_keypair_from_secretkey_and_publickey$(_context12) {\n            while (1) {\n              switch (_context12.prev = _context12.next) {\n                case 0:\n                  _context12.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (sKey instanceof X25519SecretKey) {\n                    _context12.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n\n                case 4:\n                  if (pKey instanceof X25519PublicKey) {\n                    _context12.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n\n                case 6:\n                  _context12.next = 8;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey));\n\n                case 8:\n                  return _context12.abrupt(\"return\", _context12.sent);\n\n                case 9:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }\n          }\n\n          return crypto_box_keypair_from_secretkey_and_publickey$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_keypair_from_secretkey_and_publickey;\n    }()\n    /**\n     * Extract the secret key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519SecretKey>}\n     */\n    ;\n\n    _proto.crypto_box_secretkey = function () {\n      function crypto_box_secretkey(keypair) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_secretkey$(_context13) {\n            while (1) {\n              switch (_context13.prev = _context13.next) {\n                case 0:\n                  if (!(keypair.getLength() !== 64)) {\n                    _context13.next = 2;\n                    break;\n                  }\n\n                  throw new SodiumError('Keypair must be 64 bytes');\n\n                case 2:\n                  return _context13.abrupt(\"return\", new X25519SecretKey(Buffer.from(keypair.getBuffer().slice(0, 32))));\n\n                case 3:\n                case \"end\":\n                  return _context13.stop();\n              }\n            }\n          }\n\n          return crypto_box_secretkey$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_box_secretkey;\n    }()\n    /**\n     * Extract the public key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519PublicKey>}\n     */\n    ;\n\n    _proto.crypto_box_publickey = function () {\n      function crypto_box_publickey(keypair) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_publickey$(_context14) {\n            while (1) {\n              switch (_context14.prev = _context14.next) {\n                case 0:\n                  if (!(keypair.getLength() !== 64)) {\n                    _context14.next = 2;\n                    break;\n                  }\n\n                  throw new SodiumError('Keypair must be 64 bytes');\n\n                case 2:\n                  return _context14.abrupt(\"return\", new X25519PublicKey(Buffer.from(keypair.getBuffer().slice(32, 64))));\n\n                case 3:\n                case \"end\":\n                  return _context14.stop();\n              }\n            }\n          }\n\n          return crypto_box_publickey$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_box_publickey;\n    }()\n    /**\n     * Derive the public key from a given X25519 secret key.\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    ;\n\n    _proto.crypto_box_publickey_from_secretkey = function () {\n      function crypto_box_publickey_from_secretkey(secretKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_publickey_from_secretkey$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  _context15.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (secretKey instanceof X25519SecretKey) {\n                    _context15.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n\n                case 4:\n                  _context15.t0 = X25519PublicKey;\n                  _context15.next = 7;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_scalarmult_base(secretKey));\n\n                case 7:\n                  _context15.t1 = _context15.sent;\n                  return _context15.abrupt(\"return\", new _context15.t0(_context15.t1));\n\n                case 9:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }\n\n          return crypto_box_publickey_from_secretkey$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_publickey_from_secretkey;\n    }()\n    /**\n     * Anonymous public-key encryption. (Message integrity is still assured.)\n     *\n     * @param {string|Buffer} plaintext\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_box_seal = function () {\n      function crypto_box_seal(plaintext, publicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_seal$(_context16) {\n            while (1) {\n              switch (_context16.prev = _context16.next) {\n                case 0:\n                  _context16.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (publicKey instanceof X25519PublicKey) {\n                    _context16.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n\n                case 4:\n                  _context16.next = 6;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_box_seal(plaintext, publicKey));\n\n                case 6:\n                  return _context16.abrupt(\"return\", _context16.sent);\n\n                case 7:\n                case \"end\":\n                  return _context16.stop();\n              }\n            }\n          }\n\n          return crypto_box_seal$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_seal;\n    }()\n    /**\n     * Anonymous public-key decryption. (Message integrity is still assured.)\n     *\n     * @param {Buffer} ciphertext\n     * @param {X25519PublicKey} publicKey\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_box_seal_open = function () {\n      function crypto_box_seal_open(ciphertext, publicKey, secretKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_seal_open$(_context17) {\n            while (1) {\n              switch (_context17.prev = _context17.next) {\n                case 0:\n                  _context17.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (publicKey instanceof X25519PublicKey) {\n                    _context17.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n\n                case 4:\n                  if (secretKey instanceof X25519SecretKey) {\n                    _context17.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n\n                case 6:\n                  _context17.t0 = _regeneratorRuntime;\n                  _context17.t1 = this.backend;\n                  _context17.next = 10;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ciphertext));\n\n                case 10:\n                  _context17.t2 = _context17.sent;\n                  _context17.t3 = publicKey;\n                  _context17.t4 = secretKey;\n                  _context17.t5 = _context17.t1.crypto_box_seal_open.call(_context17.t1, _context17.t2, _context17.t3, _context17.t4);\n                  _context17.next = 16;\n                  return _context17.t0.awrap.call(_context17.t0, _context17.t5);\n\n                case 16:\n                  return _context17.abrupt(\"return\", _context17.sent);\n\n                case 17:\n                case \"end\":\n                  return _context17.stop();\n              }\n            }\n          }\n\n          return crypto_box_seal_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_seal_open;\n    }()\n    /**\n     * Generic-purpose cryptographic hash.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_generichash = function () {\n      function crypto_generichash(message) {\n        var key,\n            outputLength,\n            _args18 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash$(_context18) {\n            while (1) {\n              switch (_context18.prev = _context18.next) {\n                case 0:\n                  key = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : null;\n                  outputLength = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : 32;\n                  _context18.next = 4;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 4:\n                  _context18.next = 6;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_generichash(message, key, outputLength));\n\n                case 6:\n                  return _context18.abrupt(\"return\", _context18.sent);\n\n                case 7:\n                case \"end\":\n                  return _context18.stop();\n              }\n            }\n          }\n\n          return crypto_generichash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash;\n    }()\n    /**\n     * Initialize a BLAKE2 hash context for stream hashing.\n     *\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_generichash_init = function () {\n      function crypto_generichash_init() {\n        var key,\n            outputLength,\n            _args19 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_init$(_context19) {\n            while (1) {\n              switch (_context19.prev = _context19.next) {\n                case 0:\n                  key = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : null;\n                  outputLength = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : 32;\n                  _context19.next = 4;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 4:\n                  _context19.next = 6;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_generichash_init(key, outputLength));\n\n                case 6:\n                  return _context19.abrupt(\"return\", _context19.sent);\n\n                case 7:\n                case \"end\":\n                  return _context19.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_init$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_init;\n    }()\n    /**\n     * Update the BLAKE2 hash state with a block of data.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    ;\n\n    _proto.crypto_generichash_update = function () {\n      function crypto_generichash_update(state, message) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_update$(_context20) {\n            while (1) {\n              switch (_context20.prev = _context20.next) {\n                case 0:\n                  _context20.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context20.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_generichash_update(state, message));\n\n                case 4:\n                  return _context20.abrupt(\"return\", _context20.sent);\n\n                case 5:\n                case \"end\":\n                  return _context20.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_update$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_update;\n    }()\n    /**\n     * Obtain the final BLAKE2 hash output.\n     *\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_generichash_final = function () {\n      function crypto_generichash_final(state) {\n        var outputLength,\n            _args21 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_final$(_context21) {\n            while (1) {\n              switch (_context21.prev = _context21.next) {\n                case 0:\n                  outputLength = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : 32;\n                  _context21.next = 3;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 3:\n                  _context21.next = 5;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_generichash_final(state, outputLength));\n\n                case 5:\n                  return _context21.abrupt(\"return\", _context21.sent);\n\n                case 6:\n                case \"end\":\n                  return _context21.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_final$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_final;\n    }()\n    /**\n     * Generate a 256-bit random key for BLAKE2.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_generichash_keygen = function () {\n      function crypto_generichash_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_keygen$(_context22) {\n            while (1) {\n              switch (_context22.prev = _context22.next) {\n                case 0:\n                  _context22.t0 = CryptographyKey;\n                  _context22.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(this.CRYPTO_GENERICHASH_KEYBYTES));\n\n                case 3:\n                  _context22.t1 = _context22.sent;\n                  return _context22.abrupt(\"return\", new _context22.t0(_context22.t1));\n\n                case 5:\n                case \"end\":\n                  return _context22.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_keygen;\n    }()\n    /**\n     * Derive a subkey from a master key.\n     *\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_kdf_derive_from_key = function () {\n      function crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_kdf_derive_from_key$(_context23) {\n            while (1) {\n              switch (_context23.prev = _context23.next) {\n                case 0:\n                  _context23.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (!(length < 1)) {\n                    _context23.next = 4;\n                    break;\n                  }\n\n                  throw new SodiumError('Length must be a positive integer.');\n\n                case 4:\n                  if (!(subKeyId < 0)) {\n                    _context23.next = 6;\n                    break;\n                  }\n\n                  throw new SodiumError('Key ID must be an unsigned integer');\n\n                case 6:\n                  _context23.next = 8;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_kdf_derive_from_key(length, subKeyId, context, key));\n\n                case 8:\n                  return _context23.abrupt(\"return\", _context23.sent);\n\n                case 9:\n                case \"end\":\n                  return _context23.stop();\n              }\n            }\n          }\n\n          return crypto_kdf_derive_from_key$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kdf_derive_from_key;\n    }()\n    /**\n     * Generate a 256-bit random key for our KDF.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_kdf_keygen = function () {\n      function crypto_kdf_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_kdf_keygen$(_context24) {\n            while (1) {\n              switch (_context24.prev = _context24.next) {\n                case 0:\n                  _context24.t0 = CryptographyKey;\n                  _context24.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(this.CRYPTO_KDF_KEYBYTES));\n\n                case 3:\n                  _context24.t1 = _context24.sent;\n                  return _context24.abrupt(\"return\", new _context24.t0(_context24.t1));\n\n                case 5:\n                case \"end\":\n                  return _context24.stop();\n              }\n            }\n          }\n\n          return crypto_kdf_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kdf_keygen;\n    }()\n    /**\n     * This is functionally identical to crypto_box_keypair().\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_kx_keypair = function () {\n      function crypto_kx_keypair() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_kx_keypair$(_context25) {\n            while (1) {\n              switch (_context25.prev = _context25.next) {\n                case 0:\n                  return _context25.abrupt(\"return\", this.crypto_box_keypair());\n\n                case 1:\n                case \"end\":\n                  return _context25.stop();\n              }\n            }\n          }\n\n          return crypto_kx_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kx_keypair;\n    }()\n    /**\n     * Generate an X25519 keypair from a seed.\n     *\n     * @param {string|Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_kx_seed_keypair = function () {\n      function crypto_kx_seed_keypair(seed) {\n        var sk, pk;\n        return _regeneratorRuntime.async(function () {\n          function crypto_kx_seed_keypair$(_context26) {\n            while (1) {\n              switch (_context26.prev = _context26.next) {\n                case 0:\n                  _context26.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context26.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_generichash(seed, null, this.CRYPTO_KX_SECRETKEYBYTES));\n\n                case 4:\n                  sk = _context26.sent;\n                  _context26.next = 7;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_scalarmult_base(new CryptographyKey(sk)));\n\n                case 7:\n                  pk = _context26.sent;\n                  return _context26.abrupt(\"return\", new CryptographyKey(Buffer.concat([sk, pk])));\n\n                case 9:\n                case \"end\":\n                  return _context26.stop();\n              }\n            }\n          }\n\n          return crypto_kx_seed_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kx_seed_keypair;\n    }()\n    /**\n     * Perform a key exchange from the client's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the server to the client (incoming decryption).\n     * The second is meant for data sent from the client to the server (outgoing encryption).\n     *\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    ;\n\n    _proto.crypto_kx_client_session_keys = function () {\n      function crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_kx_client_session_keys$(_context27) {\n            while (1) {\n              switch (_context27.prev = _context27.next) {\n                case 0:\n                  _context27.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (clientPublicKey instanceof X25519PublicKey) {\n                    _context27.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n\n                case 4:\n                  if (clientSecretKey instanceof X25519SecretKey) {\n                    _context27.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n\n                case 6:\n                  if (serverPublicKey instanceof X25519PublicKey) {\n                    _context27.next = 8;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n\n                case 8:\n                  return _context27.abrupt(\"return\", this.backend.crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey));\n\n                case 9:\n                case \"end\":\n                  return _context27.stop();\n              }\n            }\n          }\n\n          return crypto_kx_client_session_keys$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kx_client_session_keys;\n    }()\n    /**\n     * Perform a key exchange from the server's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the client to the server (incoming decryption).\n     * The second is meant for data sent from the server to the client (outgoing encryption).\n     *\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    ;\n\n    _proto.crypto_kx_server_session_keys = function () {\n      function crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_kx_server_session_keys$(_context28) {\n            while (1) {\n              switch (_context28.prev = _context28.next) {\n                case 0:\n                  _context28.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (serverPublicKey instanceof X25519PublicKey) {\n                    _context28.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n\n                case 4:\n                  if (serverSecretKey instanceof X25519SecretKey) {\n                    _context28.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n\n                case 6:\n                  if (clientPublicKey instanceof X25519PublicKey) {\n                    _context28.next = 8;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n\n                case 8:\n                  return _context28.abrupt(\"return\", this.backend.crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey));\n\n                case 9:\n                case \"end\":\n                  return _context28.stop();\n              }\n            }\n          }\n\n          return crypto_kx_server_session_keys$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kx_server_session_keys;\n    }()\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_onetimeauth = function () {\n      function crypto_onetimeauth(message, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_onetimeauth$(_context29) {\n            while (1) {\n              switch (_context29.prev = _context29.next) {\n                case 0:\n                  if (key instanceof CryptographyKey) {\n                    _context29.next = 2;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n\n                case 2:\n                  _context29.t0 = _regeneratorRuntime;\n                  _context29.t1 = this.backend;\n                  _context29.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 6:\n                  _context29.t2 = _context29.sent;\n                  _context29.t3 = key;\n                  _context29.t4 = _context29.t1.crypto_onetimeauth.call(_context29.t1, _context29.t2, _context29.t3);\n                  _context29.next = 11;\n                  return _context29.t0.awrap.call(_context29.t0, _context29.t4);\n\n                case 11:\n                  return _context29.abrupt(\"return\", _context29.sent);\n\n                case 12:\n                case \"end\":\n                  return _context29.stop();\n              }\n            }\n          }\n\n          return crypto_onetimeauth$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_onetimeauth;\n    }()\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_onetimeauth_verify = function () {\n      function crypto_onetimeauth_verify(message, key, tag) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_onetimeauth_verify$(_context30) {\n            while (1) {\n              switch (_context30.prev = _context30.next) {\n                case 0:\n                  if (key instanceof CryptographyKey) {\n                    _context30.next = 2;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n\n                case 2:\n                  _context30.t0 = _regeneratorRuntime;\n                  _context30.t1 = this.backend;\n                  _context30.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 6:\n                  _context30.t2 = _context30.sent;\n                  _context30.t3 = key;\n                  _context30.next = 10;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(tag));\n\n                case 10:\n                  _context30.t4 = _context30.sent;\n                  _context30.t5 = _context30.t1.crypto_onetimeauth_verify.call(_context30.t1, _context30.t2, _context30.t3, _context30.t4);\n                  _context30.next = 14;\n                  return _context30.t0.awrap.call(_context30.t0, _context30.t5);\n\n                case 14:\n                  return _context30.abrupt(\"return\", _context30.sent);\n\n                case 15:\n                case \"end\":\n                  return _context30.stop();\n              }\n            }\n          }\n\n          return crypto_onetimeauth_verify$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_onetimeauth_verify;\n    }()\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_onetimeauth_keygen = function () {\n      function crypto_onetimeauth_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_onetimeauth_keygen$(_context31) {\n            while (1) {\n              switch (_context31.prev = _context31.next) {\n                case 0:\n                  _context31.t0 = CryptographyKey;\n                  _context31.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(32));\n\n                case 3:\n                  _context31.t1 = _context31.sent;\n                  return _context31.abrupt(\"return\", new _context31.t0(_context31.t1));\n\n                case 5:\n                case \"end\":\n                  return _context31.stop();\n              }\n            }\n          }\n\n          return crypto_onetimeauth_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_onetimeauth_keygen;\n    }()\n    /**\n     * Derive a cryptography key from a password and salt.\n     *\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number|null} algorithm\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_pwhash = function () {\n      function crypto_pwhash(length, password, salt, opslimit, memlimit) {\n        var algorithm,\n            _args32 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash$(_context32) {\n            while (1) {\n              switch (_context32.prev = _context32.next) {\n                case 0:\n                  algorithm = _args32.length > 5 && _args32[5] !== undefined ? _args32[5] : null;\n                  _context32.next = 3;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 3:\n                  /* istanbul ignore if */\n                  if (!algorithm) {\n                    algorithm = this.CRYPTO_PWHASH_ALG_DEFAULT;\n                  }\n\n                  _context32.t0 = CryptographyKey;\n                  _context32.t1 = _regeneratorRuntime;\n                  _context32.t2 = this.backend;\n                  _context32.t3 = length;\n                  _context32.next = 10;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(password));\n\n                case 10:\n                  _context32.t4 = _context32.sent;\n                  _context32.next = 13;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(salt));\n\n                case 13:\n                  _context32.t5 = _context32.sent;\n                  _context32.t6 = opslimit;\n                  _context32.t7 = memlimit;\n                  _context32.t8 = algorithm;\n                  _context32.t9 = _context32.t2.crypto_pwhash.call(_context32.t2, _context32.t3, _context32.t4, _context32.t5, _context32.t6, _context32.t7, _context32.t8);\n                  _context32.next = 20;\n                  return _context32.t1.awrap.call(_context32.t1, _context32.t9);\n\n                case 20:\n                  _context32.t10 = _context32.sent;\n                  return _context32.abrupt(\"return\", new _context32.t0(_context32.t10));\n\n                case 22:\n                case \"end\":\n                  return _context32.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_pwhash;\n    }()\n    /**\n     * Get a password hash (in a safe-for-storage format)\n     *\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    ;\n\n    _proto.crypto_pwhash_str = function () {\n      function crypto_pwhash_str(password, opslimit, memlimit) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash_str$(_context33) {\n            while (1) {\n              switch (_context33.prev = _context33.next) {\n                case 0:\n                  _context33.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context33.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_pwhash_str(password, opslimit, memlimit));\n\n                case 4:\n                  return _context33.abrupt(\"return\", _context33.sent);\n\n                case 5:\n                case \"end\":\n                  return _context33.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash_str$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_pwhash_str;\n    }()\n    /**\n     * Verify a password against a known password hash\n     *\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_pwhash_str_verify = function () {\n      function crypto_pwhash_str_verify(password, hash) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash_str_verify$(_context34) {\n            while (1) {\n              switch (_context34.prev = _context34.next) {\n                case 0:\n                  _context34.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context34.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_pwhash_str_verify(password, hash));\n\n                case 4:\n                  return _context34.abrupt(\"return\", _context34.sent);\n\n                case 5:\n                case \"end\":\n                  return _context34.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash_str_verify$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_pwhash_str_verify;\n    }()\n    /**\n     * Does this password need to be rehashed?\n     *\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_pwhash_str_needs_rehash = function () {\n      function crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash_str_needs_rehash$(_context35) {\n            while (1) {\n              switch (_context35.prev = _context35.next) {\n                case 0:\n                  _context35.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context35.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit));\n\n                case 4:\n                  return _context35.abrupt(\"return\", _context35.sent);\n\n                case 5:\n                case \"end\":\n                  return _context35.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash_str_needs_rehash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_pwhash_str_needs_rehash;\n    }()\n    /**\n     * Elliptic Curve Diffie-Hellman key exchange\n     *\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_scalarmult = function () {\n      function crypto_scalarmult(secretKey, publicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_scalarmult$(_context36) {\n            while (1) {\n              switch (_context36.prev = _context36.next) {\n                case 0:\n                  _context36.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (secretKey instanceof X25519SecretKey) {\n                    _context36.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n\n                case 4:\n                  if (publicKey instanceof X25519PublicKey) {\n                    _context36.next = 6;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n\n                case 6:\n                  _context36.next = 8;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_scalarmult(secretKey, publicKey));\n\n                case 8:\n                  return _context36.abrupt(\"return\", _context36.sent);\n\n                case 9:\n                case \"end\":\n                  return _context36.stop();\n              }\n            }\n          }\n\n          return crypto_scalarmult$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_scalarmult;\n    }()\n    /**\n     * Generate an X25519PublicKey from an X25519SecretKey\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    ;\n\n    _proto.crypto_scalarmult_base = function () {\n      function crypto_scalarmult_base(secretKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_scalarmult_base$(_context37) {\n            while (1) {\n              switch (_context37.prev = _context37.next) {\n                case 0:\n                  _context37.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (secretKey instanceof X25519SecretKey) {\n                    _context37.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n\n                case 4:\n                  _context37.t0 = X25519PublicKey;\n                  _context37.next = 7;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_scalarmult_base(secretKey));\n\n                case 7:\n                  _context37.t1 = _context37.sent;\n                  return _context37.abrupt(\"return\", new _context37.t0(_context37.t1));\n\n                case 9:\n                case \"end\":\n                  return _context37.stop();\n              }\n            }\n          }\n\n          return crypto_scalarmult_base$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_scalarmult_base;\n    }()\n    /**\n     * Shared-key authenticated encryption\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretbox = function () {\n      function crypto_secretbox(plaintext, nonce, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretbox$(_context38) {\n            while (1) {\n              switch (_context38.prev = _context38.next) {\n                case 0:\n                  _context38.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (!(key.isEd25519Key() || key.isX25519Key())) {\n                    _context38.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must not be an asymmetric key');\n\n                case 4:\n                  _context38.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 6:\n                  nonce = _context38.sent;\n\n                  if (!(nonce.length !== 24)) {\n                    _context38.next = 9;\n                    break;\n                  }\n\n                  throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n\n                case 9:\n                  _context38.next = 11;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_secretbox(plaintext, nonce, key));\n\n                case 11:\n                  return _context38.abrupt(\"return\", _context38.sent);\n\n                case 12:\n                case \"end\":\n                  return _context38.stop();\n              }\n            }\n          }\n\n          return crypto_secretbox$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretbox;\n    }()\n    /**\n     * Shared-key authenticated decryption\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretbox_open = function () {\n      function crypto_secretbox_open(ciphertext, nonce, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretbox_open$(_context39) {\n            while (1) {\n              switch (_context39.prev = _context39.next) {\n                case 0:\n                  _context39.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (!(key.isEd25519Key() || key.isX25519Key())) {\n                    _context39.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 3 must not be an asymmetric key');\n\n                case 4:\n                  _context39.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ciphertext));\n\n                case 6:\n                  ciphertext = _context39.sent;\n\n                  if (!(ciphertext.length < 16)) {\n                    _context39.next = 9;\n                    break;\n                  }\n\n                  throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n\n                case 9:\n                  _context39.next = 11;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 11:\n                  nonce = _context39.sent;\n\n                  if (!(nonce.length !== 24)) {\n                    _context39.next = 14;\n                    break;\n                  }\n\n                  throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n\n                case 14:\n                  _context39.next = 16;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_secretbox_open(ciphertext, nonce, key));\n\n                case 16:\n                  return _context39.abrupt(\"return\", _context39.sent);\n\n                case 17:\n                case \"end\":\n                  return _context39.stop();\n              }\n            }\n          }\n\n          return crypto_secretbox_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretbox_open;\n    }()\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_secretbox_keygen = function () {\n      function crypto_secretbox_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretbox_keygen$(_context40) {\n            while (1) {\n              switch (_context40.prev = _context40.next) {\n                case 0:\n                  _context40.t0 = CryptographyKey;\n                  _context40.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(this.CRYPTO_SECRETBOX_KEYBYTES));\n\n                case 3:\n                  _context40.t1 = _context40.sent;\n                  return _context40.abrupt(\"return\", new _context40.t0(_context40.t1));\n\n                case 5:\n                case \"end\":\n                  return _context40.stop();\n              }\n            }\n          }\n\n          return crypto_secretbox_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretbox_keygen;\n    }()\n    /**\n     * Internalize the internal state and a random header for stream encryption.\n     *\n     * @param {CryptographyKey} key\n     * @return {Promise<array>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_init_push = function () {\n      function crypto_secretstream_xchacha20poly1305_init_push(key) {\n        var _await$this$backend$c, _await$this$backend$c2, state, header;\n\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_init_push$(_context41) {\n            while (1) {\n              switch (_context41.prev = _context41.next) {\n                case 0:\n                  _context41.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (key instanceof CryptographyKey) {\n                    _context41.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Key must be an instance of CryptographyKey');\n\n                case 4:\n                  if (!(key.getLength() !== 32)) {\n                    _context41.next = 6;\n                    break;\n                  }\n\n                  throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n\n                case 6:\n                  _context41.next = 8;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_secretstream_xchacha20poly1305_init_push(key));\n\n                case 8:\n                  _await$this$backend$c = _context41.sent;\n                  _await$this$backend$c2 = _slicedToArray(_await$this$backend$c, 2);\n                  state = _await$this$backend$c2[0];\n                  header = _await$this$backend$c2[1];\n                  return _context41.abrupt(\"return\", Object.freeze({\n                    header: header,\n                    push: this.crypto_secretstream_xchacha20poly1305_push.bind(this, state),\n                    rekey: this.crypto_secretstream_xchacha20poly1305_rekey.bind(this, state)\n                  }));\n\n                case 13:\n                case \"end\":\n                  return _context41.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_init_push$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_init_push;\n    }()\n    /**\n     * Initialize the internal state for stream decryption.\n     *\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_init_pull = function () {\n      function crypto_secretstream_xchacha20poly1305_init_pull(key, header) {\n        var state;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_init_pull$(_context42) {\n            while (1) {\n              switch (_context42.prev = _context42.next) {\n                case 0:\n                  _context42.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context42.next = 4;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(header));\n\n                case 4:\n                  header = _context42.sent;\n\n                  if (!(header.length !== 24)) {\n                    _context42.next = 7;\n                    break;\n                  }\n\n                  throw new SodiumError('crypto_secretstream headers must be 24 bytes long');\n\n                case 7:\n                  if (key instanceof CryptographyKey) {\n                    _context42.next = 9;\n                    break;\n                  }\n\n                  throw new TypeError('Key must be an instance of CryptographyKey');\n\n                case 9:\n                  if (!(key.getLength() !== 32)) {\n                    _context42.next = 11;\n                    break;\n                  }\n\n                  throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n\n                case 11:\n                  _context42.next = 13;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_secretstream_xchacha20poly1305_init_pull(header, key));\n\n                case 13:\n                  state = _context42.sent;\n                  return _context42.abrupt(\"return\", Object.freeze({\n                    pull: this.crypto_secretstream_xchacha20poly1305_pull.bind(this, state)\n                  }));\n\n                case 15:\n                case \"end\":\n                  return _context42.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_init_pull$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_init_pull;\n    }()\n    /**\n     * Stream encryption.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_push = function () {\n      function crypto_secretstream_xchacha20poly1305_push(state, message) {\n        var ad,\n            tag,\n            _args43 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_push$(_context43) {\n            while (1) {\n              switch (_context43.prev = _context43.next) {\n                case 0:\n                  ad = _args43.length > 2 && _args43[2] !== undefined ? _args43[2] : '';\n                  tag = _args43.length > 3 && _args43[3] !== undefined ? _args43[3] : 0;\n                  _context43.next = 4;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 4:\n                  return _context43.abrupt(\"return\", this.backend.crypto_secretstream_xchacha20poly1305_push(state, message, ad, tag));\n\n                case 5:\n                case \"end\":\n                  return _context43.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_push$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_push;\n    }()\n    /**\n     * Stream decryption.\n     *\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_pull = function () {\n      function crypto_secretstream_xchacha20poly1305_pull(state, ciphertext) {\n        var ad,\n            tag,\n            _args44 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_pull$(_context44) {\n            while (1) {\n              switch (_context44.prev = _context44.next) {\n                case 0:\n                  ad = _args44.length > 2 && _args44[2] !== undefined ? _args44[2] : '';\n                  tag = _args44.length > 3 && _args44[3] !== undefined ? _args44[3] : 0;\n                  _context44.next = 4;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 4:\n                  return _context44.abrupt(\"return\", this.backend.crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad, tag));\n\n                case 5:\n                case \"end\":\n                  return _context44.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_pull$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_pull;\n    }()\n    /**\n     * Deterministic rekeying.\n     *\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_rekey = function () {\n      function crypto_secretstream_xchacha20poly1305_rekey(state) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_rekey$(_context45) {\n            while (1) {\n              switch (_context45.prev = _context45.next) {\n                case 0:\n                  _context45.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context45.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_secretstream_xchacha20poly1305_rekey(state));\n\n                case 4:\n                case \"end\":\n                  return _context45.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_rekey$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_rekey;\n    }()\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_keygen = function () {\n      function crypto_secretstream_xchacha20poly1305_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_keygen$(_context46) {\n            while (1) {\n              switch (_context46.prev = _context46.next) {\n                case 0:\n                  _context46.t0 = CryptographyKey;\n                  _context46.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES));\n\n                case 3:\n                  _context46.t1 = _context46.sent;\n                  return _context46.abrupt(\"return\", new _context46.t0(_context46.t1));\n\n                case 5:\n                case \"end\":\n                  return _context46.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_keygen;\n    }()\n    /**\n     * Calculate a fast hash for short inputs.\n     *\n     * Algorithm: SipHash-2-4\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_shorthash = function () {\n      function crypto_shorthash(message, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_shorthash$(_context47) {\n            while (1) {\n              switch (_context47.prev = _context47.next) {\n                case 0:\n                  _context47.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context47.t0 = _regeneratorRuntime;\n                  _context47.t1 = this.backend;\n                  _context47.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 6:\n                  _context47.t2 = _context47.sent;\n                  _context47.t3 = key;\n                  _context47.t4 = _context47.t1.crypto_shorthash.call(_context47.t1, _context47.t2, _context47.t3);\n                  _context47.next = 11;\n                  return _context47.t0.awrap.call(_context47.t0, _context47.t4);\n\n                case 11:\n                  return _context47.abrupt(\"return\", _context47.sent);\n\n                case 12:\n                case \"end\":\n                  return _context47.stop();\n              }\n            }\n          }\n\n          return crypto_shorthash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_shorthash;\n    }()\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_shorthash_keygen = function () {\n      function crypto_shorthash_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_shorthash_keygen$(_context48) {\n            while (1) {\n              switch (_context48.prev = _context48.next) {\n                case 0:\n                  _context48.t0 = CryptographyKey;\n                  _context48.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(this.CRYPTO_SHORTHASH_KEYBYTES));\n\n                case 3:\n                  _context48.t1 = _context48.sent;\n                  return _context48.abrupt(\"return\", new _context48.t0(_context48.t1));\n\n                case 5:\n                case \"end\":\n                  return _context48.stop();\n              }\n            }\n          }\n\n          return crypto_shorthash_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_shorthash_keygen;\n    }()\n    /**\n     * Returns a signed message.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign = function () {\n      function crypto_sign(message, secretKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign$(_context49) {\n            while (1) {\n              switch (_context49.prev = _context49.next) {\n                case 0:\n                  _context49.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (secretKey instanceof Ed25519SecretKey) {\n                    _context49.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n\n                case 4:\n                  return _context49.abrupt(\"return\", this.backend.crypto_sign(message, secretKey));\n\n                case 5:\n                case \"end\":\n                  return _context49.stop();\n              }\n            }\n          }\n\n          return crypto_sign$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign;\n    }()\n    /**\n     * Given a signed message, verify the Ed25519 signature. If it matches, return the\n     * bare message (no signature).\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_open = function () {\n      function crypto_sign_open(message, publicKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_open$(_context50) {\n            while (1) {\n              switch (_context50.prev = _context50.next) {\n                case 0:\n                  _context50.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (publicKey instanceof Ed25519PublicKey) {\n                    _context50.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n\n                case 4:\n                  return _context50.abrupt(\"return\", this.backend.crypto_sign_open(message, publicKey));\n\n                case 5:\n                case \"end\":\n                  return _context50.stop();\n              }\n            }\n          }\n\n          return crypto_sign_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_open;\n    }()\n    /**\n     * Returns the Ed25519 signature of the message, for the given secret key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_detached = function () {\n      function crypto_sign_detached(message, secretKey) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_detached$(_context51) {\n            while (1) {\n              switch (_context51.prev = _context51.next) {\n                case 0:\n                  _context51.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (secretKey instanceof Ed25519SecretKey) {\n                    _context51.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n\n                case 4:\n                  return _context51.abrupt(\"return\", this.backend.crypto_sign_detached(message, secretKey));\n\n                case 5:\n                case \"end\":\n                  return _context51.stop();\n              }\n            }\n          }\n\n          return crypto_sign_detached$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_detached;\n    }()\n    /**\n     * Returns true if the Ed25519 signature is valid for a given message and public key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_sign_verify_detached = function () {\n      function crypto_sign_verify_detached(message, publicKey, signature) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_verify_detached$(_context52) {\n            while (1) {\n              switch (_context52.prev = _context52.next) {\n                case 0:\n                  _context52.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (publicKey instanceof Ed25519PublicKey) {\n                    _context52.next = 4;\n                    break;\n                  }\n\n                  throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n\n                case 4:\n                  return _context52.abrupt(\"return\", this.backend.crypto_sign_verify_detached(message, publicKey, signature));\n\n                case 5:\n                case \"end\":\n                  return _context52.stop();\n              }\n            }\n          }\n\n          return crypto_sign_verify_detached$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_verify_detached;\n    }()\n    /**\n     * Extract the secret key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519SecretKey>}\n     */\n    ;\n\n    _proto.crypto_sign_secretkey = function () {\n      function crypto_sign_secretkey(keypair) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_secretkey$(_context53) {\n            while (1) {\n              switch (_context53.prev = _context53.next) {\n                case 0:\n                  if (!(keypair.getLength() !== 96)) {\n                    _context53.next = 2;\n                    break;\n                  }\n\n                  throw new SodiumError('Keypair must be 96 bytes');\n\n                case 2:\n                  _context53.t0 = Ed25519SecretKey;\n                  _context53.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(keypair.getBuffer().slice(0, 64)));\n\n                case 5:\n                  _context53.t1 = _context53.sent;\n                  return _context53.abrupt(\"return\", new _context53.t0(_context53.t1));\n\n                case 7:\n                case \"end\":\n                  return _context53.stop();\n              }\n            }\n          }\n\n          return crypto_sign_secretkey$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_sign_secretkey;\n    }()\n    /**\n     * Extract the public key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519PublicKey>}\n     */\n    ;\n\n    _proto.crypto_sign_publickey = function () {\n      function crypto_sign_publickey(keypair) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_publickey$(_context54) {\n            while (1) {\n              switch (_context54.prev = _context54.next) {\n                case 0:\n                  if (!(keypair.getLength() !== 96)) {\n                    _context54.next = 2;\n                    break;\n                  }\n\n                  throw new SodiumError('Keypair must be 96 bytes');\n\n                case 2:\n                  return _context54.abrupt(\"return\", new Ed25519PublicKey(keypair.getBuffer().slice(64, 96)));\n\n                case 3:\n                case \"end\":\n                  return _context54.stop();\n              }\n            }\n          }\n\n          return crypto_sign_publickey$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_sign_publickey;\n    }()\n    /**\n     * Generate an Ed25519 keypair object.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_sign_keypair = function () {\n      function crypto_sign_keypair() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_keypair$(_context55) {\n            while (1) {\n              switch (_context55.prev = _context55.next) {\n                case 0:\n                  _context55.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context55.abrupt(\"return\", this.backend.crypto_sign_keypair());\n\n                case 3:\n                case \"end\":\n                  return _context55.stop();\n              }\n            }\n          }\n\n          return crypto_sign_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_keypair;\n    }()\n    /**\n     * Generate an Ed25519 keypair object from a seed.\n     *\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_sign_seed_keypair = function () {\n      function crypto_sign_seed_keypair(seed) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_seed_keypair$(_context56) {\n            while (1) {\n              switch (_context56.prev = _context56.next) {\n                case 0:\n                  _context56.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  if (seed instanceof CryptographyKey) {\n                    seed = seed.getBuffer();\n                  }\n\n                  _context56.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(seed));\n\n                case 5:\n                  seed = _context56.sent;\n\n                  if (!(seed.length !== 32)) {\n                    _context56.next = 8;\n                    break;\n                  }\n\n                  throw new SodiumError(\"Seed must be 32 bytes long; got \" + seed.length);\n\n                case 8:\n                  return _context56.abrupt(\"return\", this.backend.crypto_sign_seed_keypair(seed));\n\n                case 9:\n                case \"end\":\n                  return _context56.stop();\n              }\n            }\n          }\n\n          return crypto_sign_seed_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_seed_keypair;\n    }()\n    /**\n     * Obtain a birationally equivalent X25519 secret key,\n     * given an Ed25519 secret key.\n     *\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<X25519SecretKey>}\n     */\n    ;\n\n    _proto.crypto_sign_ed25519_sk_to_curve25519 = function () {\n      function crypto_sign_ed25519_sk_to_curve25519(sk) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_ed25519_sk_to_curve25519$(_context57) {\n            while (1) {\n              switch (_context57.prev = _context57.next) {\n                case 0:\n                  _context57.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context57.t0 = X25519SecretKey;\n                  _context57.next = 5;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_sign_ed25519_sk_to_curve25519(sk));\n\n                case 5:\n                  _context57.t1 = _context57.sent;\n                  return _context57.abrupt(\"return\", new _context57.t0(_context57.t1));\n\n                case 7:\n                case \"end\":\n                  return _context57.stop();\n              }\n            }\n          }\n\n          return crypto_sign_ed25519_sk_to_curve25519$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_ed25519_sk_to_curve25519;\n    }()\n    /**\n     * Obtain a birationally equivalent X25519 public key,\n     * given an Ed25519 public key.\n     *\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<X25519PublicKey>}\n     */\n    ;\n\n    _proto.crypto_sign_ed25519_pk_to_curve25519 = function () {\n      function crypto_sign_ed25519_pk_to_curve25519(pk) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_ed25519_pk_to_curve25519$(_context58) {\n            while (1) {\n              switch (_context58.prev = _context58.next) {\n                case 0:\n                  _context58.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context58.t0 = X25519PublicKey;\n                  _context58.next = 5;\n                  return _regeneratorRuntime.awrap(this.backend.crypto_sign_ed25519_pk_to_curve25519(pk));\n\n                case 5:\n                  _context58.t1 = _context58.sent;\n                  return _context58.abrupt(\"return\", new _context58.t0(_context58.t1));\n\n                case 7:\n                case \"end\":\n                  return _context58.stop();\n              }\n            }\n          }\n\n          return crypto_sign_ed25519_pk_to_curve25519$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_ed25519_pk_to_curve25519;\n    }()\n    /**\n     * Generate an arbitrary number of pseudorandom bytes from a given\n     * nonce and key.\n     *\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_stream = function () {\n      function crypto_stream(length, nonce, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_stream$(_context59) {\n            while (1) {\n              switch (_context59.prev = _context59.next) {\n                case 0:\n                  _context59.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context59.abrupt(\"return\", this.backend.crypto_stream(length, nonce, key));\n\n                case 3:\n                case \"end\":\n                  return _context59.stop();\n              }\n            }\n          }\n\n          return crypto_stream$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_stream;\n    }()\n    /**\n     * Encrypts a string (without authentication).\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_stream_xor = function () {\n      function crypto_stream_xor(plaintext, nonce, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_stream_xor$(_context60) {\n            while (1) {\n              switch (_context60.prev = _context60.next) {\n                case 0:\n                  _context60.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context60.abrupt(\"return\", this.backend.crypto_stream_xor(plaintext, nonce, key));\n\n                case 3:\n                case \"end\":\n                  return _context60.stop();\n              }\n            }\n          }\n\n          return crypto_stream_xor$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_stream_xor;\n    }()\n    /**\n     * Generate a key for stream ciphers.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_stream_keygen = function () {\n      function crypto_stream_keygen() {\n        return _regeneratorRuntime.async(function () {\n          function crypto_stream_keygen$(_context61) {\n            while (1) {\n              switch (_context61.prev = _context61.next) {\n                case 0:\n                  _context61.t0 = CryptographyKey;\n                  _context61.next = 3;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(this.CRYPTO_STREAM_KEYBYTES));\n\n                case 3:\n                  _context61.t1 = _context61.sent;\n                  return _context61.abrupt(\"return\", new _context61.t0(_context61.t1));\n\n                case 5:\n                case \"end\":\n                  return _context61.stop();\n              }\n            }\n          }\n\n          return crypto_stream_keygen$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_stream_keygen;\n    }()\n    /**\n     * Returns a buffer filled with random bytes.\n     *\n     * @param {number} num\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.randombytes_buf = function () {\n      function randombytes_buf(num) {\n        return _regeneratorRuntime.async(function () {\n          function randombytes_buf$(_context62) {\n            while (1) {\n              switch (_context62.prev = _context62.next) {\n                case 0:\n                  _context62.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context62.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.randombytes_buf(num));\n\n                case 4:\n                  return _context62.abrupt(\"return\", _context62.sent);\n\n                case 5:\n                case \"end\":\n                  return _context62.stop();\n              }\n            }\n          }\n\n          return randombytes_buf$;\n        }(), null, this, null, Promise);\n      }\n\n      return randombytes_buf;\n    }()\n    /**\n     * Generate an integer between 0 and upperBound (non-inclusive).\n     *\n     * For example, randombytes_uniform(10) returns an integer between 0 and 9.\n     *\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    ;\n\n    _proto.randombytes_uniform = function () {\n      function randombytes_uniform(upperBound) {\n        return _regeneratorRuntime.async(function () {\n          function randombytes_uniform$(_context63) {\n            while (1) {\n              switch (_context63.prev = _context63.next) {\n                case 0:\n                  _context63.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context63.abrupt(\"return\", this.backend.randombytes_uniform(upperBound));\n\n                case 3:\n                case \"end\":\n                  return _context63.stop();\n              }\n            }\n          }\n\n          return randombytes_uniform$;\n        }(), null, this, null, Promise);\n      }\n\n      return randombytes_uniform;\n    }()\n    /**\n     * Add two buffers (little-endian). Returns the value.\n     *\n     * @param {Buffer} val\n     * @param {Buffer} addv\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_add = function () {\n      function sodium_add(val, addv) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_add$(_context64) {\n            while (1) {\n              switch (_context64.prev = _context64.next) {\n                case 0:\n                  _context64.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context64.t0 = _regeneratorRuntime;\n                  _context64.t1 = this.backend;\n                  _context64.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(val));\n\n                case 6:\n                  _context64.t2 = _context64.sent;\n                  _context64.next = 9;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(addv));\n\n                case 9:\n                  _context64.t3 = _context64.sent;\n                  _context64.t4 = _context64.t1.sodium_add.call(_context64.t1, _context64.t2, _context64.t3);\n                  _context64.next = 13;\n                  return _context64.t0.awrap.call(_context64.t0, _context64.t4);\n\n                case 13:\n                  return _context64.abrupt(\"return\", _context64.sent);\n\n                case 14:\n                case \"end\":\n                  return _context64.stop();\n              }\n            }\n          }\n\n          return sodium_add$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_add;\n    }()\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer} decoded\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_bin2hex = function () {\n      function sodium_bin2hex(decoded) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_bin2hex$(_context65) {\n            while (1) {\n              switch (_context65.prev = _context65.next) {\n                case 0:\n                  _context65.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context65.abrupt(\"return\", this.backend.sodium_bin2hex(decoded));\n\n                case 3:\n                case \"end\":\n                  return _context65.stop();\n              }\n            }\n          }\n\n          return sodium_bin2hex$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_bin2hex;\n    }()\n    /**\n     * Compare two buffers in constant time.\n     *\n     * Returns -1 if b1 is less than b2.\n     * Returns  1 if b1 is greater than b2.\n     * Returns  0 if b1 is equal to b2.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    ;\n\n    _proto.sodium_compare = function () {\n      function sodium_compare(b1, b2) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_compare$(_context66) {\n            while (1) {\n              switch (_context66.prev = _context66.next) {\n                case 0:\n                  _context66.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context66.abrupt(\"return\", this.backend.sodium_compare(b1, b2));\n\n                case 3:\n                case \"end\":\n                  return _context66.stop();\n              }\n            }\n          }\n\n          return sodium_compare$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_compare;\n    }()\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer|string} encoded\n     * @return {Promise<string>}\n     */\n    ;\n\n    _proto.sodium_hex2bin = function () {\n      function sodium_hex2bin(encoded) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_hex2bin$(_context67) {\n            while (1) {\n              switch (_context67.prev = _context67.next) {\n                case 0:\n                  _context67.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context67.abrupt(\"return\", this.backend.sodium_hex2bin(encoded));\n\n                case 3:\n                case \"end\":\n                  return _context67.stop();\n              }\n            }\n          }\n\n          return sodium_hex2bin$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_hex2bin;\n    }()\n    /**\n     * Increment a buffer (little endian). Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_increment = function () {\n      function sodium_increment(buf) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_increment$(_context68) {\n            while (1) {\n              switch (_context68.prev = _context68.next) {\n                case 0:\n                  _context68.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context68.abrupt(\"return\", this.backend.sodium_increment(buf));\n\n                case 3:\n                case \"end\":\n                  return _context68.stop();\n              }\n            }\n          }\n\n          return sodium_increment$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_increment;\n    }()\n    /**\n     * Returns true if the buffer is zero.\n     *\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_is_zero = function () {\n      function sodium_is_zero(buf, len) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_is_zero$(_context69) {\n            while (1) {\n              switch (_context69.prev = _context69.next) {\n                case 0:\n                  _context69.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context69.abrupt(\"return\", this.backend.sodium_is_zero(buf, len));\n\n                case 3:\n                case \"end\":\n                  return _context69.stop();\n              }\n            }\n          }\n\n          return sodium_is_zero$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_is_zero;\n    }()\n    /**\n     * Timing-safe buffer comparison.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.sodium_memcmp = function () {\n      function sodium_memcmp(b1, b2) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_memcmp$(_context70) {\n            while (1) {\n              switch (_context70.prev = _context70.next) {\n                case 0:\n                  _context70.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context70.abrupt(\"return\", this.backend.sodium_memcmp(b1, b2));\n\n                case 3:\n                case \"end\":\n                  return _context70.stop();\n              }\n            }\n          }\n\n          return sodium_memcmp$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_memcmp;\n    }()\n    /**\n     * Zero out a buffer. Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    ;\n\n    _proto.sodium_memzero = function () {\n      function sodium_memzero(buf) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_memzero$(_context71) {\n            while (1) {\n              switch (_context71.prev = _context71.next) {\n                case 0:\n                  _context71.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  _context71.next = 4;\n                  return _regeneratorRuntime.awrap(this.backend.sodium_memzero(buf));\n\n                case 4:\n                case \"end\":\n                  return _context71.stop();\n              }\n            }\n          }\n\n          return sodium_memzero$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_memzero;\n    }()\n    /**\n     * Pad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_pad = function () {\n      function sodium_pad(buf, blockSize) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_pad$(_context72) {\n            while (1) {\n              switch (_context72.prev = _context72.next) {\n                case 0:\n                  _context72.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context72.abrupt(\"return\", this.backend.sodium_pad(buf, blockSize));\n\n                case 3:\n                case \"end\":\n                  return _context72.stop();\n              }\n            }\n          }\n\n          return sodium_pad$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_pad;\n    }()\n    /**\n     * Unpad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_unpad = function () {\n      function sodium_unpad(buf, blockSize) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_unpad$(_context73) {\n            while (1) {\n              switch (_context73.prev = _context73.next) {\n                case 0:\n                  _context73.next = 2;\n                  return _regeneratorRuntime.awrap(this.ensureLoaded());\n\n                case 2:\n                  return _context73.abrupt(\"return\", this.backend.sodium_unpad(buf, blockSize));\n\n                case 3:\n                case \"end\":\n                  return _context73.stop();\n              }\n            }\n          }\n\n          return sodium_unpad$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_unpad;\n    }();\n\n    return SodiumPlus;\n  }();\n\n  module.exports = SodiumPlus;\n}.call(this, module);","map":{"version":3,"sources":["imports/client/sodium-plus/lib/sodiumplus.js"],"names":["_slicedToArray","module1","link","default","v","_regeneratorRuntime","Backend","require","CryptographyKey","Ed25519SecretKey","Ed25519PublicKey","LibsodiumWrappersBackend","SodiumError","SodiumNativeBackend","X25519PublicKey","X25519SecretKey","Util","Buffer","SodiumPlus","backend","TypeError","populateConstants","getBackendName","backendName","isSodiumNative","isLibsodiumWrappers","auto","init","ensureLoaded","crypto_aead_xchacha20poly1305_ietf_decrypt","ciphertext","nonce","key","assocData","length","toBuffer","crypto_aead_xchacha20poly1305_ietf_encrypt","plaintext","crypto_aead_xchacha20poly1305_ietf_keygen","randombytes_buf","crypto_auth","message","crypto_auth_keygen","crypto_auth_verify","mac","crypto_box","myPrivateKey","theirPublicKey","crypto_box_open","crypto_box_keypair","crypto_box_keypair_from_secretkey_and_publickey","sKey","pKey","crypto_box_secretkey","keypair","getLength","from","getBuffer","slice","crypto_box_publickey","crypto_box_publickey_from_secretkey","secretKey","crypto_scalarmult_base","crypto_box_seal","publicKey","crypto_box_seal_open","crypto_generichash","outputLength","crypto_generichash_init","crypto_generichash_update","state","crypto_generichash_final","crypto_generichash_keygen","CRYPTO_GENERICHASH_KEYBYTES","crypto_kdf_derive_from_key","subKeyId","context","crypto_kdf_keygen","CRYPTO_KDF_KEYBYTES","crypto_kx_keypair","crypto_kx_seed_keypair","seed","CRYPTO_KX_SECRETKEYBYTES","sk","pk","concat","crypto_kx_client_session_keys","clientPublicKey","clientSecretKey","serverPublicKey","crypto_kx_server_session_keys","serverSecretKey","crypto_onetimeauth","crypto_onetimeauth_verify","tag","crypto_onetimeauth_keygen","crypto_pwhash","password","salt","opslimit","memlimit","algorithm","CRYPTO_PWHASH_ALG_DEFAULT","crypto_pwhash_str","crypto_pwhash_str_verify","hash","crypto_pwhash_str_needs_rehash","crypto_scalarmult","crypto_secretbox","isEd25519Key","isX25519Key","crypto_secretbox_open","crypto_secretbox_keygen","CRYPTO_SECRETBOX_KEYBYTES","crypto_secretstream_xchacha20poly1305_init_push","header","Object","freeze","push","crypto_secretstream_xchacha20poly1305_push","bind","rekey","crypto_secretstream_xchacha20poly1305_rekey","crypto_secretstream_xchacha20poly1305_init_pull","pull","crypto_secretstream_xchacha20poly1305_pull","ad","crypto_secretstream_xchacha20poly1305_keygen","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES","crypto_shorthash","crypto_shorthash_keygen","CRYPTO_SHORTHASH_KEYBYTES","crypto_sign","crypto_sign_open","crypto_sign_detached","crypto_sign_verify_detached","signature","crypto_sign_secretkey","crypto_sign_publickey","crypto_sign_keypair","crypto_sign_seed_keypair","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_pk_to_curve25519","crypto_stream","crypto_stream_xor","crypto_stream_keygen","CRYPTO_STREAM_KEYBYTES","num","randombytes_uniform","upperBound","sodium_add","val","addv","sodium_bin2hex","decoded","sodium_compare","b1","b2","sodium_hex2bin","encoded","sodium_increment","buf","sodium_is_zero","len","sodium_memcmp","sodium_memzero","sodium_pad","blockSize","sodium_unpad","module","exports"],"mappings":"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","sourcesContent":["const Backend = require('./backend');\nconst CryptographyKey = require('./cryptography-key');\nconst Ed25519SecretKey = require('./keytypes/ed25519sk');\nconst Ed25519PublicKey = require('./keytypes/ed25519pk');\nconst LibsodiumWrappersBackend = require('./backend/libsodium-wrappers');\nconst SodiumError = require('./sodium-error');\nconst SodiumNativeBackend = require('./backend/sodiumnative');\nconst X25519PublicKey = require('./keytypes/x25519pk');\nconst X25519SecretKey = require('./keytypes/x25519sk');\nconst Util = require('./util');\n\n/* istanbul ignore if */\nif (typeof (Buffer) === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n}\n\nclass SodiumPlus {\n    constructor(backend) {\n        /* istanbul ignore if */\n        if (!(backend instanceof Backend)) {\n            throw new TypeError('Backend object must implement the backend function');\n        }\n        this.backend = backend;\n        Util.populateConstants(this);\n    }\n\n    /**\n     * Returns the name of the current active backend.\n     * This method is NOT async.\n     *\n     * @return {string}\n     */\n    getBackendName() {\n        return this.backend.backendName;\n    }\n\n    /**\n     * Is this powered by sodium-native?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isSodiumNative() {\n        return (this.backend instanceof SodiumNativeBackend);\n    }\n\n    /**\n     * Is this powered by libsodium-wrappers?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isLibsodiumWrappers() {\n        return (this.backend instanceof LibsodiumWrappersBackend);\n    }\n\n    /**\n     * Automatically select a backend.\n     *\n     * @return {Promise<SodiumPlus>}\n     */\n    static async auto() {\n        let backend;\n        try {\n            backend = await SodiumNativeBackend.init();\n        } catch (e) {\n            backend = await LibsodiumWrappersBackend.init();\n        }\n        /* istanbul ignore if */\n        if (!backend) {\n            backend = await LibsodiumWrappersBackend.init();\n        }\n        Util.populateConstants(backend);\n        return new SodiumPlus(backend);\n    }\n\n    /**\n     * If our backend isn't defined, it will trigger an autoload.\n     *\n     * Mostly used internally. `await SodiumPlus.auto()` provides the same\n     * exact guarantee as this method.\n     *\n     * @return {Promise<void>}\n     */\n    async ensureLoaded() {\n        /* istanbul ignore if */\n        if (typeof (this.backend) === 'undefined') {\n            try {\n                await SodiumPlus.auto();\n            } catch (e) {\n                this.backend = await LibsodiumWrappersBackend.init();\n            }\n        }\n    }\n\n    /**\n     * Decrypt a message (and optional associated data) with XChaCha20-Poly1305\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, nonce, key, assocData = '') {\n        await this.ensureLoaded();\n        if (nonce.length !== 24) {\n            throw new SodiumError('Argument 2 must be 24 bytes');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            await Util.toBuffer(ciphertext),\n            assocData.length > 0 ? await Util.toBuffer(assocData) : null,\n            await Util.toBuffer(nonce),\n            key\n        );\n    }\n\n    /**\n     * Encrypt a message (and optional associated data) with XChaCha20-Poly1305.\n     *\n     * Throws a SodiumError if an invalid ciphertext/AAD is provided for this\n     * nonce and key.\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, nonce, key, assocData = '') {\n        await this.ensureLoaded();\n        if (nonce.length !== 24) {\n            throw new SodiumError('Argument 2 must be 24 bytes');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n        }\n\n        return await this.backend.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            await Util.toBuffer(plaintext),\n            assocData.length > 0 ? await Util.toBuffer(assocData) : null,\n            await Util.toBuffer(nonce),\n            key\n        );\n    }\n\n    /**\n     * Generate an XChaCha20-Poly1305 key.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_keygen() {\n        return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Get an authenticator for a message for a given key.\n     *\n     * Algorithm: HMAC-SHA512 truncated to 32 bytes.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_auth(message, key) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        await this.ensureLoaded();\n        return await this.backend.crypto_auth(\n            await Util.toBuffer(message),\n            key\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_auth_keygen() {\n        return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Verify an authenticator for a message for a given key.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} mac\n     * @return {Promise<boolean>}\n     */\n    async crypto_auth_verify(message, key, mac) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        await this.ensureLoaded();\n        return await this.backend.crypto_auth_verify(\n            await Util.toBuffer(mac),\n            await Util.toBuffer(message),\n            key\n        );\n    }\n\n    /**\n     * Public-key authenticated encryption.\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box(plaintext, nonce, myPrivateKey, theirPublicKey) {\n        await this.ensureLoaded();\n        if (!(myPrivateKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        if (!(theirPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return this.backend.crypto_box(\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(nonce),\n            myPrivateKey,\n            theirPublicKey\n        );\n    }\n\n    /**\n     * Public-key authenticated decryption.\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey) {\n        await this.ensureLoaded();\n        if (!(myPrivateKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        if (!(theirPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n        }\n        ciphertext = await Util.toBuffer(ciphertext);\n        if (ciphertext.length < 16) {\n            throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return this.backend.crypto_box_open(\n            ciphertext,\n            nonce,\n            myPrivateKey,\n            theirPublicKey\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair() {\n        await this.ensureLoaded();\n        return this.backend.crypto_box_keypair();\n    }\n\n    /**\n     * Combine two X25519 keys (secret, public) into a keypair object.\n     *\n     * @param {X25519SecretKey} sKey\n     * @param {X25519PublicKey} pKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey) {\n        await this.ensureLoaded();\n        if (!(sKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        if (!(pKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey);\n    }\n\n    /**\n     * Extract the secret key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_box_secretkey(keypair) {\n        if (keypair.getLength()!== 64) {\n            throw new SodiumError('Keypair must be 64 bytes');\n        }\n        return new X25519SecretKey(\n            Buffer.from(keypair.getBuffer().slice(0, 32))\n        );\n    }\n\n    /**\n     * Extract the public key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey(keypair) {\n        if (keypair.getLength() !== 64) {\n            throw new SodiumError('Keypair must be 64 bytes');\n        }\n        return new X25519PublicKey(\n            Buffer.from(keypair.getBuffer().slice(32, 64))\n        );\n    }\n\n    /**\n     * Derive the public key from a given X25519 secret key.\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey_from_secretkey(secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        return new X25519PublicKey(\n            await this.backend.crypto_scalarmult_base(secretKey)\n        );\n    }\n\n    /**\n     * Anonymous public-key encryption. (Message integrity is still assured.)\n     *\n     * @param {string|Buffer} plaintext\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal(plaintext, publicKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_box_seal(plaintext, publicKey);\n    }\n\n    /**\n     * Anonymous public-key decryption. (Message integrity is still assured.)\n     *\n     * @param {Buffer} ciphertext\n     * @param {X25519PublicKey} publicKey\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal_open(ciphertext, publicKey, secretKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        return await this.backend.crypto_box_seal_open(\n            await Util.toBuffer(ciphertext),\n            publicKey,\n            secretKey\n        );\n    }\n\n    /**\n     * Generic-purpose cryptographic hash.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash(message, key = null, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash(message, key, outputLength);\n    }\n\n    /**\n     * Initialize a BLAKE2 hash context for stream hashing.\n     *\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_init(key = null, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_init(key, outputLength);\n    }\n\n\n    /**\n     * Update the BLAKE2 hash state with a block of data.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    async crypto_generichash_update(state, message) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_update(state, message);\n    }\n\n    /**\n     * Obtain the final BLAKE2 hash output.\n     *\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_final(state, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_final(state, outputLength);\n    }\n\n    /**\n     * Generate a 256-bit random key for BLAKE2.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_generichash_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_GENERICHASH_KEYBYTES)\n        );\n    }\n\n    /**\n     * Derive a subkey from a master key.\n     *\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        await this.ensureLoaded();\n        if (length < 1) {\n            throw new SodiumError('Length must be a positive integer.');\n        }\n        if (subKeyId < 0) {\n            throw new SodiumError('Key ID must be an unsigned integer');\n        }\n        return await this.backend.crypto_kdf_derive_from_key(\n            length,\n            subKeyId,\n            context,\n            key\n        );\n    }\n\n    /**\n     * Generate a 256-bit random key for our KDF.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_KDF_KEYBYTES)\n        );\n    }\n\n    /**\n     * This is functionally identical to crypto_box_keypair().\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_keypair() {\n        return this.crypto_box_keypair();\n    }\n\n    /**\n     * Generate an X25519 keypair from a seed.\n     *\n     * @param {string|Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_seed_keypair(seed) {\n        await this.ensureLoaded();\n        const sk = await this.backend.crypto_generichash(seed, null, this.CRYPTO_KX_SECRETKEYBYTES);\n        const pk = await this.backend.crypto_scalarmult_base(new CryptographyKey(sk));\n        return new CryptographyKey(Buffer.concat([sk, pk]));\n    }\n\n    /**\n     * Perform a key exchange from the client's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the server to the client (incoming decryption).\n     * The second is meant for data sent from the client to the server (outgoing encryption).\n     *\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        await this.ensureLoaded();\n        if (!(clientPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n        }\n        if (!(clientSecretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n        }\n        if (!(serverPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n        }\n        return this.backend.crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey);\n    }\n\n    /**\n     * Perform a key exchange from the server's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the client to the server (incoming decryption).\n     * The second is meant for data sent from the server to the client (outgoing encryption).\n     *\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        await this.ensureLoaded();\n        if (!(serverPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n        }\n        if (!(serverSecretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n        }\n        if (!(clientPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n        }\n        return this.backend.crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_onetimeauth(message, key) {\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_onetimeauth(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    async crypto_onetimeauth_verify(message, key, tag) {\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_onetimeauth_verify(\n            await Util.toBuffer(message),\n            key,\n            await Util.toBuffer(tag)\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_onetimeauth_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(32)\n        );\n    }\n\n    /**\n     * Derive a cryptography key from a password and salt.\n     *\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number|null} algorithm\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm = null) {\n        await this.ensureLoaded();\n        /* istanbul ignore if */\n        if (!algorithm) {\n            algorithm = this.CRYPTO_PWHASH_ALG_DEFAULT;\n        }\n        return new CryptographyKey(\n            await this.backend.crypto_pwhash(\n                length,\n                await Util.toBuffer(password),\n                await Util.toBuffer(salt),\n                opslimit,\n                memlimit,\n                algorithm\n            )\n        );\n    }\n\n    /**\n     * Get a password hash (in a safe-for-storage format)\n     *\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str(password, opslimit, memlimit);\n    }\n\n    /**\n     * Verify a password against a known password hash\n     *\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_verify(password, hash) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str_verify(password, hash);\n    }\n\n    /**\n     * Does this password need to be rehashed?\n     *\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit);\n    }\n\n    /**\n     * Elliptic Curve Diffie-Hellman key exchange\n     *\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_scalarmult(secretKey, publicKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_scalarmult(secretKey, publicKey);\n    }\n\n    /**\n     * Generate an X25519PublicKey from an X25519SecretKey\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_scalarmult_base(secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        return new X25519PublicKey(\n            await this.backend.crypto_scalarmult_base(secretKey)\n        );\n    }\n\n    /**\n     * Shared-key authenticated encryption\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox(plaintext, nonce, key) {\n        await this.ensureLoaded();\n        if (key.isEd25519Key() || key.isX25519Key()) {\n            throw new TypeError('Argument 3 must not be an asymmetric key');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n\n        return await this.backend.crypto_secretbox(\n            plaintext,\n            nonce,\n            key\n        );\n    }\n\n    /**\n     * Shared-key authenticated decryption\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n        await this.ensureLoaded();\n        if (key.isEd25519Key() || key.isX25519Key()) {\n            throw new TypeError('Argument 3 must not be an asymmetric key');\n        }\n        ciphertext = await Util.toBuffer(ciphertext);\n        if (ciphertext.length < 16) {\n            throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return await this.backend.crypto_secretbox_open(\n            ciphertext,\n            nonce,\n            key\n        );\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretbox_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SECRETBOX_KEYBYTES)\n        );\n    }\n\n    /**\n     * Internalize the internal state and a random header for stream encryption.\n     *\n     * @param {CryptographyKey} key\n     * @return {Promise<array>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Key must be an instance of CryptographyKey');\n        }\n        if (key.getLength() !== 32) {\n            throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n        }\n        const [state, header] = await this.backend.crypto_secretstream_xchacha20poly1305_init_push(key);\n        return Object.freeze({\n            header: header,\n            push: this.crypto_secretstream_xchacha20poly1305_push.bind(this, state),\n            rekey: this.crypto_secretstream_xchacha20poly1305_rekey.bind(this, state)\n        });\n    }\n\n    /**\n     * Initialize the internal state for stream decryption.\n     *\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_pull(key, header) {\n        await this.ensureLoaded();\n        header = await Util.toBuffer(header);\n        if (header.length !== 24) {\n            throw new SodiumError('crypto_secretstream headers must be 24 bytes long');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Key must be an instance of CryptographyKey');\n        }\n        if (key.getLength() !== 32) {\n            throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n        }\n        const state = await this.backend.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n        return Object.freeze({\n            pull: this.crypto_secretstream_xchacha20poly1305_pull.bind(this, state)\n        });\n    }\n\n    /**\n     * Stream encryption.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_push(state, message, ad = '', tag = 0) {\n        await this.ensureLoaded();\n        return this.backend.crypto_secretstream_xchacha20poly1305_push(state, message, ad, tag);\n    }\n\n    /**\n     * Stream decryption.\n     *\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad = '', tag = 0) {\n        await this.ensureLoaded();\n        return this.backend.crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad, tag);\n    }\n\n    /**\n     * Deterministic rekeying.\n     *\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n        await this.ensureLoaded();\n        await this.backend.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretstream_xchacha20poly1305_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES)\n        );\n    }\n\n    /**\n     * Calculate a fast hash for short inputs.\n     *\n     * Algorithm: SipHash-2-4\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_shorthash(message, key) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_shorthash(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_shorthash_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SHORTHASH_KEYBYTES)\n        );\n    }\n\n    /**\n     * Returns a signed message.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign(message, secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof Ed25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n        }\n        return this.backend.crypto_sign(message, secretKey);\n    }\n\n    /**\n     * Given a signed message, verify the Ed25519 signature. If it matches, return the\n     * bare message (no signature).\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_open(message, publicKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof Ed25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n        }\n        return this.backend.crypto_sign_open(message, publicKey);\n    }\n\n    /**\n     * Returns the Ed25519 signature of the message, for the given secret key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_detached(message, secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof Ed25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n        }\n        return this.backend.crypto_sign_detached(message, secretKey);\n    }\n\n    /**\n     * Returns true if the Ed25519 signature is valid for a given message and public key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<boolean>}\n     */\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof Ed25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n        }\n        return this.backend.crypto_sign_verify_detached(message, publicKey, signature);\n    }\n\n    /**\n     * Extract the secret key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519SecretKey>}\n     */\n    async crypto_sign_secretkey(keypair) {\n        if (keypair.getLength() !== 96) {\n            throw new SodiumError('Keypair must be 96 bytes');\n        }\n        return new Ed25519SecretKey(\n            await Util.toBuffer(\n                keypair.getBuffer().slice(0, 64)\n            )\n        );\n    }\n\n    /**\n     * Extract the public key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519PublicKey>}\n     */\n    async crypto_sign_publickey(keypair) {\n        if (keypair.getLength() !== 96) {\n            throw new SodiumError('Keypair must be 96 bytes');\n        }\n        return new Ed25519PublicKey(\n            keypair.getBuffer().slice(64, 96)\n        );\n    }\n\n    /**\n     * Generate an Ed25519 keypair object.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_keypair() {\n        await this.ensureLoaded();\n        return this.backend.crypto_sign_keypair();\n    }\n\n    /**\n     * Generate an Ed25519 keypair object from a seed.\n     *\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_seed_keypair(seed) {\n        await this.ensureLoaded();\n        if (seed instanceof CryptographyKey) {\n            seed = seed.getBuffer();\n        }\n        seed = await Util.toBuffer(seed);\n        if (seed.length !== 32) {\n            throw new SodiumError(`Seed must be 32 bytes long; got ${seed.length}`);\n        }\n        return this.backend.crypto_sign_seed_keypair(seed);\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 secret key,\n     * given an Ed25519 secret key.\n     *\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n        await this.ensureLoaded();\n        return new X25519SecretKey(\n            await this.backend.crypto_sign_ed25519_sk_to_curve25519(sk)\n        );\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 public key,\n     * given an Ed25519 public key.\n     *\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n        await this.ensureLoaded();\n        return new X25519PublicKey(\n            await this.backend.crypto_sign_ed25519_pk_to_curve25519(pk)\n        );\n    }\n\n    /**\n     * Generate an arbitrary number of pseudorandom bytes from a given\n     * nonce and key.\n     *\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream(length, nonce, key) {\n        await this.ensureLoaded();\n        return this.backend.crypto_stream(length, nonce, key);\n    }\n\n    /**\n     * Encrypts a string (without authentication).\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream_xor(plaintext, nonce, key) {\n        await this.ensureLoaded();\n        return this.backend.crypto_stream_xor(plaintext, nonce, key);\n    }\n    /**\n     * Generate a key for stream ciphers.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_stream_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_STREAM_KEYBYTES)\n        );\n    }\n\n    /**\n     * Returns a buffer filled with random bytes.\n     *\n     * @param {number} num\n     * @return {Promise<Buffer>}\n     */\n    async randombytes_buf(num) {\n        await this.ensureLoaded();\n        return await this.backend.randombytes_buf(num);\n    }\n\n    /**\n     * Generate an integer between 0 and upperBound (non-inclusive).\n     *\n     * For example, randombytes_uniform(10) returns an integer between 0 and 9.\n     *\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    async randombytes_uniform(upperBound) {\n        await this.ensureLoaded();\n        return this.backend.randombytes_uniform(upperBound);\n    }\n\n    /**\n     * Add two buffers (little-endian). Returns the value.\n     *\n     * @param {Buffer} val\n     * @param {Buffer} addv\n     * @return {Promise<Buffer>}\n     */\n    async sodium_add(val, addv) {\n        await this.ensureLoaded();\n        return await this.backend.sodium_add(\n            await Util.toBuffer(val),\n            await Util.toBuffer(addv)\n        );\n    }\n\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer} decoded\n     * @return {Promise<Buffer>}\n     */\n    async sodium_bin2hex(decoded) {\n        await this.ensureLoaded();\n        return this.backend.sodium_bin2hex(decoded);\n    }\n\n    /**\n     * Compare two buffers in constant time.\n     *\n     * Returns -1 if b1 is less than b2.\n     * Returns  1 if b1 is greater than b2.\n     * Returns  0 if b1 is equal to b2.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    async sodium_compare(b1, b2) {\n        await this.ensureLoaded();\n        return this.backend.sodium_compare(b1, b2);\n    }\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer|string} encoded\n     * @return {Promise<string>}\n     */\n    async sodium_hex2bin(encoded) {\n        await this.ensureLoaded();\n        return this.backend.sodium_hex2bin(encoded);\n    }\n\n    /**\n     * Increment a buffer (little endian). Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    async sodium_increment(buf) {\n        await this.ensureLoaded();\n        return this.backend.sodium_increment(buf);\n    }\n\n    /**\n     * Returns true if the buffer is zero.\n     *\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    async sodium_is_zero(buf, len) {\n        await this.ensureLoaded();\n        return this.backend.sodium_is_zero(buf, len);\n    }\n\n    /**\n     * Timing-safe buffer comparison.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    async sodium_memcmp(b1, b2) {\n        await this.ensureLoaded();\n        return this.backend.sodium_memcmp(b1, b2);\n    }\n\n    /**\n     * Zero out a buffer. Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    async sodium_memzero(buf) {\n        await this.ensureLoaded();\n        await this.backend.sodium_memzero(buf);\n    }\n\n    /**\n     * Pad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_pad(buf, blockSize) {\n        await this.ensureLoaded();\n        return this.backend.sodium_pad(buf, blockSize);\n    }\n\n    /**\n     * Unpad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_unpad(buf, blockSize) {\n        await this.ensureLoaded();\n        return this.backend.sodium_unpad(buf, blockSize);\n    }\n}\n\nmodule.exports = SodiumPlus;\n"]},"sourceType":"module","hash":"a1e4fdb321d3e4f3d65f01a639a11be06754f026"}
