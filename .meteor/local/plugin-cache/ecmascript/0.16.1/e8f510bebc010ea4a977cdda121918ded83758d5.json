{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/jalik:ufs/ufs-uploader.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/jalik:ufs/ufs-uploader.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/jalik:ufs/ufs-uploader.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/jalik:ufs/ufs-uploader.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/jalik:ufs/ufs-uploader.js"}},"code":"module.export({\n  Uploader: () => Uploader\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\n\nlet _;\n\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n\n}, 1);\nlet Store;\nmodule.link(\"./ufs-store\", {\n  Store(v) {\n    Store = v;\n  }\n\n}, 2);\n\nclass Uploader {\n  constructor(options) {\n    const self = this; // Set default options\n\n    options = _.extend({\n      adaptive: true,\n      capacity: 0.9,\n      chunkSize: 16 * 1024,\n      data: null,\n      file: null,\n      maxChunkSize: 4 * 1024 * 1000,\n      maxTries: 5,\n      onAbort: this.onAbort,\n      onComplete: this.onComplete,\n      onCreate: this.onCreate,\n      onError: this.onError,\n      onProgress: this.onProgress,\n      onStart: this.onStart,\n      onStop: this.onStop,\n      retryDelay: 2000,\n      store: null,\n      transferDelay: 100\n    }, options); // Check options\n\n    if (typeof options.adaptive !== 'boolean') {\n      throw new TypeError('adaptive is not a number');\n    }\n\n    if (typeof options.capacity !== 'number') {\n      throw new TypeError('capacity is not a number');\n    }\n\n    if (options.capacity <= 0 || options.capacity > 1) {\n      throw new RangeError('capacity must be a float between 0.1 and 1.0');\n    }\n\n    if (typeof options.chunkSize !== 'number') {\n      throw new TypeError('chunkSize is not a number');\n    }\n\n    if (!(options.data instanceof Blob) && !(options.data instanceof File)) {\n      throw new TypeError('data is not an Blob or File');\n    }\n\n    if (options.file === null || typeof options.file !== 'object') {\n      throw new TypeError('file is not an object');\n    }\n\n    if (typeof options.maxChunkSize !== 'number') {\n      throw new TypeError('maxChunkSize is not a number');\n    }\n\n    if (typeof options.maxTries !== 'number') {\n      throw new TypeError('maxTries is not a number');\n    }\n\n    if (typeof options.retryDelay !== 'number') {\n      throw new TypeError('retryDelay is not a number');\n    }\n\n    if (typeof options.transferDelay !== 'number') {\n      throw new TypeError('transferDelay is not a number');\n    }\n\n    if (typeof options.onAbort !== 'function') {\n      throw new TypeError('onAbort is not a function');\n    }\n\n    if (typeof options.onComplete !== 'function') {\n      throw new TypeError('onComplete is not a function');\n    }\n\n    if (typeof options.onCreate !== 'function') {\n      throw new TypeError('onCreate is not a function');\n    }\n\n    if (typeof options.onError !== 'function') {\n      throw new TypeError('onError is not a function');\n    }\n\n    if (typeof options.onProgress !== 'function') {\n      throw new TypeError('onProgress is not a function');\n    }\n\n    if (typeof options.onStart !== 'function') {\n      throw new TypeError('onStart is not a function');\n    }\n\n    if (typeof options.onStop !== 'function') {\n      throw new TypeError('onStop is not a function');\n    }\n\n    if (typeof options.store !== 'string' && !(options.store instanceof Store)) {\n      throw new TypeError('store must be the name of the store or an instance of UploadFS.Store');\n    } // Public attributes\n\n\n    self.adaptive = options.adaptive;\n    self.capacity = parseFloat(options.capacity);\n    self.chunkSize = parseInt(options.chunkSize);\n    self.maxChunkSize = parseInt(options.maxChunkSize);\n    self.maxTries = parseInt(options.maxTries);\n    self.retryDelay = parseInt(options.retryDelay);\n    self.transferDelay = parseInt(options.transferDelay);\n    self.onAbort = options.onAbort;\n    self.onComplete = options.onComplete;\n    self.onCreate = options.onCreate;\n    self.onError = options.onError;\n    self.onProgress = options.onProgress;\n    self.onStart = options.onStart;\n    self.onStop = options.onStop; // Private attributes\n\n    let {\n      store\n    } = options;\n    const {\n      data\n    } = options;\n    const capacityMargin = 0.1;\n    let {\n      file\n    } = options;\n    let fileId = null;\n    let offset = 0;\n    let loaded = 0;\n    const total = data.size;\n    let tries = 0;\n    let postUrl = null;\n    let token = null;\n    let complete = false;\n    let uploading = false;\n    let timeA = null;\n    let timeB = null;\n    let elapsedTime = 0;\n    let startTime = 0; // Keep only the name of the store\n\n    if (store instanceof Store) {\n      store = store.getName();\n    } // Assign file to store\n\n\n    file.store = store;\n\n    function finish() {\n      // Finish the upload by telling the store the upload is complete\n      Meteor.call('ufsComplete', fileId, store, token, function (err, uploadedFile) {\n        if (err) {\n          self.onError(err, file);\n          self.abort();\n        } else if (uploadedFile) {\n          uploading = false;\n          complete = true;\n          file = uploadedFile;\n          self.onComplete(uploadedFile);\n        }\n      });\n    }\n    /**\n     * Aborts the current transfer\n     */\n\n\n    self.abort = function () {\n      // Remove the file from database\n      // eslint-disable-next-line no-unused-vars\n      Meteor.call('ufsDelete', fileId, store, token, function (err, result) {\n        if (err) {\n          self.onError(err, file);\n        }\n      }); // Reset uploader status\n\n      uploading = false;\n      fileId = null;\n      offset = 0;\n      tries = 0;\n      loaded = 0;\n      complete = false;\n      startTime = null;\n      self.onAbort(file);\n    };\n    /**\n     * Returns the average speed in bytes per second\n     * @returns {number}\n     */\n\n\n    self.getAverageSpeed = function () {\n      const seconds = self.getElapsedTime() / 1000;\n      return self.getLoaded() / seconds;\n    };\n    /**\n     * Returns the elapsed time in milliseconds\n     * @returns {number}\n     */\n\n\n    self.getElapsedTime = function () {\n      if (startTime && self.isUploading()) {\n        return elapsedTime + (Date.now() - startTime);\n      }\n\n      return elapsedTime;\n    };\n    /**\n     * Returns the file\n     * @return {object}\n     */\n\n\n    self.getFile = function () {\n      return file;\n    };\n    /**\n     * Returns the loaded bytes\n     * @return {number}\n     */\n\n\n    self.getLoaded = function () {\n      return loaded;\n    };\n    /**\n     * Returns current progress\n     * @return {number}\n     */\n\n\n    self.getProgress = function () {\n      return Math.min(loaded / total * 100 / 100, 1.0);\n    };\n    /**\n     * Returns the remaining time in milliseconds\n     * @returns {number}\n     */\n\n\n    self.getRemainingTime = function () {\n      const averageSpeed = self.getAverageSpeed();\n      const remainingBytes = total - self.getLoaded();\n      return averageSpeed && remainingBytes ? Math.max(remainingBytes / averageSpeed, 0) : 0;\n    };\n    /**\n     * Returns the upload speed in bytes per second\n     * @returns {number}\n     */\n\n\n    self.getSpeed = function () {\n      if (timeA && timeB && self.isUploading()) {\n        const seconds = (timeB - timeA) / 1000;\n        return self.chunkSize / seconds;\n      }\n\n      return 0;\n    };\n    /**\n     * Returns the total bytes\n     * @return {number}\n     */\n\n\n    self.getTotal = function () {\n      return total;\n    };\n    /**\n     * Checks if the transfer is complete\n     * @return {boolean}\n     */\n\n\n    self.isComplete = function () {\n      return complete;\n    };\n    /**\n     * Checks if the transfer is active\n     * @return {boolean}\n     */\n\n\n    self.isUploading = function () {\n      return uploading;\n    };\n    /**\n     * Reads a portion of file\n     * @param start\n     * @param length\n     * @param callback\n     * @returns {Blob}\n     */\n\n\n    self.readChunk = function (start, length, callback) {\n      if (typeof callback !== 'function') {\n        throw new Error('readChunk is missing callback');\n      }\n\n      try {\n        let end; // Calculate the chunk size\n\n        if (length && start + length > total) {\n          end = total;\n        } else {\n          end = start + length;\n        } // Get chunk\n\n\n        const chunk = data.slice(start, end); // Pass chunk to callback\n\n        callback.call(self, null, chunk);\n      } catch (err) {\n        console.error('read error', err); // Retry to read chunk\n\n        Meteor.setTimeout(function () {\n          if (tries < self.maxTries) {\n            tries += 1;\n            self.readChunk(start, length, callback);\n          }\n        }, self.retryDelay);\n      }\n    };\n    /**\n     * Sends a file chunk to the store\n     */\n\n\n    self.sendChunk = function () {\n      if (!complete && startTime !== null) {\n        if (offset < total) {\n          let {\n            chunkSize\n          } = self; // Use adaptive length\n\n          if (self.adaptive && timeA && timeB && timeB > timeA) {\n            const duration = (timeB - timeA) / 1000;\n            const max = self.capacity * (1 + capacityMargin);\n            const min = self.capacity * (1 - capacityMargin);\n\n            if (duration >= max) {\n              chunkSize = Math.abs(Math.round(chunkSize * (max - duration)));\n            } else if (duration < min) {\n              chunkSize = Math.round(chunkSize * (min / duration));\n            } // Limit to max chunk size\n\n\n            if (self.maxChunkSize > 0 && chunkSize > self.maxChunkSize) {\n              chunkSize = self.maxChunkSize;\n            }\n          } // Reduce chunk size to fit total\n\n\n          if (offset + chunkSize > total) {\n            chunkSize = total - offset;\n          } // Prepare the chunk\n\n\n          self.readChunk(offset, chunkSize, function (err, chunk) {\n            if (err) {\n              self.onError(err, file);\n              return;\n            }\n\n            const xhr = new XMLHttpRequest();\n\n            xhr.onreadystatechange = function () {\n              if (xhr.readyState === 4) {\n                if ([200, 201, 202, 204].includes(xhr.status)) {\n                  timeB = Date.now();\n                  offset += chunkSize;\n                  loaded += chunkSize; // Send next chunk\n\n                  self.onProgress(file, self.getProgress()); // Finish upload\n\n                  if (loaded >= total) {\n                    elapsedTime = Date.now() - startTime;\n                    finish();\n                  } else {\n                    Meteor.setTimeout(self.sendChunk, self.transferDelay);\n                  }\n                } else if (![402, 403, 404, 500].includes(xhr.status)) {\n                  // Retry until max tries is reach\n                  // But don't retry if these errors occur\n                  if (tries <= self.maxTries) {\n                    tries += 1; // Wait before retrying\n\n                    Meteor.setTimeout(self.sendChunk, self.retryDelay);\n                  } else {\n                    self.abort();\n                  }\n                } else {\n                  self.abort();\n                }\n              }\n            }; // Calculate upload progress\n\n\n            const progress = (offset + chunkSize) / total; // let formData = new FormData();\n            // formData.append('progress', progress);\n            // formData.append('chunk', chunk);\n\n            const url = \"\".concat(postUrl, \"&progress=\").concat(progress);\n            timeA = Date.now();\n            timeB = null;\n            uploading = true; // Send chunk to the store\n\n            xhr.open('POST', url, true);\n            xhr.send(chunk);\n          });\n        }\n      }\n    };\n    /**\n     * Starts or resumes the transfer\n     */\n\n\n    self.start = function () {\n      if (!fileId) {\n        // Create the file document and get the token\n        // that allows the user to send chunks to the store.\n        Meteor.call('ufsCreate', _.extend({}, file), function (err, result) {\n          if (err) {\n            self.onError(err, file);\n          } else if (result) {\n            token = result.token;\n            postUrl = result.url;\n            fileId = result.fileId;\n            file._id = result.fileId;\n            self.onCreate(file);\n            tries = 0;\n            startTime = Date.now();\n            self.onStart(file);\n            self.sendChunk();\n          }\n        });\n      } else if (!uploading && !complete) {\n        // Resume uploading\n        tries = 0;\n        startTime = Date.now();\n        self.onStart(file);\n        self.sendChunk();\n      }\n    };\n    /**\n     * Stops the transfer\n     */\n\n\n    self.stop = function () {\n      if (uploading) {\n        // Update elapsed time\n        elapsedTime = Date.now() - startTime;\n        startTime = null;\n        uploading = false;\n        self.onStop(file); // eslint-disable-next-line no-unused-vars\n\n        Meteor.call('ufsStop', fileId, store, token, function (err, result) {\n          if (err) {\n            self.onError(err, file);\n          }\n        });\n      }\n    };\n  }\n  /**\n   * Called when the file upload is aborted\n   * @param file\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onAbort(file) {}\n  /**\n   * Called when the file upload is complete\n   * @param file\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onComplete(file) {}\n  /**\n   * Called when the file is created in the collection\n   * @param file\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onCreate(file) {}\n  /**\n   * Called when an error occurs during file upload\n   * @param err\n   * @param file\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onError(err, file) {\n    console.error(\"ufs: \".concat(err.message));\n  }\n  /**\n   * Called when a file chunk has been sent\n   * @param file\n   * @param progress is a float from 0.0 to 1.0\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onProgress(file, progress) {}\n  /**\n   * Called when the file upload starts\n   * @param file\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onStart(file) {}\n  /**\n   * Called when the file upload stops\n   * @param file\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  onStop(file) {}\n\n}","map":{"version":3,"sources":["packages/jalik:ufs/ufs-uploader.js"],"names":["module","export","Uploader","Meteor","link","v","_","Store","constructor","options","self","extend","adaptive","capacity","chunkSize","data","file","maxChunkSize","maxTries","onAbort","onComplete","onCreate","onError","onProgress","onStart","onStop","retryDelay","store","transferDelay","TypeError","RangeError","Blob","File","parseFloat","parseInt","capacityMargin","fileId","offset","loaded","total","size","tries","postUrl","token","complete","uploading","timeA","timeB","elapsedTime","startTime","getName","finish","call","err","uploadedFile","abort","result","getAverageSpeed","seconds","getElapsedTime","getLoaded","isUploading","Date","now","getFile","getProgress","Math","min","getRemainingTime","averageSpeed","remainingBytes","max","getSpeed","getTotal","isComplete","readChunk","start","length","callback","Error","end","chunk","slice","console","error","setTimeout","sendChunk","duration","abs","round","xhr","XMLHttpRequest","onreadystatechange","readyState","includes","status","progress","url","open","send","_id","stop","message"],"mappings":"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","sourcesContent":["/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2017 Karl STEIN\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nimport { Meteor } from 'meteor/meteor';\nimport { _ } from 'meteor/underscore';\n\nimport { Store } from './ufs-store';\n\n/**\n * File uploader\n */\nexport class Uploader {\n\tconstructor(options) {\n\t\tconst self = this;\n\n\t\t// Set default options\n\t\toptions = _.extend(\n\t\t\t{\n\t\t\t\tadaptive: true,\n\t\t\t\tcapacity: 0.9,\n\t\t\t\tchunkSize: 16 * 1024,\n\t\t\t\tdata: null,\n\t\t\t\tfile: null,\n\t\t\t\tmaxChunkSize: 4 * 1024 * 1000,\n\t\t\t\tmaxTries: 5,\n\t\t\t\tonAbort: this.onAbort,\n\t\t\t\tonComplete: this.onComplete,\n\t\t\t\tonCreate: this.onCreate,\n\t\t\t\tonError: this.onError,\n\t\t\t\tonProgress: this.onProgress,\n\t\t\t\tonStart: this.onStart,\n\t\t\t\tonStop: this.onStop,\n\t\t\t\tretryDelay: 2000,\n\t\t\t\tstore: null,\n\t\t\t\ttransferDelay: 100,\n\t\t\t},\n\t\t\toptions,\n\t\t);\n\n\t\t// Check options\n\t\tif (typeof options.adaptive !== 'boolean') {\n\t\t\tthrow new TypeError('adaptive is not a number');\n\t\t}\n\t\tif (typeof options.capacity !== 'number') {\n\t\t\tthrow new TypeError('capacity is not a number');\n\t\t}\n\t\tif (options.capacity <= 0 || options.capacity > 1) {\n\t\t\tthrow new RangeError('capacity must be a float between 0.1 and 1.0');\n\t\t}\n\t\tif (typeof options.chunkSize !== 'number') {\n\t\t\tthrow new TypeError('chunkSize is not a number');\n\t\t}\n\t\tif (!(options.data instanceof Blob) && !(options.data instanceof File)) {\n\t\t\tthrow new TypeError('data is not an Blob or File');\n\t\t}\n\t\tif (options.file === null || typeof options.file !== 'object') {\n\t\t\tthrow new TypeError('file is not an object');\n\t\t}\n\t\tif (typeof options.maxChunkSize !== 'number') {\n\t\t\tthrow new TypeError('maxChunkSize is not a number');\n\t\t}\n\t\tif (typeof options.maxTries !== 'number') {\n\t\t\tthrow new TypeError('maxTries is not a number');\n\t\t}\n\t\tif (typeof options.retryDelay !== 'number') {\n\t\t\tthrow new TypeError('retryDelay is not a number');\n\t\t}\n\t\tif (typeof options.transferDelay !== 'number') {\n\t\t\tthrow new TypeError('transferDelay is not a number');\n\t\t}\n\t\tif (typeof options.onAbort !== 'function') {\n\t\t\tthrow new TypeError('onAbort is not a function');\n\t\t}\n\t\tif (typeof options.onComplete !== 'function') {\n\t\t\tthrow new TypeError('onComplete is not a function');\n\t\t}\n\t\tif (typeof options.onCreate !== 'function') {\n\t\t\tthrow new TypeError('onCreate is not a function');\n\t\t}\n\t\tif (typeof options.onError !== 'function') {\n\t\t\tthrow new TypeError('onError is not a function');\n\t\t}\n\t\tif (typeof options.onProgress !== 'function') {\n\t\t\tthrow new TypeError('onProgress is not a function');\n\t\t}\n\t\tif (typeof options.onStart !== 'function') {\n\t\t\tthrow new TypeError('onStart is not a function');\n\t\t}\n\t\tif (typeof options.onStop !== 'function') {\n\t\t\tthrow new TypeError('onStop is not a function');\n\t\t}\n\t\tif (typeof options.store !== 'string' && !(options.store instanceof Store)) {\n\t\t\tthrow new TypeError('store must be the name of the store or an instance of UploadFS.Store');\n\t\t}\n\n\t\t// Public attributes\n\t\tself.adaptive = options.adaptive;\n\t\tself.capacity = parseFloat(options.capacity);\n\t\tself.chunkSize = parseInt(options.chunkSize);\n\t\tself.maxChunkSize = parseInt(options.maxChunkSize);\n\t\tself.maxTries = parseInt(options.maxTries);\n\t\tself.retryDelay = parseInt(options.retryDelay);\n\t\tself.transferDelay = parseInt(options.transferDelay);\n\t\tself.onAbort = options.onAbort;\n\t\tself.onComplete = options.onComplete;\n\t\tself.onCreate = options.onCreate;\n\t\tself.onError = options.onError;\n\t\tself.onProgress = options.onProgress;\n\t\tself.onStart = options.onStart;\n\t\tself.onStop = options.onStop;\n\n\t\t// Private attributes\n\t\tlet { store } = options;\n\t\tconst { data } = options;\n\t\tconst capacityMargin = 0.1;\n\t\tlet { file } = options;\n\t\tlet fileId = null;\n\t\tlet offset = 0;\n\t\tlet loaded = 0;\n\t\tconst total = data.size;\n\t\tlet tries = 0;\n\t\tlet postUrl = null;\n\t\tlet token = null;\n\t\tlet complete = false;\n\t\tlet uploading = false;\n\n\t\tlet timeA = null;\n\t\tlet timeB = null;\n\n\t\tlet elapsedTime = 0;\n\t\tlet startTime = 0;\n\n\t\t// Keep only the name of the store\n\t\tif (store instanceof Store) {\n\t\t\tstore = store.getName();\n\t\t}\n\n\t\t// Assign file to store\n\t\tfile.store = store;\n\n\t\tfunction finish() {\n\t\t\t// Finish the upload by telling the store the upload is complete\n\t\t\tMeteor.call('ufsComplete', fileId, store, token, function (err, uploadedFile) {\n\t\t\t\tif (err) {\n\t\t\t\t\tself.onError(err, file);\n\t\t\t\t\tself.abort();\n\t\t\t\t} else if (uploadedFile) {\n\t\t\t\t\tuploading = false;\n\t\t\t\t\tcomplete = true;\n\t\t\t\t\tfile = uploadedFile;\n\t\t\t\t\tself.onComplete(uploadedFile);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Aborts the current transfer\n\t\t */\n\t\tself.abort = function () {\n\t\t\t// Remove the file from database\n\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\tMeteor.call('ufsDelete', fileId, store, token, function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\tself.onError(err, file);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Reset uploader status\n\t\t\tuploading = false;\n\t\t\tfileId = null;\n\t\t\toffset = 0;\n\t\t\ttries = 0;\n\t\t\tloaded = 0;\n\t\t\tcomplete = false;\n\t\t\tstartTime = null;\n\t\t\tself.onAbort(file);\n\t\t};\n\n\t\t/**\n\t\t * Returns the average speed in bytes per second\n\t\t * @returns {number}\n\t\t */\n\t\tself.getAverageSpeed = function () {\n\t\t\tconst seconds = self.getElapsedTime() / 1000;\n\t\t\treturn self.getLoaded() / seconds;\n\t\t};\n\n\t\t/**\n\t\t * Returns the elapsed time in milliseconds\n\t\t * @returns {number}\n\t\t */\n\t\tself.getElapsedTime = function () {\n\t\t\tif (startTime && self.isUploading()) {\n\t\t\t\treturn elapsedTime + (Date.now() - startTime);\n\t\t\t}\n\t\t\treturn elapsedTime;\n\t\t};\n\n\t\t/**\n\t\t * Returns the file\n\t\t * @return {object}\n\t\t */\n\t\tself.getFile = function () {\n\t\t\treturn file;\n\t\t};\n\n\t\t/**\n\t\t * Returns the loaded bytes\n\t\t * @return {number}\n\t\t */\n\t\tself.getLoaded = function () {\n\t\t\treturn loaded;\n\t\t};\n\n\t\t/**\n\t\t * Returns current progress\n\t\t * @return {number}\n\t\t */\n\t\tself.getProgress = function () {\n\t\t\treturn Math.min(((loaded / total) * 100) / 100, 1.0);\n\t\t};\n\n\t\t/**\n\t\t * Returns the remaining time in milliseconds\n\t\t * @returns {number}\n\t\t */\n\t\tself.getRemainingTime = function () {\n\t\t\tconst averageSpeed = self.getAverageSpeed();\n\t\t\tconst remainingBytes = total - self.getLoaded();\n\t\t\treturn averageSpeed && remainingBytes ? Math.max(remainingBytes / averageSpeed, 0) : 0;\n\t\t};\n\n\t\t/**\n\t\t * Returns the upload speed in bytes per second\n\t\t * @returns {number}\n\t\t */\n\t\tself.getSpeed = function () {\n\t\t\tif (timeA && timeB && self.isUploading()) {\n\t\t\t\tconst seconds = (timeB - timeA) / 1000;\n\t\t\t\treturn self.chunkSize / seconds;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t\t/**\n\t\t * Returns the total bytes\n\t\t * @return {number}\n\t\t */\n\t\tself.getTotal = function () {\n\t\t\treturn total;\n\t\t};\n\n\t\t/**\n\t\t * Checks if the transfer is complete\n\t\t * @return {boolean}\n\t\t */\n\t\tself.isComplete = function () {\n\t\t\treturn complete;\n\t\t};\n\n\t\t/**\n\t\t * Checks if the transfer is active\n\t\t * @return {boolean}\n\t\t */\n\t\tself.isUploading = function () {\n\t\t\treturn uploading;\n\t\t};\n\n\t\t/**\n\t\t * Reads a portion of file\n\t\t * @param start\n\t\t * @param length\n\t\t * @param callback\n\t\t * @returns {Blob}\n\t\t */\n\t\tself.readChunk = function (start, length, callback) {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('readChunk is missing callback');\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlet end;\n\n\t\t\t\t// Calculate the chunk size\n\t\t\t\tif (length && start + length > total) {\n\t\t\t\t\tend = total;\n\t\t\t\t} else {\n\t\t\t\t\tend = start + length;\n\t\t\t\t}\n\t\t\t\t// Get chunk\n\t\t\t\tconst chunk = data.slice(start, end);\n\t\t\t\t// Pass chunk to callback\n\t\t\t\tcallback.call(self, null, chunk);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error('read error', err);\n\t\t\t\t// Retry to read chunk\n\t\t\t\tMeteor.setTimeout(function () {\n\t\t\t\t\tif (tries < self.maxTries) {\n\t\t\t\t\t\ttries += 1;\n\t\t\t\t\t\tself.readChunk(start, length, callback);\n\t\t\t\t\t}\n\t\t\t\t}, self.retryDelay);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Sends a file chunk to the store\n\t\t */\n\t\tself.sendChunk = function () {\n\t\t\tif (!complete && startTime !== null) {\n\t\t\t\tif (offset < total) {\n\t\t\t\t\tlet { chunkSize } = self;\n\n\t\t\t\t\t// Use adaptive length\n\t\t\t\t\tif (self.adaptive && timeA && timeB && timeB > timeA) {\n\t\t\t\t\t\tconst duration = (timeB - timeA) / 1000;\n\t\t\t\t\t\tconst max = self.capacity * (1 + capacityMargin);\n\t\t\t\t\t\tconst min = self.capacity * (1 - capacityMargin);\n\n\t\t\t\t\t\tif (duration >= max) {\n\t\t\t\t\t\t\tchunkSize = Math.abs(Math.round(chunkSize * (max - duration)));\n\t\t\t\t\t\t} else if (duration < min) {\n\t\t\t\t\t\t\tchunkSize = Math.round(chunkSize * (min / duration));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Limit to max chunk size\n\t\t\t\t\t\tif (self.maxChunkSize > 0 && chunkSize > self.maxChunkSize) {\n\t\t\t\t\t\t\tchunkSize = self.maxChunkSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reduce chunk size to fit total\n\t\t\t\t\tif (offset + chunkSize > total) {\n\t\t\t\t\t\tchunkSize = total - offset;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prepare the chunk\n\t\t\t\t\tself.readChunk(offset, chunkSize, function (err, chunk) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tself.onError(err, file);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst xhr = new XMLHttpRequest();\n\t\t\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\t\t\t\tif ([200, 201, 202, 204].includes(xhr.status)) {\n\t\t\t\t\t\t\t\t\ttimeB = Date.now();\n\t\t\t\t\t\t\t\t\toffset += chunkSize;\n\t\t\t\t\t\t\t\t\tloaded += chunkSize;\n\n\t\t\t\t\t\t\t\t\t// Send next chunk\n\t\t\t\t\t\t\t\t\tself.onProgress(file, self.getProgress());\n\n\t\t\t\t\t\t\t\t\t// Finish upload\n\t\t\t\t\t\t\t\t\tif (loaded >= total) {\n\t\t\t\t\t\t\t\t\t\telapsedTime = Date.now() - startTime;\n\t\t\t\t\t\t\t\t\t\tfinish();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tMeteor.setTimeout(self.sendChunk, self.transferDelay);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (![402, 403, 404, 500].includes(xhr.status)) {\n\t\t\t\t\t\t\t\t\t// Retry until max tries is reach\n\t\t\t\t\t\t\t\t\t// But don't retry if these errors occur\n\t\t\t\t\t\t\t\t\tif (tries <= self.maxTries) {\n\t\t\t\t\t\t\t\t\t\ttries += 1;\n\t\t\t\t\t\t\t\t\t\t// Wait before retrying\n\t\t\t\t\t\t\t\t\t\tMeteor.setTimeout(self.sendChunk, self.retryDelay);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tself.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tself.abort();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Calculate upload progress\n\t\t\t\t\t\tconst progress = (offset + chunkSize) / total;\n\t\t\t\t\t\t// let formData = new FormData();\n\t\t\t\t\t\t// formData.append('progress', progress);\n\t\t\t\t\t\t// formData.append('chunk', chunk);\n\t\t\t\t\t\tconst url = `${postUrl}&progress=${progress}`;\n\n\t\t\t\t\t\ttimeA = Date.now();\n\t\t\t\t\t\ttimeB = null;\n\t\t\t\t\t\tuploading = true;\n\n\t\t\t\t\t\t// Send chunk to the store\n\t\t\t\t\t\txhr.open('POST', url, true);\n\t\t\t\t\t\txhr.send(chunk);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Starts or resumes the transfer\n\t\t */\n\t\tself.start = function () {\n\t\t\tif (!fileId) {\n\t\t\t\t// Create the file document and get the token\n\t\t\t\t// that allows the user to send chunks to the store.\n\t\t\t\tMeteor.call('ufsCreate', _.extend({}, file), function (err, result) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tself.onError(err, file);\n\t\t\t\t\t} else if (result) {\n\t\t\t\t\t\ttoken = result.token;\n\t\t\t\t\t\tpostUrl = result.url;\n\t\t\t\t\t\tfileId = result.fileId;\n\t\t\t\t\t\tfile._id = result.fileId;\n\t\t\t\t\t\tself.onCreate(file);\n\t\t\t\t\t\ttries = 0;\n\t\t\t\t\t\tstartTime = Date.now();\n\t\t\t\t\t\tself.onStart(file);\n\t\t\t\t\t\tself.sendChunk();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (!uploading && !complete) {\n\t\t\t\t// Resume uploading\n\t\t\t\ttries = 0;\n\t\t\t\tstartTime = Date.now();\n\t\t\t\tself.onStart(file);\n\t\t\t\tself.sendChunk();\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stops the transfer\n\t\t */\n\t\tself.stop = function () {\n\t\t\tif (uploading) {\n\t\t\t\t// Update elapsed time\n\t\t\t\telapsedTime = Date.now() - startTime;\n\t\t\t\tstartTime = null;\n\t\t\t\tuploading = false;\n\t\t\t\tself.onStop(file);\n\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\tMeteor.call('ufsStop', fileId, store, token, function (err, result) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tself.onError(err, file);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Called when the file upload is aborted\n\t * @param file\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonAbort(file) {}\n\n\t/**\n\t * Called when the file upload is complete\n\t * @param file\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonComplete(file) {}\n\n\t/**\n\t * Called when the file is created in the collection\n\t * @param file\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonCreate(file) {}\n\n\t/**\n\t * Called when an error occurs during file upload\n\t * @param err\n\t * @param file\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonError(err, file) {\n\t\tconsole.error(`ufs: ${err.message}`);\n\t}\n\n\t/**\n\t * Called when a file chunk has been sent\n\t * @param file\n\t * @param progress is a float from 0.0 to 1.0\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonProgress(file, progress) {}\n\n\t/**\n\t * Called when the file upload starts\n\t * @param file\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonStart(file) {}\n\n\t/**\n\t * Called when the file upload stops\n\t * @param file\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tonStop(file) {}\n}\n"]},"sourceType":"module","hash":"e8f510bebc010ea4a977cdda121918ded83758d5"}
