{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/rate-limit/rate-limit.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/rate-limit/rate-limit.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/rate-limit/rate-limit.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/packages/rate-limit/rate-limit.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/rate-limit/rate-limit.js"}},"code":"var _slicedToArray;\n\nmodule.link(\"@babel/runtime/helpers/slicedToArray\", {\n  default: function (v) {\n    _slicedToArray = v;\n  }\n}, 0);\nmodule.export({\n  RateLimiter: function () {\n    return RateLimiter;\n  }\n});\nvar Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar Random;\nmodule.link(\"meteor/random\", {\n  Random: function (v) {\n    Random = v;\n  }\n}, 1);\n// Default time interval (in milliseconds) to reset rate limit counters\nvar DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000; // Default number of events allowed per time interval\n\nvar DEFAULT_REQUESTS_PER_INTERVAL = 10;\nvar hasOwn = Object.prototype.hasOwnProperty; // A rule is defined by an options object that contains two fields,\n// `numRequestsAllowed` which is the number of events allowed per interval, and\n// an `intervalTime` which is the amount of time in milliseconds before the\n// rate limit restarts its internal counters, and by a matchers object. A\n// matchers object is a POJO that contains a set of keys with values that\n// define the entire set of inputs that match for each key. The values can\n// either be null (optional), a primitive or a function that returns a boolean\n// of whether the provided input's value matches for this key.\n//\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\n// which are records used to keep track of inputs that match the rule. If a\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a\n// rate limit is reached and future inputs that map to that counter will\n// result in errors being returned to the client.\n\nvar Rule = /*#__PURE__*/function () {\n  function Rule(options, matchers) {\n    this.id = Random.id();\n    this.options = options;\n    this._matchers = matchers;\n    this._lastResetTime = new Date().getTime(); // Dictionary of input keys to counters\n\n    this.counters = {};\n  } // Determine if this rule applies to the given input by comparing all\n  // rule.matchers. If the match fails, search short circuits instead of\n  // iterating through all matchers.\n\n\n  var _proto = Rule.prototype;\n\n  _proto.match = function () {\n    function match(input) {\n      return Object.entries(this._matchers).every(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            matcher = _ref2[1];\n\n        if (matcher !== null) {\n          if (!hasOwn.call(input, key)) {\n            return false;\n          } else if (typeof matcher === 'function') {\n            if (!matcher(input[key])) {\n              return false;\n            }\n          } else if (matcher !== input[key]) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n\n    return match;\n  }() // Generates unique key string for provided input by concatenating all the\n  // keys in the matcher with the corresponding values in the input.\n  // Only called if rule matches input.\n  ;\n\n  _proto._generateKeyString = function () {\n    function _generateKeyString(input) {\n      var _this = this;\n\n      return Object.entries(this._matchers).filter(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            key = _ref4[0];\n\n        return _this._matchers[key] !== null;\n      }).reduce(function (returnString, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            key = _ref6[0],\n            matcher = _ref6[1];\n\n        if (typeof matcher === 'function') {\n          if (matcher(input[key])) {\n            returnString += key + input[key];\n          }\n        } else {\n          returnString += key + input[key];\n        }\n\n        return returnString;\n      }, '');\n    }\n\n    return _generateKeyString;\n  }() // Applies the provided input and returns the key string, time since counters\n  // were last reset and time to next reset.\n  ;\n\n  _proto.apply = function () {\n    function apply(input) {\n      var key = this._generateKeyString(input);\n\n      var timeSinceLastReset = new Date().getTime() - this._lastResetTime;\n\n      var timeToNextReset = this.options.intervalTime - timeSinceLastReset;\n      return {\n        key: key,\n        timeSinceLastReset: timeSinceLastReset,\n        timeToNextReset: timeToNextReset\n      };\n    }\n\n    return apply;\n  }() // Reset counter dictionary for this specific rule. Called once the\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is\n  // set to be the current time in milliseconds.\n  ;\n\n  _proto.resetCounter = function () {\n    function resetCounter() {\n      // Delete the old counters dictionary to allow for garbage collection\n      this.counters = {};\n      this._lastResetTime = new Date().getTime();\n    }\n\n    return resetCounter;\n  }();\n\n  _proto._executeCallback = function () {\n    function _executeCallback(reply, ruleInput) {\n      try {\n        if (this.options.callback) {\n          this.options.callback(reply, ruleInput);\n        }\n      } catch (e) {\n        // Do not throw error here\n        console.error(e);\n      }\n    }\n\n    return _executeCallback;\n  }();\n\n  return Rule;\n}();\n\nvar RateLimiter = /*#__PURE__*/function () {\n  // Initialize rules to be an empty dictionary.\n  function RateLimiter() {\n    // Dictionary of all rules associated with this RateLimiter, keyed by their\n    // id. Each rule object stores the rule pattern, number of events allowed,\n    // last reset time and the rule reset interval in milliseconds.\n    this.rules = {};\n  }\n  /**\n  * Checks if this input has exceeded any rate limits.\n  * @param  {object} input dictionary containing key-value pairs of attributes\n  * that match to rules\n  * @return {object} Returns object of following structure\n  * { 'allowed': boolean - is this input allowed\n  *   'timeToReset': integer | Infinity - returns time until counters are reset\n  *                   in milliseconds\n  *   'numInvocationsLeft': integer | Infinity - returns number of calls left\n  *   before limit is reached\n  * }\n  * If multiple rules match, the least number of invocations left is returned.\n  * If the rate limit has been reached, the longest timeToReset is returned.\n  */\n\n\n  var _proto2 = RateLimiter.prototype;\n\n  _proto2.check = function () {\n    function check(input) {\n      var reply = {\n        allowed: true,\n        timeToReset: 0,\n        numInvocationsLeft: Infinity\n      };\n\n      var matchedRules = this._findAllMatchingRules(input);\n\n      matchedRules.forEach(function (rule) {\n        var ruleResult = rule.apply(input);\n        var numInvocations = rule.counters[ruleResult.key];\n\n        if (ruleResult.timeToNextReset < 0) {\n          // Reset all the counters since the rule has reset\n          rule.resetCounter();\n          ruleResult.timeSinceLastReset = new Date().getTime() - rule._lastResetTime;\n          ruleResult.timeToNextReset = rule.options.intervalTime;\n          numInvocations = 0;\n        }\n\n        if (numInvocations > rule.options.numRequestsAllowed) {\n          // Only update timeToReset if the new time would be longer than the\n          // previously set time. This is to ensure that if this input triggers\n          // multiple rules, we return the longest period of time until they can\n          // successfully make another call\n          if (reply.timeToReset < ruleResult.timeToNextReset) {\n            reply.timeToReset = ruleResult.timeToNextReset;\n          }\n\n          reply.allowed = false;\n          reply.numInvocationsLeft = 0;\n\n          rule._executeCallback(reply, input);\n        } else {\n          // If this is an allowed attempt and we haven't failed on any of the\n          // other rules that match, update the reply field.\n          if (rule.options.numRequestsAllowed - numInvocations < reply.numInvocationsLeft && reply.allowed) {\n            reply.timeToReset = ruleResult.timeToNextReset;\n            reply.numInvocationsLeft = rule.options.numRequestsAllowed - numInvocations;\n          }\n\n          rule._executeCallback(reply, input);\n        }\n      });\n      return reply;\n    }\n\n    return check;\n  }()\n  /**\n  * Adds a rule to dictionary of rules that are checked against on every call.\n  * Only inputs that pass all of the rules will be allowed. Returns unique rule\n  * id that can be passed to `removeRule`.\n  * @param {object} rule    Input dictionary defining certain attributes and\n  * rules associated with them.\n  * Each attribute's value can either be a value, a function or null. All\n  * functions must return a boolean of whether the input is matched by that\n  * attribute's rule or not\n  * @param {integer} numRequestsAllowed Optional. Number of events allowed per\n  * interval. Default = 10.\n  * @param {integer} intervalTime Optional. Number of milliseconds before\n  * rule's counters are reset. Default = 1000.\n  * @param {function} callback Optional. Function to be called after a\n  * rule is executed. Two objects will be passed to this function.\n  * The first one is the result of RateLimiter.prototype.check\n  * The second is the input object of the rule, it has the following structure:\n  * {\n  *   'type': string - either 'method' or 'subscription'\n  *   'name': string - the name of the method or subscription being called\n  *   'userId': string - the user ID attempting the method or subscription\n  *   'connectionId': string - a string representing the user's DDP connection\n  *   'clientAddress': string - the IP address of the user\n  * }\n  * @return {string} Returns unique rule id\n  */\n  ;\n\n  _proto2.addRule = function () {\n    function addRule(rule, numRequestsAllowed, intervalTime, callback) {\n      var options = {\n        numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,\n        intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS,\n        callback: callback && Meteor.bindEnvironment(callback)\n      };\n      var newRule = new Rule(options, rule);\n      this.rules[newRule.id] = newRule;\n      return newRule.id;\n    }\n\n    return addRule;\n  }()\n  /**\n  * Increment counters in every rule that match to this input\n  * @param  {object} input Dictionary object containing attributes that may\n  * match to rules\n  */\n  ;\n\n  _proto2.increment = function () {\n    function increment(input) {\n      // Only increment rule counters that match this input\n      var matchedRules = this._findAllMatchingRules(input);\n\n      matchedRules.forEach(function (rule) {\n        var ruleResult = rule.apply(input);\n\n        if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {\n          // Reset all the counters since the rule has reset\n          rule.resetCounter();\n        } // Check whether the key exists, incrementing it if so or otherwise\n        // adding the key and setting its value to 1\n\n\n        if (hasOwn.call(rule.counters, ruleResult.key)) {\n          rule.counters[ruleResult.key]++;\n        } else {\n          rule.counters[ruleResult.key] = 1;\n        }\n      });\n    }\n\n    return increment;\n  }() // Returns an array of all rules that apply to provided input\n  ;\n\n  _proto2._findAllMatchingRules = function () {\n    function _findAllMatchingRules(input) {\n      return Object.values(this.rules).filter(function (rule) {\n        return rule.match(input);\n      });\n    }\n\n    return _findAllMatchingRules;\n  }()\n  /**\n   * Provides a mechanism to remove rules from the rate limiter. Returns boolean\n   * about success.\n   * @param  {string} id Rule id returned from #addRule\n   * @return {boolean} Returns true if rule was found and deleted, else false.\n   */\n  ;\n\n  _proto2.removeRule = function () {\n    function removeRule(id) {\n      if (this.rules[id]) {\n        delete this.rules[id];\n        return true;\n      }\n\n      return false;\n    }\n\n    return removeRule;\n  }();\n\n  return RateLimiter;\n}();","map":{"version":3,"sources":["packages/rate-limit/rate-limit.js"],"names":["_slicedToArray","module","link","default","v","export","RateLimiter","Meteor","Random","DEFAULT_INTERVAL_TIME_IN_MILLISECONDS","DEFAULT_REQUESTS_PER_INTERVAL","hasOwn","Object","prototype","hasOwnProperty","Rule","options","matchers","id","_matchers","_lastResetTime","Date","getTime","counters","match","input","entries","every","key","matcher","call","_generateKeyString","filter","reduce","returnString","apply","timeSinceLastReset","timeToNextReset","intervalTime","resetCounter","_executeCallback","reply","ruleInput","callback","e","console","error","rules","check","allowed","timeToReset","numInvocationsLeft","Infinity","matchedRules","_findAllMatchingRules","forEach","rule","ruleResult","numInvocations","numRequestsAllowed","addRule","bindEnvironment","newRule","increment","values","removeRule"],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Random } from 'meteor/random';\n\n// Default time interval (in milliseconds) to reset rate limit counters\nconst DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;\n// Default number of events allowed per time interval\nconst DEFAULT_REQUESTS_PER_INTERVAL = 10;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// A rule is defined by an options object that contains two fields,\n// `numRequestsAllowed` which is the number of events allowed per interval, and\n// an `intervalTime` which is the amount of time in milliseconds before the\n// rate limit restarts its internal counters, and by a matchers object. A\n// matchers object is a POJO that contains a set of keys with values that\n// define the entire set of inputs that match for each key. The values can\n// either be null (optional), a primitive or a function that returns a boolean\n// of whether the provided input's value matches for this key.\n//\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\n// which are records used to keep track of inputs that match the rule. If a\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a\n// rate limit is reached and future inputs that map to that counter will\n// result in errors being returned to the client.\nclass Rule {\n  constructor(options, matchers) {\n    this.id = Random.id();\n\n    this.options = options;\n\n    this._matchers = matchers;\n\n    this._lastResetTime = new Date().getTime();\n\n    // Dictionary of input keys to counters\n    this.counters = {};\n  }\n  // Determine if this rule applies to the given input by comparing all\n  // rule.matchers. If the match fails, search short circuits instead of\n  // iterating through all matchers.\n  match(input) {\n    return Object\n      .entries(this._matchers)\n      .every(([key, matcher]) => {\n        if (matcher !== null) {\n          if (!hasOwn.call(input, key)) {\n            return false;\n          } else if (typeof matcher === 'function') {\n            if (!(matcher(input[key]))) {\n              return false;\n            }\n          } else if (matcher !== input[key]) {\n            return false;\n          }\n        }\n        return true;\n      });\n  }\n\n  // Generates unique key string for provided input by concatenating all the\n  // keys in the matcher with the corresponding values in the input.\n  // Only called if rule matches input.\n  _generateKeyString(input) {\n    return Object.entries(this._matchers)\n      .filter(([key]) => this._matchers[key] !== null)\n      .reduce((returnString, [key, matcher]) => {\n        if (typeof matcher === 'function') {\n          if (matcher(input[key])) {\n            returnString += key + input[key];\n          }\n        } else {\n          returnString += key + input[key];\n        }\n        return returnString;\n      }, '');\n  }\n\n  // Applies the provided input and returns the key string, time since counters\n  // were last reset and time to next reset.\n  apply(input) {\n    const key = this._generateKeyString(input);\n    const timeSinceLastReset = new Date().getTime() - this._lastResetTime;\n    const timeToNextReset = this.options.intervalTime - timeSinceLastReset;\n    return {\n      key,\n      timeSinceLastReset,\n      timeToNextReset,\n    };\n  }\n\n  // Reset counter dictionary for this specific rule. Called once the\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is\n  // set to be the current time in milliseconds.\n  resetCounter() {\n    // Delete the old counters dictionary to allow for garbage collection\n    this.counters = {};\n    this._lastResetTime = new Date().getTime();\n  }\n\n  _executeCallback(reply, ruleInput) {\n    try {\n      if (this.options.callback) {\n        this.options.callback(reply, ruleInput);\n      }\n    } catch (e) {\n      // Do not throw error here\n      console.error(e);\n    }\n  }\n}\n\nclass RateLimiter {\n  // Initialize rules to be an empty dictionary.\n  constructor() {\n    // Dictionary of all rules associated with this RateLimiter, keyed by their\n    // id. Each rule object stores the rule pattern, number of events allowed,\n    // last reset time and the rule reset interval in milliseconds.\n\n    this.rules = {};\n  }\n\n  /**\n  * Checks if this input has exceeded any rate limits.\n  * @param  {object} input dictionary containing key-value pairs of attributes\n  * that match to rules\n  * @return {object} Returns object of following structure\n  * { 'allowed': boolean - is this input allowed\n  *   'timeToReset': integer | Infinity - returns time until counters are reset\n  *                   in milliseconds\n  *   'numInvocationsLeft': integer | Infinity - returns number of calls left\n  *   before limit is reached\n  * }\n  * If multiple rules match, the least number of invocations left is returned.\n  * If the rate limit has been reached, the longest timeToReset is returned.\n  */\n  check(input) {\n    const reply = {\n      allowed: true,\n      timeToReset: 0,\n      numInvocationsLeft: Infinity,\n    };\n\n    const matchedRules = this._findAllMatchingRules(input);\n    matchedRules.forEach((rule) => {\n      const ruleResult = rule.apply(input);\n      let numInvocations = rule.counters[ruleResult.key];\n\n      if (ruleResult.timeToNextReset < 0) {\n        // Reset all the counters since the rule has reset\n        rule.resetCounter();\n        ruleResult.timeSinceLastReset = new Date().getTime() -\n          rule._lastResetTime;\n        ruleResult.timeToNextReset = rule.options.intervalTime;\n        numInvocations = 0;\n      }\n\n      if (numInvocations > rule.options.numRequestsAllowed) {\n        // Only update timeToReset if the new time would be longer than the\n        // previously set time. This is to ensure that if this input triggers\n        // multiple rules, we return the longest period of time until they can\n        // successfully make another call\n        if (reply.timeToReset < ruleResult.timeToNextReset) {\n          reply.timeToReset = ruleResult.timeToNextReset;\n        }\n        reply.allowed = false;\n        reply.numInvocationsLeft = 0;\n        rule._executeCallback(reply, input);\n      } else {\n        // If this is an allowed attempt and we haven't failed on any of the\n        // other rules that match, update the reply field.\n        if (rule.options.numRequestsAllowed - numInvocations <\n          reply.numInvocationsLeft && reply.allowed) {\n          reply.timeToReset = ruleResult.timeToNextReset;\n          reply.numInvocationsLeft = rule.options.numRequestsAllowed -\n            numInvocations;\n        }\n        rule._executeCallback(reply, input);\n      }\n    });\n    return reply;\n  }\n\n  /**\n  * Adds a rule to dictionary of rules that are checked against on every call.\n  * Only inputs that pass all of the rules will be allowed. Returns unique rule\n  * id that can be passed to `removeRule`.\n  * @param {object} rule    Input dictionary defining certain attributes and\n  * rules associated with them.\n  * Each attribute's value can either be a value, a function or null. All\n  * functions must return a boolean of whether the input is matched by that\n  * attribute's rule or not\n  * @param {integer} numRequestsAllowed Optional. Number of events allowed per\n  * interval. Default = 10.\n  * @param {integer} intervalTime Optional. Number of milliseconds before\n  * rule's counters are reset. Default = 1000.\n  * @param {function} callback Optional. Function to be called after a\n  * rule is executed. Two objects will be passed to this function.\n  * The first one is the result of RateLimiter.prototype.check\n  * The second is the input object of the rule, it has the following structure:\n  * {\n  *   'type': string - either 'method' or 'subscription'\n  *   'name': string - the name of the method or subscription being called\n  *   'userId': string - the user ID attempting the method or subscription\n  *   'connectionId': string - a string representing the user's DDP connection\n  *   'clientAddress': string - the IP address of the user\n  * }\n  * @return {string} Returns unique rule id\n  */\n  addRule(rule, numRequestsAllowed, intervalTime, callback) {\n    const options = {\n      numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,\n      intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS,\n      callback: callback && Meteor.bindEnvironment(callback),\n    };\n\n    const newRule = new Rule(options, rule);\n    this.rules[newRule.id] = newRule;\n    return newRule.id;\n  }\n\n  /**\n  * Increment counters in every rule that match to this input\n  * @param  {object} input Dictionary object containing attributes that may\n  * match to rules\n  */\n  increment(input) {\n    // Only increment rule counters that match this input\n    const matchedRules = this._findAllMatchingRules(input);\n    matchedRules.forEach((rule) => {\n      const ruleResult = rule.apply(input);\n\n      if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {\n        // Reset all the counters since the rule has reset\n        rule.resetCounter();\n      }\n\n      // Check whether the key exists, incrementing it if so or otherwise\n      // adding the key and setting its value to 1\n      if (hasOwn.call(rule.counters, ruleResult.key)) {\n        rule.counters[ruleResult.key]++;\n      } else {\n        rule.counters[ruleResult.key] = 1;\n      }\n    });\n  }\n\n  // Returns an array of all rules that apply to provided input\n  _findAllMatchingRules(input) {\n    return Object.values(this.rules).filter(rule => rule.match(input));\n  }\n\n  /**\n   * Provides a mechanism to remove rules from the rate limiter. Returns boolean\n   * about success.\n   * @param  {string} id Rule id returned from #addRule\n   * @return {boolean} Returns true if rule was found and deleted, else false.\n   */\n  removeRule(id) {\n    if (this.rules[id]) {\n      delete this.rules[id];\n      return true;\n    }\n    return false;\n  }\n}\n\nexport { RateLimiter };\n"]},"sourceType":"module","hash":"d330e9cb2ff61ae2abd54ff0bd460cfb251c0bc4"}
