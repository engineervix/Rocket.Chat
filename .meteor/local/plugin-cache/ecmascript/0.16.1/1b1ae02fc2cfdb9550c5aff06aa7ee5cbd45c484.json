{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/sodiumplus.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"imports/client/sodium-plus/lib/sodiumplus.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/sodiumplus.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/sodiumplus.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/client/sodium-plus/lib/sodiumplus.js"}},"code":"!function (module1) {\n  const Backend = require('./backend');\n\n  const CryptographyKey = require('./cryptography-key');\n\n  const Ed25519SecretKey = require('./keytypes/ed25519sk');\n\n  const Ed25519PublicKey = require('./keytypes/ed25519pk');\n\n  const LibsodiumWrappersBackend = require('./backend/libsodium-wrappers');\n\n  const SodiumError = require('./sodium-error');\n\n  const SodiumNativeBackend = require('./backend/sodiumnative');\n\n  const X25519PublicKey = require('./keytypes/x25519pk');\n\n  const X25519SecretKey = require('./keytypes/x25519sk');\n\n  const Util = require('./util');\n  /* istanbul ignore if */\n\n\n  if (typeof Buffer === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n  }\n\n  class SodiumPlus {\n    constructor(backend) {\n      /* istanbul ignore if */\n      if (!(backend instanceof Backend)) {\n        throw new TypeError('Backend object must implement the backend function');\n      }\n\n      this.backend = backend;\n      Util.populateConstants(this);\n    }\n    /**\n     * Returns the name of the current active backend.\n     * This method is NOT async.\n     *\n     * @return {string}\n     */\n\n\n    getBackendName() {\n      return this.backend.backendName;\n    }\n    /**\n     * Is this powered by sodium-native?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n\n\n    isSodiumNative() {\n      return this.backend instanceof SodiumNativeBackend;\n    }\n    /**\n     * Is this powered by libsodium-wrappers?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n\n\n    isLibsodiumWrappers() {\n      return this.backend instanceof LibsodiumWrappersBackend;\n    }\n    /**\n     * Automatically select a backend.\n     *\n     * @return {Promise<SodiumPlus>}\n     */\n\n\n    static async auto() {\n      let backend;\n\n      try {\n        backend = await SodiumNativeBackend.init();\n      } catch (e) {\n        backend = await LibsodiumWrappersBackend.init();\n      }\n      /* istanbul ignore if */\n\n\n      if (!backend) {\n        backend = await LibsodiumWrappersBackend.init();\n      }\n\n      Util.populateConstants(backend);\n      return new SodiumPlus(backend);\n    }\n    /**\n     * If our backend isn't defined, it will trigger an autoload.\n     *\n     * Mostly used internally. `await SodiumPlus.auto()` provides the same\n     * exact guarantee as this method.\n     *\n     * @return {Promise<void>}\n     */\n\n\n    async ensureLoaded() {\n      /* istanbul ignore if */\n      if (typeof this.backend === 'undefined') {\n        try {\n          await SodiumPlus.auto();\n        } catch (e) {\n          this.backend = await LibsodiumWrappersBackend.init();\n        }\n      }\n    }\n    /**\n     * Decrypt a message (and optional associated data) with XChaCha20-Poly1305\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n\n\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, nonce, key) {\n      let assocData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      await this.ensureLoaded();\n\n      if (nonce.length !== 24) {\n        throw new SodiumError('Argument 2 must be 24 bytes');\n      }\n\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n      }\n\n      return await this.backend.crypto_aead_xchacha20poly1305_ietf_decrypt(await Util.toBuffer(ciphertext), assocData.length > 0 ? await Util.toBuffer(assocData) : null, await Util.toBuffer(nonce), key);\n    }\n    /**\n     * Encrypt a message (and optional associated data) with XChaCha20-Poly1305.\n     *\n     * Throws a SodiumError if an invalid ciphertext/AAD is provided for this\n     * nonce and key.\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n\n\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, nonce, key) {\n      let assocData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      await this.ensureLoaded();\n\n      if (nonce.length !== 24) {\n        throw new SodiumError('Argument 2 must be 24 bytes');\n      }\n\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n      }\n\n      return await this.backend.crypto_aead_xchacha20poly1305_ietf_encrypt(await Util.toBuffer(plaintext), assocData.length > 0 ? await Util.toBuffer(assocData) : null, await Util.toBuffer(nonce), key);\n    }\n    /**\n     * Generate an XChaCha20-Poly1305 key.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_aead_xchacha20poly1305_ietf_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n    /**\n     * Get an authenticator for a message for a given key.\n     *\n     * Algorithm: HMAC-SHA512 truncated to 32 bytes.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_auth(message, key) {\n      await this.ensureLoaded();\n\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n\n      await this.ensureLoaded();\n      return await this.backend.crypto_auth(await Util.toBuffer(message), key);\n    }\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_auth_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n    /**\n     * Verify an authenticator for a message for a given key.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} mac\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_auth_verify(message, key, mac) {\n      await this.ensureLoaded();\n\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n\n      await this.ensureLoaded();\n      return await this.backend.crypto_auth_verify(await Util.toBuffer(mac), await Util.toBuffer(message), key);\n    }\n    /**\n     * Public-key authenticated encryption.\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_box(plaintext, nonce, myPrivateKey, theirPublicKey) {\n      await this.ensureLoaded();\n\n      if (!(myPrivateKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n      }\n\n      if (!(theirPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n      }\n\n      nonce = await Util.toBuffer(nonce);\n\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n\n      return this.backend.crypto_box(await Util.toBuffer(plaintext), await Util.toBuffer(nonce), myPrivateKey, theirPublicKey);\n    }\n    /**\n     * Public-key authenticated decryption.\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey) {\n      await this.ensureLoaded();\n\n      if (!(myPrivateKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n      }\n\n      if (!(theirPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n      }\n\n      ciphertext = await Util.toBuffer(ciphertext);\n\n      if (ciphertext.length < 16) {\n        throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n      }\n\n      nonce = await Util.toBuffer(nonce);\n\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n\n      return this.backend.crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey);\n    }\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_box_keypair() {\n      await this.ensureLoaded();\n      return this.backend.crypto_box_keypair();\n    }\n    /**\n     * Combine two X25519 keys (secret, public) into a keypair object.\n     *\n     * @param {X25519SecretKey} sKey\n     * @param {X25519PublicKey} pKey\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey) {\n      await this.ensureLoaded();\n\n      if (!(sKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n\n      if (!(pKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n\n      return await this.backend.crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey);\n    }\n    /**\n     * Extract the secret key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519SecretKey>}\n     */\n\n\n    async crypto_box_secretkey(keypair) {\n      if (keypair.getLength() !== 64) {\n        throw new SodiumError('Keypair must be 64 bytes');\n      }\n\n      return new X25519SecretKey(Buffer.from(keypair.getBuffer().slice(0, 32)));\n    }\n    /**\n     * Extract the public key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519PublicKey>}\n     */\n\n\n    async crypto_box_publickey(keypair) {\n      if (keypair.getLength() !== 64) {\n        throw new SodiumError('Keypair must be 64 bytes');\n      }\n\n      return new X25519PublicKey(Buffer.from(keypair.getBuffer().slice(32, 64)));\n    }\n    /**\n     * Derive the public key from a given X25519 secret key.\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n\n\n    async crypto_box_publickey_from_secretkey(secretKey) {\n      await this.ensureLoaded();\n\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n\n      return new X25519PublicKey(await this.backend.crypto_scalarmult_base(secretKey));\n    }\n    /**\n     * Anonymous public-key encryption. (Message integrity is still assured.)\n     *\n     * @param {string|Buffer} plaintext\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_box_seal(plaintext, publicKey) {\n      await this.ensureLoaded();\n\n      if (!(publicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n\n      return await this.backend.crypto_box_seal(plaintext, publicKey);\n    }\n    /**\n     * Anonymous public-key decryption. (Message integrity is still assured.)\n     *\n     * @param {Buffer} ciphertext\n     * @param {X25519PublicKey} publicKey\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_box_seal_open(ciphertext, publicKey, secretKey) {\n      await this.ensureLoaded();\n\n      if (!(publicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n      }\n\n      return await this.backend.crypto_box_seal_open(await Util.toBuffer(ciphertext), publicKey, secretKey);\n    }\n    /**\n     * Generic-purpose cryptographic hash.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_generichash(message) {\n      let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let outputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash(message, key, outputLength);\n    }\n    /**\n     * Initialize a BLAKE2 hash context for stream hashing.\n     *\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_generichash_init() {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      let outputLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash_init(key, outputLength);\n    }\n    /**\n     * Update the BLAKE2 hash state with a block of data.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n\n\n    async crypto_generichash_update(state, message) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash_update(state, message);\n    }\n    /**\n     * Obtain the final BLAKE2 hash output.\n     *\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_generichash_final(state) {\n      let outputLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash_final(state, outputLength);\n    }\n    /**\n     * Generate a 256-bit random key for BLAKE2.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_generichash_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_GENERICHASH_KEYBYTES));\n    }\n    /**\n     * Derive a subkey from a master key.\n     *\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n      await this.ensureLoaded();\n\n      if (length < 1) {\n        throw new SodiumError('Length must be a positive integer.');\n      }\n\n      if (subKeyId < 0) {\n        throw new SodiumError('Key ID must be an unsigned integer');\n      }\n\n      return await this.backend.crypto_kdf_derive_from_key(length, subKeyId, context, key);\n    }\n    /**\n     * Generate a 256-bit random key for our KDF.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_kdf_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_KDF_KEYBYTES));\n    }\n    /**\n     * This is functionally identical to crypto_box_keypair().\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_kx_keypair() {\n      return this.crypto_box_keypair();\n    }\n    /**\n     * Generate an X25519 keypair from a seed.\n     *\n     * @param {string|Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_kx_seed_keypair(seed) {\n      await this.ensureLoaded();\n      const sk = await this.backend.crypto_generichash(seed, null, this.CRYPTO_KX_SECRETKEYBYTES);\n      const pk = await this.backend.crypto_scalarmult_base(new CryptographyKey(sk));\n      return new CryptographyKey(Buffer.concat([sk, pk]));\n    }\n    /**\n     * Perform a key exchange from the client's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the server to the client (incoming decryption).\n     * The second is meant for data sent from the client to the server (outgoing encryption).\n     *\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n\n\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n      await this.ensureLoaded();\n\n      if (!(clientPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n      }\n\n      if (!(clientSecretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n      }\n\n      if (!(serverPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n      }\n\n      return this.backend.crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey);\n    }\n    /**\n     * Perform a key exchange from the server's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the client to the server (incoming decryption).\n     * The second is meant for data sent from the server to the client (outgoing encryption).\n     *\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n\n\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n      await this.ensureLoaded();\n\n      if (!(serverPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n      }\n\n      if (!(serverSecretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n      }\n\n      if (!(clientPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n      }\n\n      return this.backend.crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey);\n    }\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_onetimeauth(message, key) {\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n\n      return await this.backend.crypto_onetimeauth(await Util.toBuffer(message), key);\n    }\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_onetimeauth_verify(message, key, tag) {\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n\n      return await this.backend.crypto_onetimeauth_verify(await Util.toBuffer(message), key, await Util.toBuffer(tag));\n    }\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_onetimeauth_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n    /**\n     * Derive a cryptography key from a password and salt.\n     *\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number|null} algorithm\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_pwhash(length, password, salt, opslimit, memlimit) {\n      let algorithm = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      await this.ensureLoaded();\n      /* istanbul ignore if */\n\n      if (!algorithm) {\n        algorithm = this.CRYPTO_PWHASH_ALG_DEFAULT;\n      }\n\n      return new CryptographyKey(await this.backend.crypto_pwhash(length, await Util.toBuffer(password), await Util.toBuffer(salt), opslimit, memlimit, algorithm));\n    }\n    /**\n     * Get a password hash (in a safe-for-storage format)\n     *\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n\n\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_pwhash_str(password, opslimit, memlimit);\n    }\n    /**\n     * Verify a password against a known password hash\n     *\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_pwhash_str_verify(password, hash) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_pwhash_str_verify(password, hash);\n    }\n    /**\n     * Does this password need to be rehashed?\n     *\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit);\n    }\n    /**\n     * Elliptic Curve Diffie-Hellman key exchange\n     *\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_scalarmult(secretKey, publicKey) {\n      await this.ensureLoaded();\n\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n\n      if (!(publicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n\n      return await this.backend.crypto_scalarmult(secretKey, publicKey);\n    }\n    /**\n     * Generate an X25519PublicKey from an X25519SecretKey\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n\n\n    async crypto_scalarmult_base(secretKey) {\n      await this.ensureLoaded();\n\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n\n      return new X25519PublicKey(await this.backend.crypto_scalarmult_base(secretKey));\n    }\n    /**\n     * Shared-key authenticated encryption\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretbox(plaintext, nonce, key) {\n      await this.ensureLoaded();\n\n      if (key.isEd25519Key() || key.isX25519Key()) {\n        throw new TypeError('Argument 3 must not be an asymmetric key');\n      }\n\n      nonce = await Util.toBuffer(nonce);\n\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n\n      return await this.backend.crypto_secretbox(plaintext, nonce, key);\n    }\n    /**\n     * Shared-key authenticated decryption\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n      await this.ensureLoaded();\n\n      if (key.isEd25519Key() || key.isX25519Key()) {\n        throw new TypeError('Argument 3 must not be an asymmetric key');\n      }\n\n      ciphertext = await Util.toBuffer(ciphertext);\n\n      if (ciphertext.length < 16) {\n        throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n      }\n\n      nonce = await Util.toBuffer(nonce);\n\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n\n      return await this.backend.crypto_secretbox_open(ciphertext, nonce, key);\n    }\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_secretbox_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_SECRETBOX_KEYBYTES));\n    }\n    /**\n     * Internalize the internal state and a random header for stream encryption.\n     *\n     * @param {CryptographyKey} key\n     * @return {Promise<array>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n      await this.ensureLoaded();\n\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Key must be an instance of CryptographyKey');\n      }\n\n      if (key.getLength() !== 32) {\n        throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n      }\n\n      const [state, header] = await this.backend.crypto_secretstream_xchacha20poly1305_init_push(key);\n      return Object.freeze({\n        header: header,\n        push: this.crypto_secretstream_xchacha20poly1305_push.bind(this, state),\n        rekey: this.crypto_secretstream_xchacha20poly1305_rekey.bind(this, state)\n      });\n    }\n    /**\n     * Initialize the internal state for stream decryption.\n     *\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_init_pull(key, header) {\n      await this.ensureLoaded();\n      header = await Util.toBuffer(header);\n\n      if (header.length !== 24) {\n        throw new SodiumError('crypto_secretstream headers must be 24 bytes long');\n      }\n\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Key must be an instance of CryptographyKey');\n      }\n\n      if (key.getLength() !== 32) {\n        throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n      }\n\n      const state = await this.backend.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n      return Object.freeze({\n        pull: this.crypto_secretstream_xchacha20poly1305_pull.bind(this, state)\n      });\n    }\n    /**\n     * Stream encryption.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_push(state, message) {\n      let ad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let tag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      await this.ensureLoaded();\n      return this.backend.crypto_secretstream_xchacha20poly1305_push(state, message, ad, tag);\n    }\n    /**\n     * Stream decryption.\n     *\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext) {\n      let ad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let tag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      await this.ensureLoaded();\n      return this.backend.crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad, tag);\n    }\n    /**\n     * Deterministic rekeying.\n     *\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n      await this.ensureLoaded();\n      await this.backend.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES));\n    }\n    /**\n     * Calculate a fast hash for short inputs.\n     *\n     * Algorithm: SipHash-2-4\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_shorthash(message, key) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_shorthash(await Util.toBuffer(message), key);\n    }\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_shorthash_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_SHORTHASH_KEYBYTES));\n    }\n    /**\n     * Returns a signed message.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign(message, secretKey) {\n      await this.ensureLoaded();\n\n      if (!(secretKey instanceof Ed25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n      }\n\n      return this.backend.crypto_sign(message, secretKey);\n    }\n    /**\n     * Given a signed message, verify the Ed25519 signature. If it matches, return the\n     * bare message (no signature).\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_open(message, publicKey) {\n      await this.ensureLoaded();\n\n      if (!(publicKey instanceof Ed25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n      }\n\n      return this.backend.crypto_sign_open(message, publicKey);\n    }\n    /**\n     * Returns the Ed25519 signature of the message, for the given secret key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_detached(message, secretKey) {\n      await this.ensureLoaded();\n\n      if (!(secretKey instanceof Ed25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n      }\n\n      return this.backend.crypto_sign_detached(message, secretKey);\n    }\n    /**\n     * Returns true if the Ed25519 signature is valid for a given message and public key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n      await this.ensureLoaded();\n\n      if (!(publicKey instanceof Ed25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n      }\n\n      return this.backend.crypto_sign_verify_detached(message, publicKey, signature);\n    }\n    /**\n     * Extract the secret key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519SecretKey>}\n     */\n\n\n    async crypto_sign_secretkey(keypair) {\n      if (keypair.getLength() !== 96) {\n        throw new SodiumError('Keypair must be 96 bytes');\n      }\n\n      return new Ed25519SecretKey(await Util.toBuffer(keypair.getBuffer().slice(0, 64)));\n    }\n    /**\n     * Extract the public key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519PublicKey>}\n     */\n\n\n    async crypto_sign_publickey(keypair) {\n      if (keypair.getLength() !== 96) {\n        throw new SodiumError('Keypair must be 96 bytes');\n      }\n\n      return new Ed25519PublicKey(keypair.getBuffer().slice(64, 96));\n    }\n    /**\n     * Generate an Ed25519 keypair object.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_sign_keypair() {\n      await this.ensureLoaded();\n      return this.backend.crypto_sign_keypair();\n    }\n    /**\n     * Generate an Ed25519 keypair object from a seed.\n     *\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_sign_seed_keypair(seed) {\n      await this.ensureLoaded();\n\n      if (seed instanceof CryptographyKey) {\n        seed = seed.getBuffer();\n      }\n\n      seed = await Util.toBuffer(seed);\n\n      if (seed.length !== 32) {\n        throw new SodiumError(\"Seed must be 32 bytes long; got \".concat(seed.length));\n      }\n\n      return this.backend.crypto_sign_seed_keypair(seed);\n    }\n    /**\n     * Obtain a birationally equivalent X25519 secret key,\n     * given an Ed25519 secret key.\n     *\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<X25519SecretKey>}\n     */\n\n\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n      await this.ensureLoaded();\n      return new X25519SecretKey(await this.backend.crypto_sign_ed25519_sk_to_curve25519(sk));\n    }\n    /**\n     * Obtain a birationally equivalent X25519 public key,\n     * given an Ed25519 public key.\n     *\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<X25519PublicKey>}\n     */\n\n\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n      await this.ensureLoaded();\n      return new X25519PublicKey(await this.backend.crypto_sign_ed25519_pk_to_curve25519(pk));\n    }\n    /**\n     * Generate an arbitrary number of pseudorandom bytes from a given\n     * nonce and key.\n     *\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_stream(length, nonce, key) {\n      await this.ensureLoaded();\n      return this.backend.crypto_stream(length, nonce, key);\n    }\n    /**\n     * Encrypts a string (without authentication).\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_stream_xor(plaintext, nonce, key) {\n      await this.ensureLoaded();\n      return this.backend.crypto_stream_xor(plaintext, nonce, key);\n    }\n    /**\n     * Generate a key for stream ciphers.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_stream_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_STREAM_KEYBYTES));\n    }\n    /**\n     * Returns a buffer filled with random bytes.\n     *\n     * @param {number} num\n     * @return {Promise<Buffer>}\n     */\n\n\n    async randombytes_buf(num) {\n      await this.ensureLoaded();\n      return await this.backend.randombytes_buf(num);\n    }\n    /**\n     * Generate an integer between 0 and upperBound (non-inclusive).\n     *\n     * For example, randombytes_uniform(10) returns an integer between 0 and 9.\n     *\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n\n\n    async randombytes_uniform(upperBound) {\n      await this.ensureLoaded();\n      return this.backend.randombytes_uniform(upperBound);\n    }\n    /**\n     * Add two buffers (little-endian). Returns the value.\n     *\n     * @param {Buffer} val\n     * @param {Buffer} addv\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_add(val, addv) {\n      await this.ensureLoaded();\n      return await this.backend.sodium_add(await Util.toBuffer(val), await Util.toBuffer(addv));\n    }\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer} decoded\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_bin2hex(decoded) {\n      await this.ensureLoaded();\n      return this.backend.sodium_bin2hex(decoded);\n    }\n    /**\n     * Compare two buffers in constant time.\n     *\n     * Returns -1 if b1 is less than b2.\n     * Returns  1 if b1 is greater than b2.\n     * Returns  0 if b1 is equal to b2.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n\n\n    async sodium_compare(b1, b2) {\n      await this.ensureLoaded();\n      return this.backend.sodium_compare(b1, b2);\n    }\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer|string} encoded\n     * @return {Promise<string>}\n     */\n\n\n    async sodium_hex2bin(encoded) {\n      await this.ensureLoaded();\n      return this.backend.sodium_hex2bin(encoded);\n    }\n    /**\n     * Increment a buffer (little endian). Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_increment(buf) {\n      await this.ensureLoaded();\n      return this.backend.sodium_increment(buf);\n    }\n    /**\n     * Returns true if the buffer is zero.\n     *\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_is_zero(buf, len) {\n      await this.ensureLoaded();\n      return this.backend.sodium_is_zero(buf, len);\n    }\n    /**\n     * Timing-safe buffer comparison.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n\n\n    async sodium_memcmp(b1, b2) {\n      await this.ensureLoaded();\n      return this.backend.sodium_memcmp(b1, b2);\n    }\n    /**\n     * Zero out a buffer. Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n\n\n    async sodium_memzero(buf) {\n      await this.ensureLoaded();\n      await this.backend.sodium_memzero(buf);\n    }\n    /**\n     * Pad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_pad(buf, blockSize) {\n      await this.ensureLoaded();\n      return this.backend.sodium_pad(buf, blockSize);\n    }\n    /**\n     * Unpad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_unpad(buf, blockSize) {\n      await this.ensureLoaded();\n      return this.backend.sodium_unpad(buf, blockSize);\n    }\n\n  }\n\n  module.exports = SodiumPlus;\n}.call(this, module);","map":{"version":3,"sources":["imports/client/sodium-plus/lib/sodiumplus.js"],"names":["Backend","require","CryptographyKey","Ed25519SecretKey","Ed25519PublicKey","LibsodiumWrappersBackend","SodiumError","SodiumNativeBackend","X25519PublicKey","X25519SecretKey","Util","Buffer","SodiumPlus","constructor","backend","TypeError","populateConstants","getBackendName","backendName","isSodiumNative","isLibsodiumWrappers","auto","init","e","ensureLoaded","crypto_aead_xchacha20poly1305_ietf_decrypt","ciphertext","nonce","key","assocData","length","toBuffer","crypto_aead_xchacha20poly1305_ietf_encrypt","plaintext","crypto_aead_xchacha20poly1305_ietf_keygen","randombytes_buf","crypto_auth","message","crypto_auth_keygen","crypto_auth_verify","mac","crypto_box","myPrivateKey","theirPublicKey","crypto_box_open","crypto_box_keypair","crypto_box_keypair_from_secretkey_and_publickey","sKey","pKey","crypto_box_secretkey","keypair","getLength","from","getBuffer","slice","crypto_box_publickey","crypto_box_publickey_from_secretkey","secretKey","crypto_scalarmult_base","crypto_box_seal","publicKey","crypto_box_seal_open","crypto_generichash","outputLength","crypto_generichash_init","crypto_generichash_update","state","crypto_generichash_final","crypto_generichash_keygen","CRYPTO_GENERICHASH_KEYBYTES","crypto_kdf_derive_from_key","subKeyId","context","crypto_kdf_keygen","CRYPTO_KDF_KEYBYTES","crypto_kx_keypair","crypto_kx_seed_keypair","seed","sk","CRYPTO_KX_SECRETKEYBYTES","pk","concat","crypto_kx_client_session_keys","clientPublicKey","clientSecretKey","serverPublicKey","crypto_kx_server_session_keys","serverSecretKey","crypto_onetimeauth","crypto_onetimeauth_verify","tag","crypto_onetimeauth_keygen","crypto_pwhash","password","salt","opslimit","memlimit","algorithm","CRYPTO_PWHASH_ALG_DEFAULT","crypto_pwhash_str","crypto_pwhash_str_verify","hash","crypto_pwhash_str_needs_rehash","crypto_scalarmult","crypto_secretbox","isEd25519Key","isX25519Key","crypto_secretbox_open","crypto_secretbox_keygen","CRYPTO_SECRETBOX_KEYBYTES","crypto_secretstream_xchacha20poly1305_init_push","header","Object","freeze","push","crypto_secretstream_xchacha20poly1305_push","bind","rekey","crypto_secretstream_xchacha20poly1305_rekey","crypto_secretstream_xchacha20poly1305_init_pull","pull","crypto_secretstream_xchacha20poly1305_pull","ad","crypto_secretstream_xchacha20poly1305_keygen","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES","crypto_shorthash","crypto_shorthash_keygen","CRYPTO_SHORTHASH_KEYBYTES","crypto_sign","crypto_sign_open","crypto_sign_detached","crypto_sign_verify_detached","signature","crypto_sign_secretkey","crypto_sign_publickey","crypto_sign_keypair","crypto_sign_seed_keypair","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_pk_to_curve25519","crypto_stream","crypto_stream_xor","crypto_stream_keygen","CRYPTO_STREAM_KEYBYTES","num","randombytes_uniform","upperBound","sodium_add","val","addv","sodium_bin2hex","decoded","sodium_compare","b1","b2","sodium_hex2bin","encoded","sodium_increment","buf","sodium_is_zero","len","sodium_memcmp","sodium_memzero","sodium_pad","blockSize","sodium_unpad","module","exports"],"mappings":"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","sourcesContent":["const Backend = require('./backend');\nconst CryptographyKey = require('./cryptography-key');\nconst Ed25519SecretKey = require('./keytypes/ed25519sk');\nconst Ed25519PublicKey = require('./keytypes/ed25519pk');\nconst LibsodiumWrappersBackend = require('./backend/libsodium-wrappers');\nconst SodiumError = require('./sodium-error');\nconst SodiumNativeBackend = require('./backend/sodiumnative');\nconst X25519PublicKey = require('./keytypes/x25519pk');\nconst X25519SecretKey = require('./keytypes/x25519sk');\nconst Util = require('./util');\n\n/* istanbul ignore if */\nif (typeof (Buffer) === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n}\n\nclass SodiumPlus {\n    constructor(backend) {\n        /* istanbul ignore if */\n        if (!(backend instanceof Backend)) {\n            throw new TypeError('Backend object must implement the backend function');\n        }\n        this.backend = backend;\n        Util.populateConstants(this);\n    }\n\n    /**\n     * Returns the name of the current active backend.\n     * This method is NOT async.\n     *\n     * @return {string}\n     */\n    getBackendName() {\n        return this.backend.backendName;\n    }\n\n    /**\n     * Is this powered by sodium-native?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isSodiumNative() {\n        return (this.backend instanceof SodiumNativeBackend);\n    }\n\n    /**\n     * Is this powered by libsodium-wrappers?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isLibsodiumWrappers() {\n        return (this.backend instanceof LibsodiumWrappersBackend);\n    }\n\n    /**\n     * Automatically select a backend.\n     *\n     * @return {Promise<SodiumPlus>}\n     */\n    static async auto() {\n        let backend;\n        try {\n            backend = await SodiumNativeBackend.init();\n        } catch (e) {\n            backend = await LibsodiumWrappersBackend.init();\n        }\n        /* istanbul ignore if */\n        if (!backend) {\n            backend = await LibsodiumWrappersBackend.init();\n        }\n        Util.populateConstants(backend);\n        return new SodiumPlus(backend);\n    }\n\n    /**\n     * If our backend isn't defined, it will trigger an autoload.\n     *\n     * Mostly used internally. `await SodiumPlus.auto()` provides the same\n     * exact guarantee as this method.\n     *\n     * @return {Promise<void>}\n     */\n    async ensureLoaded() {\n        /* istanbul ignore if */\n        if (typeof (this.backend) === 'undefined') {\n            try {\n                await SodiumPlus.auto();\n            } catch (e) {\n                this.backend = await LibsodiumWrappersBackend.init();\n            }\n        }\n    }\n\n    /**\n     * Decrypt a message (and optional associated data) with XChaCha20-Poly1305\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, nonce, key, assocData = '') {\n        await this.ensureLoaded();\n        if (nonce.length !== 24) {\n            throw new SodiumError('Argument 2 must be 24 bytes');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            await Util.toBuffer(ciphertext),\n            assocData.length > 0 ? await Util.toBuffer(assocData) : null,\n            await Util.toBuffer(nonce),\n            key\n        );\n    }\n\n    /**\n     * Encrypt a message (and optional associated data) with XChaCha20-Poly1305.\n     *\n     * Throws a SodiumError if an invalid ciphertext/AAD is provided for this\n     * nonce and key.\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, nonce, key, assocData = '') {\n        await this.ensureLoaded();\n        if (nonce.length !== 24) {\n            throw new SodiumError('Argument 2 must be 24 bytes');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n        }\n\n        return await this.backend.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            await Util.toBuffer(plaintext),\n            assocData.length > 0 ? await Util.toBuffer(assocData) : null,\n            await Util.toBuffer(nonce),\n            key\n        );\n    }\n\n    /**\n     * Generate an XChaCha20-Poly1305 key.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_keygen() {\n        return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Get an authenticator for a message for a given key.\n     *\n     * Algorithm: HMAC-SHA512 truncated to 32 bytes.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_auth(message, key) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        await this.ensureLoaded();\n        return await this.backend.crypto_auth(\n            await Util.toBuffer(message),\n            key\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_auth_keygen() {\n        return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Verify an authenticator for a message for a given key.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} mac\n     * @return {Promise<boolean>}\n     */\n    async crypto_auth_verify(message, key, mac) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        await this.ensureLoaded();\n        return await this.backend.crypto_auth_verify(\n            await Util.toBuffer(mac),\n            await Util.toBuffer(message),\n            key\n        );\n    }\n\n    /**\n     * Public-key authenticated encryption.\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box(plaintext, nonce, myPrivateKey, theirPublicKey) {\n        await this.ensureLoaded();\n        if (!(myPrivateKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        if (!(theirPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return this.backend.crypto_box(\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(nonce),\n            myPrivateKey,\n            theirPublicKey\n        );\n    }\n\n    /**\n     * Public-key authenticated decryption.\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey) {\n        await this.ensureLoaded();\n        if (!(myPrivateKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        if (!(theirPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n        }\n        ciphertext = await Util.toBuffer(ciphertext);\n        if (ciphertext.length < 16) {\n            throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return this.backend.crypto_box_open(\n            ciphertext,\n            nonce,\n            myPrivateKey,\n            theirPublicKey\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair() {\n        await this.ensureLoaded();\n        return this.backend.crypto_box_keypair();\n    }\n\n    /**\n     * Combine two X25519 keys (secret, public) into a keypair object.\n     *\n     * @param {X25519SecretKey} sKey\n     * @param {X25519PublicKey} pKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey) {\n        await this.ensureLoaded();\n        if (!(sKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        if (!(pKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey);\n    }\n\n    /**\n     * Extract the secret key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_box_secretkey(keypair) {\n        if (keypair.getLength()!== 64) {\n            throw new SodiumError('Keypair must be 64 bytes');\n        }\n        return new X25519SecretKey(\n            Buffer.from(keypair.getBuffer().slice(0, 32))\n        );\n    }\n\n    /**\n     * Extract the public key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey(keypair) {\n        if (keypair.getLength() !== 64) {\n            throw new SodiumError('Keypair must be 64 bytes');\n        }\n        return new X25519PublicKey(\n            Buffer.from(keypair.getBuffer().slice(32, 64))\n        );\n    }\n\n    /**\n     * Derive the public key from a given X25519 secret key.\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey_from_secretkey(secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        return new X25519PublicKey(\n            await this.backend.crypto_scalarmult_base(secretKey)\n        );\n    }\n\n    /**\n     * Anonymous public-key encryption. (Message integrity is still assured.)\n     *\n     * @param {string|Buffer} plaintext\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal(plaintext, publicKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_box_seal(plaintext, publicKey);\n    }\n\n    /**\n     * Anonymous public-key decryption. (Message integrity is still assured.)\n     *\n     * @param {Buffer} ciphertext\n     * @param {X25519PublicKey} publicKey\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal_open(ciphertext, publicKey, secretKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        return await this.backend.crypto_box_seal_open(\n            await Util.toBuffer(ciphertext),\n            publicKey,\n            secretKey\n        );\n    }\n\n    /**\n     * Generic-purpose cryptographic hash.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash(message, key = null, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash(message, key, outputLength);\n    }\n\n    /**\n     * Initialize a BLAKE2 hash context for stream hashing.\n     *\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_init(key = null, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_init(key, outputLength);\n    }\n\n\n    /**\n     * Update the BLAKE2 hash state with a block of data.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    async crypto_generichash_update(state, message) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_update(state, message);\n    }\n\n    /**\n     * Obtain the final BLAKE2 hash output.\n     *\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_final(state, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_final(state, outputLength);\n    }\n\n    /**\n     * Generate a 256-bit random key for BLAKE2.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_generichash_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_GENERICHASH_KEYBYTES)\n        );\n    }\n\n    /**\n     * Derive a subkey from a master key.\n     *\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        await this.ensureLoaded();\n        if (length < 1) {\n            throw new SodiumError('Length must be a positive integer.');\n        }\n        if (subKeyId < 0) {\n            throw new SodiumError('Key ID must be an unsigned integer');\n        }\n        return await this.backend.crypto_kdf_derive_from_key(\n            length,\n            subKeyId,\n            context,\n            key\n        );\n    }\n\n    /**\n     * Generate a 256-bit random key for our KDF.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_KDF_KEYBYTES)\n        );\n    }\n\n    /**\n     * This is functionally identical to crypto_box_keypair().\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_keypair() {\n        return this.crypto_box_keypair();\n    }\n\n    /**\n     * Generate an X25519 keypair from a seed.\n     *\n     * @param {string|Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_seed_keypair(seed) {\n        await this.ensureLoaded();\n        const sk = await this.backend.crypto_generichash(seed, null, this.CRYPTO_KX_SECRETKEYBYTES);\n        const pk = await this.backend.crypto_scalarmult_base(new CryptographyKey(sk));\n        return new CryptographyKey(Buffer.concat([sk, pk]));\n    }\n\n    /**\n     * Perform a key exchange from the client's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the server to the client (incoming decryption).\n     * The second is meant for data sent from the client to the server (outgoing encryption).\n     *\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        await this.ensureLoaded();\n        if (!(clientPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n        }\n        if (!(clientSecretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n        }\n        if (!(serverPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n        }\n        return this.backend.crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey);\n    }\n\n    /**\n     * Perform a key exchange from the server's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the client to the server (incoming decryption).\n     * The second is meant for data sent from the server to the client (outgoing encryption).\n     *\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        await this.ensureLoaded();\n        if (!(serverPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n        }\n        if (!(serverSecretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n        }\n        if (!(clientPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n        }\n        return this.backend.crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_onetimeauth(message, key) {\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_onetimeauth(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    async crypto_onetimeauth_verify(message, key, tag) {\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_onetimeauth_verify(\n            await Util.toBuffer(message),\n            key,\n            await Util.toBuffer(tag)\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_onetimeauth_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(32)\n        );\n    }\n\n    /**\n     * Derive a cryptography key from a password and salt.\n     *\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number|null} algorithm\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm = null) {\n        await this.ensureLoaded();\n        /* istanbul ignore if */\n        if (!algorithm) {\n            algorithm = this.CRYPTO_PWHASH_ALG_DEFAULT;\n        }\n        return new CryptographyKey(\n            await this.backend.crypto_pwhash(\n                length,\n                await Util.toBuffer(password),\n                await Util.toBuffer(salt),\n                opslimit,\n                memlimit,\n                algorithm\n            )\n        );\n    }\n\n    /**\n     * Get a password hash (in a safe-for-storage format)\n     *\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str(password, opslimit, memlimit);\n    }\n\n    /**\n     * Verify a password against a known password hash\n     *\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_verify(password, hash) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str_verify(password, hash);\n    }\n\n    /**\n     * Does this password need to be rehashed?\n     *\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit);\n    }\n\n    /**\n     * Elliptic Curve Diffie-Hellman key exchange\n     *\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_scalarmult(secretKey, publicKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_scalarmult(secretKey, publicKey);\n    }\n\n    /**\n     * Generate an X25519PublicKey from an X25519SecretKey\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_scalarmult_base(secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        return new X25519PublicKey(\n            await this.backend.crypto_scalarmult_base(secretKey)\n        );\n    }\n\n    /**\n     * Shared-key authenticated encryption\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox(plaintext, nonce, key) {\n        await this.ensureLoaded();\n        if (key.isEd25519Key() || key.isX25519Key()) {\n            throw new TypeError('Argument 3 must not be an asymmetric key');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n\n        return await this.backend.crypto_secretbox(\n            plaintext,\n            nonce,\n            key\n        );\n    }\n\n    /**\n     * Shared-key authenticated decryption\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n        await this.ensureLoaded();\n        if (key.isEd25519Key() || key.isX25519Key()) {\n            throw new TypeError('Argument 3 must not be an asymmetric key');\n        }\n        ciphertext = await Util.toBuffer(ciphertext);\n        if (ciphertext.length < 16) {\n            throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return await this.backend.crypto_secretbox_open(\n            ciphertext,\n            nonce,\n            key\n        );\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretbox_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SECRETBOX_KEYBYTES)\n        );\n    }\n\n    /**\n     * Internalize the internal state and a random header for stream encryption.\n     *\n     * @param {CryptographyKey} key\n     * @return {Promise<array>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Key must be an instance of CryptographyKey');\n        }\n        if (key.getLength() !== 32) {\n            throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n        }\n        const [state, header] = await this.backend.crypto_secretstream_xchacha20poly1305_init_push(key);\n        return Object.freeze({\n            header: header,\n            push: this.crypto_secretstream_xchacha20poly1305_push.bind(this, state),\n            rekey: this.crypto_secretstream_xchacha20poly1305_rekey.bind(this, state)\n        });\n    }\n\n    /**\n     * Initialize the internal state for stream decryption.\n     *\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_pull(key, header) {\n        await this.ensureLoaded();\n        header = await Util.toBuffer(header);\n        if (header.length !== 24) {\n            throw new SodiumError('crypto_secretstream headers must be 24 bytes long');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Key must be an instance of CryptographyKey');\n        }\n        if (key.getLength() !== 32) {\n            throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n        }\n        const state = await this.backend.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n        return Object.freeze({\n            pull: this.crypto_secretstream_xchacha20poly1305_pull.bind(this, state)\n        });\n    }\n\n    /**\n     * Stream encryption.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_push(state, message, ad = '', tag = 0) {\n        await this.ensureLoaded();\n        return this.backend.crypto_secretstream_xchacha20poly1305_push(state, message, ad, tag);\n    }\n\n    /**\n     * Stream decryption.\n     *\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad = '', tag = 0) {\n        await this.ensureLoaded();\n        return this.backend.crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad, tag);\n    }\n\n    /**\n     * Deterministic rekeying.\n     *\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n        await this.ensureLoaded();\n        await this.backend.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretstream_xchacha20poly1305_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES)\n        );\n    }\n\n    /**\n     * Calculate a fast hash for short inputs.\n     *\n     * Algorithm: SipHash-2-4\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_shorthash(message, key) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_shorthash(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_shorthash_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SHORTHASH_KEYBYTES)\n        );\n    }\n\n    /**\n     * Returns a signed message.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign(message, secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof Ed25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n        }\n        return this.backend.crypto_sign(message, secretKey);\n    }\n\n    /**\n     * Given a signed message, verify the Ed25519 signature. If it matches, return the\n     * bare message (no signature).\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_open(message, publicKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof Ed25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n        }\n        return this.backend.crypto_sign_open(message, publicKey);\n    }\n\n    /**\n     * Returns the Ed25519 signature of the message, for the given secret key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_detached(message, secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof Ed25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n        }\n        return this.backend.crypto_sign_detached(message, secretKey);\n    }\n\n    /**\n     * Returns true if the Ed25519 signature is valid for a given message and public key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<boolean>}\n     */\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof Ed25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n        }\n        return this.backend.crypto_sign_verify_detached(message, publicKey, signature);\n    }\n\n    /**\n     * Extract the secret key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519SecretKey>}\n     */\n    async crypto_sign_secretkey(keypair) {\n        if (keypair.getLength() !== 96) {\n            throw new SodiumError('Keypair must be 96 bytes');\n        }\n        return new Ed25519SecretKey(\n            await Util.toBuffer(\n                keypair.getBuffer().slice(0, 64)\n            )\n        );\n    }\n\n    /**\n     * Extract the public key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519PublicKey>}\n     */\n    async crypto_sign_publickey(keypair) {\n        if (keypair.getLength() !== 96) {\n            throw new SodiumError('Keypair must be 96 bytes');\n        }\n        return new Ed25519PublicKey(\n            keypair.getBuffer().slice(64, 96)\n        );\n    }\n\n    /**\n     * Generate an Ed25519 keypair object.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_keypair() {\n        await this.ensureLoaded();\n        return this.backend.crypto_sign_keypair();\n    }\n\n    /**\n     * Generate an Ed25519 keypair object from a seed.\n     *\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_seed_keypair(seed) {\n        await this.ensureLoaded();\n        if (seed instanceof CryptographyKey) {\n            seed = seed.getBuffer();\n        }\n        seed = await Util.toBuffer(seed);\n        if (seed.length !== 32) {\n            throw new SodiumError(`Seed must be 32 bytes long; got ${seed.length}`);\n        }\n        return this.backend.crypto_sign_seed_keypair(seed);\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 secret key,\n     * given an Ed25519 secret key.\n     *\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n        await this.ensureLoaded();\n        return new X25519SecretKey(\n            await this.backend.crypto_sign_ed25519_sk_to_curve25519(sk)\n        );\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 public key,\n     * given an Ed25519 public key.\n     *\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n        await this.ensureLoaded();\n        return new X25519PublicKey(\n            await this.backend.crypto_sign_ed25519_pk_to_curve25519(pk)\n        );\n    }\n\n    /**\n     * Generate an arbitrary number of pseudorandom bytes from a given\n     * nonce and key.\n     *\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream(length, nonce, key) {\n        await this.ensureLoaded();\n        return this.backend.crypto_stream(length, nonce, key);\n    }\n\n    /**\n     * Encrypts a string (without authentication).\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream_xor(plaintext, nonce, key) {\n        await this.ensureLoaded();\n        return this.backend.crypto_stream_xor(plaintext, nonce, key);\n    }\n    /**\n     * Generate a key for stream ciphers.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_stream_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_STREAM_KEYBYTES)\n        );\n    }\n\n    /**\n     * Returns a buffer filled with random bytes.\n     *\n     * @param {number} num\n     * @return {Promise<Buffer>}\n     */\n    async randombytes_buf(num) {\n        await this.ensureLoaded();\n        return await this.backend.randombytes_buf(num);\n    }\n\n    /**\n     * Generate an integer between 0 and upperBound (non-inclusive).\n     *\n     * For example, randombytes_uniform(10) returns an integer between 0 and 9.\n     *\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    async randombytes_uniform(upperBound) {\n        await this.ensureLoaded();\n        return this.backend.randombytes_uniform(upperBound);\n    }\n\n    /**\n     * Add two buffers (little-endian). Returns the value.\n     *\n     * @param {Buffer} val\n     * @param {Buffer} addv\n     * @return {Promise<Buffer>}\n     */\n    async sodium_add(val, addv) {\n        await this.ensureLoaded();\n        return await this.backend.sodium_add(\n            await Util.toBuffer(val),\n            await Util.toBuffer(addv)\n        );\n    }\n\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer} decoded\n     * @return {Promise<Buffer>}\n     */\n    async sodium_bin2hex(decoded) {\n        await this.ensureLoaded();\n        return this.backend.sodium_bin2hex(decoded);\n    }\n\n    /**\n     * Compare two buffers in constant time.\n     *\n     * Returns -1 if b1 is less than b2.\n     * Returns  1 if b1 is greater than b2.\n     * Returns  0 if b1 is equal to b2.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    async sodium_compare(b1, b2) {\n        await this.ensureLoaded();\n        return this.backend.sodium_compare(b1, b2);\n    }\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer|string} encoded\n     * @return {Promise<string>}\n     */\n    async sodium_hex2bin(encoded) {\n        await this.ensureLoaded();\n        return this.backend.sodium_hex2bin(encoded);\n    }\n\n    /**\n     * Increment a buffer (little endian). Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    async sodium_increment(buf) {\n        await this.ensureLoaded();\n        return this.backend.sodium_increment(buf);\n    }\n\n    /**\n     * Returns true if the buffer is zero.\n     *\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    async sodium_is_zero(buf, len) {\n        await this.ensureLoaded();\n        return this.backend.sodium_is_zero(buf, len);\n    }\n\n    /**\n     * Timing-safe buffer comparison.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    async sodium_memcmp(b1, b2) {\n        await this.ensureLoaded();\n        return this.backend.sodium_memcmp(b1, b2);\n    }\n\n    /**\n     * Zero out a buffer. Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    async sodium_memzero(buf) {\n        await this.ensureLoaded();\n        await this.backend.sodium_memzero(buf);\n    }\n\n    /**\n     * Pad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_pad(buf, blockSize) {\n        await this.ensureLoaded();\n        return this.backend.sodium_pad(buf, blockSize);\n    }\n\n    /**\n     * Unpad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_unpad(buf, blockSize) {\n        await this.ensureLoaded();\n        return this.backend.sodium_unpad(buf, blockSize);\n    }\n}\n\nmodule.exports = SodiumPlus;\n"]},"sourceType":"module","hash":"1b1ae02fc2cfdb9550c5aff06aa7ee5cbd45c484"}
