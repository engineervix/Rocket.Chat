{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/app/meteor-autocomplete/client/autocomplete-client.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"app/meteor-autocomplete/client/autocomplete-client.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/app/meteor-autocomplete/client/autocomplete-client.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/app/meteor-autocomplete/client/autocomplete-client.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/meteor-autocomplete/client/autocomplete-client.js"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nmodule.export({\n  default: () => AutoComplete\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Match;\nmodule.link(\"meteor/check\", {\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Blaze;\nmodule.link(\"meteor/blaze\", {\n  Blaze(v) {\n    Blaze = v;\n  }\n\n}, 2);\nlet Deps;\nmodule.link(\"meteor/deps\", {\n  Deps(v) {\n    Deps = v;\n  }\n\n}, 3);\n\nlet _;\n\nmodule.link(\"underscore\", {\n  default(v) {\n    _ = v;\n  }\n\n}, 4);\nlet getCaretCoordinates;\nmodule.link(\"meteor/dandv:caret-position\", {\n  getCaretCoordinates(v) {\n    getCaretCoordinates = v;\n  }\n\n}, 5);\nlet AutoCompleteRecords;\nmodule.link(\"./collection\", {\n  default(v) {\n    AutoCompleteRecords = v;\n  }\n\n}, 6);\nlet APIClient;\nmodule.link(\"../../utils/client\", {\n  APIClient(v) {\n    APIClient = v;\n  }\n\n}, 7);\n\nconst isServerSearch = function (rule) {\n  return _.isString(rule.collection);\n};\n\nconst validateRule = function (rule) {\n  if (rule.subscription != null && !Match.test(rule.collection, String)) {\n    throw new Error('Collection name must be specified as string for server-side search');\n  } // XXX back-compat message, to be removed\n\n\n  if (rule.callback) {\n    console.warn('autocomplete no longer supports callbacks; use event listeners instead.');\n  }\n};\n\nconst isWholeField = function (rule) {\n  // either '' or null both count as whole field.\n  return !rule.token;\n};\n\nconst getRegExp = function (rule) {\n  if (!isWholeField(rule)) {\n    // Expressions for the range from the last word break to the current cursor position\n    return new RegExp(\"(^|\\\\b|\\\\s)\".concat(rule.token, \"([\\\\w.]*)$\"));\n  } // Whole-field behavior - word characters or spaces\n\n\n  return new RegExp('(^)(.*)$');\n};\n\nconst getFindParams = function (rule, filter, limit) {\n  // This is a different 'filter' - the selector from the settings\n  // We need to extend so that we don't copy over rule.filter\n  const selector = _.extend({}, rule.filter || {});\n\n  const options = {\n    limit\n  };\n\n  if (!filter) {\n    // Match anything, no sort, limit X\n    return [selector, options];\n  }\n\n  if (rule.sort && rule.field) {\n    const sortspec = {}; // Only sort if there is a filter, for faster performance on a match of anything\n\n    sortspec[rule.field] = 1;\n    options.sort = sortspec;\n  }\n\n  if (_.isFunction(rule.selector)) {\n    // Custom selector\n    _.extend(selector, rule.selector(filter));\n  } else {\n    selector[rule.field] = {\n      $regex: rule.matchAll ? filter : \"^\".concat(filter),\n      // default is case insensitive search - empty string is not the same as undefined!\n      $options: typeof rule.options === 'undefined' ? 'i' : rule.options\n    };\n  }\n\n  return [selector, options];\n};\n\nconst getField = function (obj, str) {\n  const string = str.split('.');\n  string.forEach(key => {\n    obj = obj[key];\n  });\n  return obj;\n};\n\nclass AutoComplete {\n  constructor(settings) {\n    this.KEYS = [40, 38, 13, 27, 9];\n    this.limit = settings.limit || 5;\n    this.position = settings.position || 'bottom';\n    this.rules = settings.rules;\n    this.selector = _objectSpread({\n      container: '.-autocomplete-container',\n      item: '.-autocomplete-item'\n    }, settings.selector);\n    const {\n      rules\n    } = this;\n    Object.keys(rules).forEach(key => {\n      const rule = rules[key];\n      validateRule(rule);\n    });\n    this.onSelect = settings.onSelect;\n\n    this.expressions = (() => Object.keys(rules).map(key => {\n      const rule = rules[key];\n      return getRegExp(rule);\n    }))();\n\n    this.matched = -1;\n    this.loaded = true; // Reactive dependencies for current matching rule and filter\n\n    this.ruleDep = new Deps.Dependency();\n    this.filterDep = new Deps.Dependency();\n    this.loadingDep = new Deps.Dependency(); // Autosubscribe to the record set published by the server based on the filter\n    // This will tear down server subscriptions when they are no longer being used.\n\n    this.sub = null;\n    this.comp = Deps.autorun(async () => {\n      const rule = this.matchedRule();\n      const filter = this.getFilter();\n\n      if (this.sub) {\n        // Stop any existing sub immediately, don't wait\n        this.sub.stop();\n      }\n\n      if (!(rule && filter)) {\n        return;\n      } // subscribe only for server-side collections\n\n\n      if (!isServerSearch(rule)) {\n        this.setLoaded(true);\n        return;\n      }\n\n      const [selector] = getFindParams(rule, filter, this.limit); // console.debug 'Subscribing to <%s> in <%s>.<%s>', filter, rule.collection, rule.field\n\n      this.setLoaded(false);\n      const endpointName = rule.endpoint || 'users.autocomplete';\n      const {\n        items\n      } = await APIClient.v1.get(\"\".concat(endpointName, \"?selector=\").concat(JSON.stringify(selector)));\n      AutoCompleteRecords.remove({});\n      items.forEach(item => AutoCompleteRecords.insert(item));\n      this.setLoaded(true);\n    });\n  }\n\n  teardown() {\n    // Stop the reactive computation we started for this autocomplete instance\n    this.comp.stop();\n  }\n\n  matchedRule() {\n    // reactive getters and setters for @filter and the currently matched rule\n    this.ruleDep.depend();\n\n    if (this.matched >= 0) {\n      return this.rules[this.matched];\n    }\n\n    return null;\n  }\n\n  setMatchedRule(i) {\n    this.matched = i;\n    this.ruleDep.changed();\n  }\n\n  getFilter() {\n    this.filterDep.depend();\n    return this.filter;\n  }\n\n  setFilter(x) {\n    this.filter = x;\n    this.filterDep.changed();\n    return this.filter;\n  }\n\n  isLoaded() {\n    this.loadingDep.depend();\n    return this.loaded;\n  }\n\n  setLoaded(val) {\n    if (val === this.loaded) {\n      return; // Don't cause redraws unnecessarily\n    }\n\n    this.loaded = val;\n    this.loadingDep.changed();\n  }\n\n  onKeyUp() {\n    if (!this.$element) {\n      return; // Don't try to do this while loading\n    }\n\n    if (this._timeoutHandler) {\n      clearTimeout(this._timeoutHandler);\n    }\n\n    this._timeoutHandler = setTimeout(() => {\n      this._timeoutHandler = 0;\n      const startpos = this.element.selectionStart;\n      const val = this.getText().substring(0, startpos);\n      /*\n      \tMatching on multiple expressions.\n      \tWe always go from a matched state to an unmatched one\n      \tbefore going to a different matched one.\n       */\n\n      let i = 0;\n      let breakLoop = false;\n\n      while (i < this.expressions.length) {\n        const matches = val.match(this.expressions[i]); // matching -> not matching\n\n        if (!matches && this.matched === i) {\n          this.setMatchedRule(-1);\n          breakLoop = true;\n        } // not matching -> matching\n\n\n        if (matches && this.matched === -1) {\n          this.setMatchedRule(i);\n          breakLoop = true;\n        } // Did filter change?\n\n\n        if (matches && this.filter !== matches[2]) {\n          this.setFilter(matches[2]);\n          breakLoop = true;\n        }\n\n        if (breakLoop) {\n          break;\n        }\n\n        i++;\n      }\n    }, 300);\n  }\n\n  onKeyDown(e) {\n    if (this.matched === -1 || this.KEYS.indexOf(e.keyCode) < 0) {\n      return;\n    }\n\n    switch (e.keyCode) {\n      case 9: // TAB\n\n      case 13:\n        // ENTER\n        if (this.select()) {\n          // Don't jump fields or submit if select successful\n          e.preventDefault();\n          e.stopPropagation();\n        }\n\n        break;\n      // preventDefault needed below to avoid moving cursor when selecting\n\n      case 40:\n        // DOWN\n        e.preventDefault();\n        this.next();\n        break;\n\n      case 38:\n        // UP\n        e.preventDefault();\n        this.prev();\n        break;\n\n      case 27:\n        // ESCAPE\n        this.$element.blur();\n        this.hideList();\n    }\n  }\n\n  onFocus() {\n    // We need to run onKeyUp after the focus resolves,\n    // or the caret position (selectionStart) will not be correct\n    Meteor.defer(() => this.onKeyUp());\n  }\n\n  onBlur() {\n    // We need to delay this so click events work\n    // TODO this is a bit of a hack, see if we can't be smarter\n    Meteor.setTimeout(() => {\n      this.hideList();\n    }, 500);\n  }\n\n  onItemClick(doc) {\n    this.processSelection(doc, this.rules[this.matched]);\n  }\n\n  onItemHover(doc, e) {\n    this.tmplInst.$(this.selector.item).removeClass('selected');\n    $(e.target).closest(this.selector.item).addClass('selected');\n  }\n\n  filteredList() {\n    // @ruleDep.depend() # optional as long as we use depend on filter, because list will always get re-rendered\n    const filter = this.getFilter(); // Reactively depend on the filter\n\n    if (this.matched === -1) {\n      return null;\n    }\n\n    const rule = this.rules[this.matched]; // Don't display list unless we have a token or a filter (or both)\n    // Single field: nothing displayed until something is typed\n\n    if (!(rule.token || filter)) {\n      return null;\n    }\n\n    const params = getFindParams(rule, filter, this.limit);\n    const selector = params[0];\n    const options = params[1];\n    Meteor.defer(() => this.ensureSelection()); // if server collection, the server has already done the filtering work\n\n    if (isServerSearch(rule)) {\n      return AutoCompleteRecords.find({}, options);\n    } // Otherwise, search on client\n\n\n    return rule.collection.find(selector, options);\n  }\n\n  isShowing() {\n    const rule = this.matchedRule(); // Same rules as above\n\n    const showing = rule && (rule.token || this.getFilter()); // Do this after the render\n\n    if (showing) {\n      Meteor.defer(() => {\n        this.positionContainer();\n        this.ensureSelection();\n      });\n    }\n\n    return showing;\n  } // Replace text with currently selected item\n\n\n  select() {\n    const node = this.tmplInst.find(\"\".concat(this.selector.item, \".selected\"));\n\n    if (node == null) {\n      return false;\n    }\n\n    const doc = Blaze.getData(node);\n\n    if (!doc) {\n      return false; // Don't select if nothing matched\n    }\n\n    this.processSelection(doc, this.rules[this.matched]);\n    return true;\n  }\n\n  processSelection(doc, rule) {\n    const replacement = getField(doc, rule.field);\n\n    if (!isWholeField(rule)) {\n      this.replace(replacement, rule);\n      this.hideList();\n    } else {\n      // Empty string or doesn't exist?\n      // Single-field replacement: replace whole field\n      this.setText(replacement); // Field retains focus, but list is hidden unless another key is pressed\n      // Must be deferred or onKeyUp will trigger and match again\n      // TODO this is a hack; see above\n\n      this.onBlur();\n    }\n\n    this.onSelect && this.onSelect(doc);\n    this.$element.trigger('autocompleteselect', doc);\n  } // Replace the appropriate region\n\n\n  replace(replacement) {\n    const startpos = this.element.selectionStart;\n    const fullStuff = this.getText();\n    let val = fullStuff.substring(0, startpos);\n    val = val.replace(this.expressions[this.matched], \"$1\".concat(this.rules[this.matched].token).concat(replacement));\n    const posfix = fullStuff.substring(startpos, fullStuff.length);\n    const separator = posfix.match(/^\\s/) ? '' : ' ';\n    const finalFight = val + separator + posfix;\n    this.setText(finalFight);\n    const newPosition = val.length + 1;\n    this.element.setSelectionRange(newPosition, newPosition);\n  }\n\n  hideList() {\n    this.setMatchedRule(-1);\n    this.setFilter(null);\n  }\n\n  getText() {\n    return this.$element.val() || this.$element.text();\n  }\n\n  setText(text) {\n    if (this.$element.is('input,textarea')) {\n      return this.$element.val(text);\n    }\n\n    this.$element.html(text);\n  }\n  /*\n  \tRendering functions\n   */\n\n\n  positionContainer() {\n    // First render; Pick the first item and set css whenever list gets shown\n    let pos = {};\n    const element = this.selector.anchor ? this.tmplInst.$(this.selector.anchor) : this.$element;\n\n    if (this.position === 'fixed') {\n      const width = element.outerWidth();\n      return this.tmplInst.$(this.selector.container).css({\n        width,\n        position: 'fixed'\n      });\n    }\n\n    const position = element.position();\n\n    if (!position) {\n      return;\n    }\n\n    const rule = this.matchedRule();\n    const offset = getCaretCoordinates(this.element, this.element.selectionStart); // In whole-field positioning, we don't move the container and make it the\n    // full width of the field.\n\n    if (rule && isWholeField(rule)) {\n      pos.left = position.left;\n\n      if (rule.doNotChangeWidth !== false) {\n        pos.width = element.outerWidth(); // position.offsetWidth\n      }\n    } else {\n      // Normal positioning, at token word\n      pos = {\n        left: position.left + offset.left\n      };\n    } // Position menu from top (above) or from bottom of caret (below, default)\n\n\n    if (this.position === 'top') {\n      pos.bottom = element.offsetParent().height() - position.top - offset.top;\n    } else {\n      pos.top = position.top + offset.top + parseInt(element.css('font-size'));\n    }\n\n    this.tmplInst.$(this.selector.container).css(_objectSpread(_objectSpread({}, pos), {}, {\n      position: 'absolute'\n    }));\n  }\n\n  ensureSelection() {\n    // Re-render; make sure selected item is something in the list or none if list empty\n    const selectedItem = this.tmplInst.$(\"\".concat(this.selector.item, \".selected\"));\n\n    if (!selectedItem.length) {\n      // Select anything\n      this.tmplInst.$(\"\".concat(this.selector.item, \":first-child\")).addClass('selected');\n    }\n  } // Select next item in list\n\n\n  next() {\n    const currentItem = this.tmplInst.$(\"\".concat(this.selector.item, \".selected\"));\n\n    if (!currentItem.length) {\n      return this.tmplInst.$(\"\".concat(this.selector.item, \":first-child\")).addClass('selected');\n    }\n\n    currentItem.removeClass('selected');\n    const next = currentItem.next();\n\n    if (next.length) {\n      next.addClass('selected');\n    } else {\n      // End of list or lost selection; Go back to first item\n      this.tmplInst.$(\"\".concat(this.selector.item, \":first-child\")).addClass('selected');\n    }\n  } // Select previous item in list\n\n\n  prev() {\n    const currentItem = this.tmplInst.$(\"\".concat(this.selector.item, \".selected\"));\n\n    if (!currentItem.length) {\n      return; // Don't try to iterate an empty list\n    }\n\n    currentItem.removeClass('selected');\n    const prev = currentItem.prev();\n\n    if (prev.length) {\n      prev.addClass('selected');\n    } else {\n      // Beginning of list or lost selection; Go to end of list\n      this.tmplInst.$(\"\".concat(this.selector.item, \":last-child\")).addClass('selected');\n    }\n  } // This doesn't need to be reactive because list already changes reactively\n  // and will cause all of the items to re-render anyway\n\n\n  currentTemplate() {\n    return this.rules[this.matched].template;\n  }\n\n}","map":{"version":3,"sources":["app/meteor-autocomplete/client/autocomplete-client.js"],"names":["_objectSpread","module","link","default","v","export","AutoComplete","Meteor","Match","Blaze","Deps","_","getCaretCoordinates","AutoCompleteRecords","APIClient","isServerSearch","rule","isString","collection","validateRule","subscription","test","String","Error","callback","console","warn","isWholeField","token","getRegExp","RegExp","getFindParams","filter","limit","selector","extend","options","sort","field","sortspec","isFunction","$regex","matchAll","$options","getField","obj","str","string","split","forEach","key","constructor","settings","KEYS","position","rules","container","item","Object","keys","onSelect","expressions","map","matched","loaded","ruleDep","Dependency","filterDep","loadingDep","sub","comp","autorun","matchedRule","getFilter","stop","setLoaded","endpointName","endpoint","items","v1","get","JSON","stringify","remove","insert","teardown","depend","setMatchedRule","i","changed","setFilter","x","isLoaded","val","onKeyUp","$element","_timeoutHandler","clearTimeout","setTimeout","startpos","element","selectionStart","getText","substring","breakLoop","length","matches","match","onKeyDown","e","indexOf","keyCode","select","preventDefault","stopPropagation","next","prev","blur","hideList","onFocus","defer","onBlur","onItemClick","doc","processSelection","onItemHover","tmplInst","$","removeClass","target","closest","addClass","filteredList","params","ensureSelection","find","isShowing","showing","positionContainer","node","getData","replacement","replace","setText","trigger","fullStuff","posfix","separator","finalFight","newPosition","setSelectionRange","text","is","html","pos","anchor","width","outerWidth","css","offset","left","doNotChangeWidth","bottom","offsetParent","height","top","parseInt","selectedItem","currentItem","currentTemplate","template"],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Match } from 'meteor/check';\nimport { Blaze } from 'meteor/blaze';\nimport { Deps } from 'meteor/deps';\nimport _ from 'underscore';\nimport { getCaretCoordinates } from 'meteor/dandv:caret-position';\n\nimport AutoCompleteRecords from './collection';\nimport { APIClient } from '../../utils/client';\n\nconst isServerSearch = function (rule) {\n\treturn _.isString(rule.collection);\n};\n\nconst validateRule = function (rule) {\n\tif (rule.subscription != null && !Match.test(rule.collection, String)) {\n\t\tthrow new Error('Collection name must be specified as string for server-side search');\n\t}\n\t// XXX back-compat message, to be removed\n\tif (rule.callback) {\n\t\tconsole.warn('autocomplete no longer supports callbacks; use event listeners instead.');\n\t}\n};\n\nconst isWholeField = function (rule) {\n\t// either '' or null both count as whole field.\n\treturn !rule.token;\n};\n\nconst getRegExp = function (rule) {\n\tif (!isWholeField(rule)) {\n\t\t// Expressions for the range from the last word break to the current cursor position\n\t\treturn new RegExp(`(^|\\\\b|\\\\s)${rule.token}([\\\\w.]*)$`);\n\t}\n\t// Whole-field behavior - word characters or spaces\n\treturn new RegExp('(^)(.*)$');\n};\n\nconst getFindParams = function (rule, filter, limit) {\n\t// This is a different 'filter' - the selector from the settings\n\t// We need to extend so that we don't copy over rule.filter\n\tconst selector = _.extend({}, rule.filter || {});\n\tconst options = {\n\t\tlimit,\n\t};\n\tif (!filter) {\n\t\t// Match anything, no sort, limit X\n\t\treturn [selector, options];\n\t}\n\tif (rule.sort && rule.field) {\n\t\tconst sortspec = {};\n\t\t// Only sort if there is a filter, for faster performance on a match of anything\n\t\tsortspec[rule.field] = 1;\n\t\toptions.sort = sortspec;\n\t}\n\tif (_.isFunction(rule.selector)) {\n\t\t// Custom selector\n\t\t_.extend(selector, rule.selector(filter));\n\t} else {\n\t\tselector[rule.field] = {\n\t\t\t$regex: rule.matchAll ? filter : `^${filter}`,\n\t\t\t// default is case insensitive search - empty string is not the same as undefined!\n\t\t\t$options: typeof rule.options === 'undefined' ? 'i' : rule.options,\n\t\t};\n\t}\n\treturn [selector, options];\n};\n\nconst getField = function (obj, str) {\n\tconst string = str.split('.');\n\tstring.forEach((key) => {\n\t\tobj = obj[key];\n\t});\n\treturn obj;\n};\n\nexport default class AutoComplete {\n\tconstructor(settings) {\n\t\tthis.KEYS = [40, 38, 13, 27, 9];\n\t\tthis.limit = settings.limit || 5;\n\t\tthis.position = settings.position || 'bottom';\n\t\tthis.rules = settings.rules;\n\t\tthis.selector = {\n\t\t\tcontainer: '.-autocomplete-container',\n\t\t\titem: '.-autocomplete-item',\n\t\t\t...settings.selector,\n\t\t};\n\t\tconst { rules } = this;\n\n\t\tObject.keys(rules).forEach((key) => {\n\t\t\tconst rule = rules[key];\n\t\t\tvalidateRule(rule);\n\t\t});\n\n\t\tthis.onSelect = settings.onSelect;\n\n\t\tthis.expressions = (() =>\n\t\t\tObject.keys(rules).map((key) => {\n\t\t\t\tconst rule = rules[key];\n\t\t\t\treturn getRegExp(rule);\n\t\t\t}))();\n\t\tthis.matched = -1;\n\t\tthis.loaded = true;\n\n\t\t// Reactive dependencies for current matching rule and filter\n\t\tthis.ruleDep = new Deps.Dependency();\n\t\tthis.filterDep = new Deps.Dependency();\n\t\tthis.loadingDep = new Deps.Dependency();\n\n\t\t// Autosubscribe to the record set published by the server based on the filter\n\t\t// This will tear down server subscriptions when they are no longer being used.\n\t\tthis.sub = null;\n\t\tthis.comp = Deps.autorun(async () => {\n\t\t\tconst rule = this.matchedRule();\n\t\t\tconst filter = this.getFilter();\n\t\t\tif (this.sub) {\n\t\t\t\t// Stop any existing sub immediately, don't wait\n\t\t\t\tthis.sub.stop();\n\t\t\t}\n\t\t\tif (!(rule && filter)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// subscribe only for server-side collections\n\t\t\tif (!isServerSearch(rule)) {\n\t\t\t\tthis.setLoaded(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst [selector] = getFindParams(rule, filter, this.limit);\n\n\t\t\t// console.debug 'Subscribing to <%s> in <%s>.<%s>', filter, rule.collection, rule.field\n\t\t\tthis.setLoaded(false);\n\t\t\tconst endpointName = rule.endpoint || 'users.autocomplete';\n\t\t\tconst { items } = await APIClient.v1.get(`${endpointName}?selector=${JSON.stringify(selector)}`);\n\t\t\tAutoCompleteRecords.remove({});\n\t\t\titems.forEach((item) => AutoCompleteRecords.insert(item));\n\t\t\tthis.setLoaded(true);\n\t\t});\n\t}\n\n\tteardown() {\n\t\t// Stop the reactive computation we started for this autocomplete instance\n\t\tthis.comp.stop();\n\t}\n\n\tmatchedRule() {\n\t\t// reactive getters and setters for @filter and the currently matched rule\n\t\tthis.ruleDep.depend();\n\t\tif (this.matched >= 0) {\n\t\t\treturn this.rules[this.matched];\n\t\t}\n\t\treturn null;\n\t}\n\n\tsetMatchedRule(i) {\n\t\tthis.matched = i;\n\t\tthis.ruleDep.changed();\n\t}\n\n\tgetFilter() {\n\t\tthis.filterDep.depend();\n\t\treturn this.filter;\n\t}\n\n\tsetFilter(x) {\n\t\tthis.filter = x;\n\t\tthis.filterDep.changed();\n\t\treturn this.filter;\n\t}\n\n\tisLoaded() {\n\t\tthis.loadingDep.depend();\n\t\treturn this.loaded;\n\t}\n\n\tsetLoaded(val) {\n\t\tif (val === this.loaded) {\n\t\t\treturn; // Don't cause redraws unnecessarily\n\t\t}\n\t\tthis.loaded = val;\n\t\tthis.loadingDep.changed();\n\t}\n\n\tonKeyUp() {\n\t\tif (!this.$element) {\n\t\t\treturn; // Don't try to do this while loading\n\t\t}\n\n\t\tif (this._timeoutHandler) {\n\t\t\tclearTimeout(this._timeoutHandler);\n\t\t}\n\n\t\tthis._timeoutHandler = setTimeout(() => {\n\t\t\tthis._timeoutHandler = 0;\n\n\t\t\tconst startpos = this.element.selectionStart;\n\t\t\tconst val = this.getText().substring(0, startpos);\n\n\t\t\t/*\n\t\t\t\tMatching on multiple expressions.\n\t\t\t\tWe always go from a matched state to an unmatched one\n\t\t\t\tbefore going to a different matched one.\n\t\t\t */\n\t\t\tlet i = 0;\n\t\t\tlet breakLoop = false;\n\t\t\twhile (i < this.expressions.length) {\n\t\t\t\tconst matches = val.match(this.expressions[i]);\n\n\t\t\t\t// matching -> not matching\n\t\t\t\tif (!matches && this.matched === i) {\n\t\t\t\t\tthis.setMatchedRule(-1);\n\t\t\t\t\tbreakLoop = true;\n\t\t\t\t}\n\n\t\t\t\t// not matching -> matching\n\t\t\t\tif (matches && this.matched === -1) {\n\t\t\t\t\tthis.setMatchedRule(i);\n\t\t\t\t\tbreakLoop = true;\n\t\t\t\t}\n\n\t\t\t\t// Did filter change?\n\t\t\t\tif (matches && this.filter !== matches[2]) {\n\t\t\t\t\tthis.setFilter(matches[2]);\n\t\t\t\t\tbreakLoop = true;\n\t\t\t\t}\n\t\t\t\tif (breakLoop) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}, 300);\n\t}\n\n\tonKeyDown(e) {\n\t\tif (this.matched === -1 || this.KEYS.indexOf(e.keyCode) < 0) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (e.keyCode) {\n\t\t\tcase 9: // TAB\n\t\t\tcase 13: // ENTER\n\t\t\t\tif (this.select()) {\n\t\t\t\t\t// Don't jump fields or submit if select successful\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// preventDefault needed below to avoid moving cursor when selecting\n\t\t\tcase 40: // DOWN\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.next();\n\t\t\t\tbreak;\n\t\t\tcase 38: // UP\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.prev();\n\t\t\t\tbreak;\n\t\t\tcase 27: // ESCAPE\n\t\t\t\tthis.$element.blur();\n\t\t\t\tthis.hideList();\n\t\t}\n\t}\n\n\tonFocus() {\n\t\t// We need to run onKeyUp after the focus resolves,\n\t\t// or the caret position (selectionStart) will not be correct\n\t\tMeteor.defer(() => this.onKeyUp());\n\t}\n\n\tonBlur() {\n\t\t// We need to delay this so click events work\n\t\t// TODO this is a bit of a hack, see if we can't be smarter\n\t\tMeteor.setTimeout(() => {\n\t\t\tthis.hideList();\n\t\t}, 500);\n\t}\n\n\tonItemClick(doc) {\n\t\tthis.processSelection(doc, this.rules[this.matched]);\n\t}\n\n\tonItemHover(doc, e) {\n\t\tthis.tmplInst.$(this.selector.item).removeClass('selected');\n\t\t$(e.target).closest(this.selector.item).addClass('selected');\n\t}\n\n\tfilteredList() {\n\t\t// @ruleDep.depend() # optional as long as we use depend on filter, because list will always get re-rendered\n\t\tconst filter = this.getFilter(); // Reactively depend on the filter\n\t\tif (this.matched === -1) {\n\t\t\treturn null;\n\t\t}\n\t\tconst rule = this.rules[this.matched];\n\n\t\t// Don't display list unless we have a token or a filter (or both)\n\t\t// Single field: nothing displayed until something is typed\n\t\tif (!(rule.token || filter)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst params = getFindParams(rule, filter, this.limit);\n\t\tconst selector = params[0];\n\t\tconst options = params[1];\n\t\tMeteor.defer(() => this.ensureSelection());\n\n\t\t// if server collection, the server has already done the filtering work\n\t\tif (isServerSearch(rule)) {\n\t\t\treturn AutoCompleteRecords.find({}, options);\n\t\t}\n\t\t// Otherwise, search on client\n\t\treturn rule.collection.find(selector, options);\n\t}\n\n\tisShowing() {\n\t\tconst rule = this.matchedRule();\n\t\t// Same rules as above\n\t\tconst showing = rule && (rule.token || this.getFilter());\n\n\t\t// Do this after the render\n\t\tif (showing) {\n\t\t\tMeteor.defer(() => {\n\t\t\t\tthis.positionContainer();\n\t\t\t\tthis.ensureSelection();\n\t\t\t});\n\t\t}\n\t\treturn showing;\n\t}\n\n\t// Replace text with currently selected item\n\tselect() {\n\t\tconst node = this.tmplInst.find(`${this.selector.item}.selected`);\n\t\tif (node == null) {\n\t\t\treturn false;\n\t\t}\n\t\tconst doc = Blaze.getData(node);\n\t\tif (!doc) {\n\t\t\treturn false; // Don't select if nothing matched\n\t\t}\n\t\tthis.processSelection(doc, this.rules[this.matched]);\n\t\treturn true;\n\t}\n\n\tprocessSelection(doc, rule) {\n\t\tconst replacement = getField(doc, rule.field);\n\t\tif (!isWholeField(rule)) {\n\t\t\tthis.replace(replacement, rule);\n\t\t\tthis.hideList();\n\t\t} else {\n\t\t\t// Empty string or doesn't exist?\n\t\t\t// Single-field replacement: replace whole field\n\t\t\tthis.setText(replacement);\n\n\t\t\t// Field retains focus, but list is hidden unless another key is pressed\n\t\t\t// Must be deferred or onKeyUp will trigger and match again\n\t\t\t// TODO this is a hack; see above\n\t\t\tthis.onBlur();\n\t\t}\n\t\tthis.onSelect && this.onSelect(doc);\n\t\tthis.$element.trigger('autocompleteselect', doc);\n\t}\n\n\t// Replace the appropriate region\n\treplace(replacement) {\n\t\tconst startpos = this.element.selectionStart;\n\t\tconst fullStuff = this.getText();\n\t\tlet val = fullStuff.substring(0, startpos);\n\t\tval = val.replace(this.expressions[this.matched], `$1${this.rules[this.matched].token}${replacement}`);\n\t\tconst posfix = fullStuff.substring(startpos, fullStuff.length);\n\t\tconst separator = posfix.match(/^\\s/) ? '' : ' ';\n\t\tconst finalFight = val + separator + posfix;\n\t\tthis.setText(finalFight);\n\t\tconst newPosition = val.length + 1;\n\t\tthis.element.setSelectionRange(newPosition, newPosition);\n\t}\n\n\thideList() {\n\t\tthis.setMatchedRule(-1);\n\t\tthis.setFilter(null);\n\t}\n\n\tgetText() {\n\t\treturn this.$element.val() || this.$element.text();\n\t}\n\n\tsetText(text) {\n\t\tif (this.$element.is('input,textarea')) {\n\t\t\treturn this.$element.val(text);\n\t\t}\n\t\tthis.$element.html(text);\n\t}\n\n\t/*\n\t\tRendering functions\n\t */\n\n\tpositionContainer() {\n\t\t// First render; Pick the first item and set css whenever list gets shown\n\t\tlet pos = {};\n\t\tconst element = this.selector.anchor ? this.tmplInst.$(this.selector.anchor) : this.$element;\n\n\t\tif (this.position === 'fixed') {\n\t\t\tconst width = element.outerWidth();\n\t\t\treturn this.tmplInst.$(this.selector.container).css({ width, position: 'fixed' });\n\t\t}\n\n\t\tconst position = element.position();\n\t\tif (!position) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst rule = this.matchedRule();\n\t\tconst offset = getCaretCoordinates(this.element, this.element.selectionStart);\n\n\t\t// In whole-field positioning, we don't move the container and make it the\n\t\t// full width of the field.\n\t\tif (rule && isWholeField(rule)) {\n\t\t\tpos.left = position.left;\n\t\t\tif (rule.doNotChangeWidth !== false) {\n\t\t\t\tpos.width = element.outerWidth(); // position.offsetWidth\n\t\t\t}\n\t\t} else {\n\t\t\t// Normal positioning, at token word\n\t\t\tpos = { left: position.left + offset.left };\n\t\t}\n\n\t\t// Position menu from top (above) or from bottom of caret (below, default)\n\t\tif (this.position === 'top') {\n\t\t\tpos.bottom = element.offsetParent().height() - position.top - offset.top;\n\t\t} else {\n\t\t\tpos.top = position.top + offset.top + parseInt(element.css('font-size'));\n\t\t}\n\n\t\tthis.tmplInst.$(this.selector.container).css({ ...pos, position: 'absolute' });\n\t}\n\n\tensureSelection() {\n\t\t// Re-render; make sure selected item is something in the list or none if list empty\n\t\tconst selectedItem = this.tmplInst.$(`${this.selector.item}.selected`);\n\t\tif (!selectedItem.length) {\n\t\t\t// Select anything\n\t\t\tthis.tmplInst.$(`${this.selector.item}:first-child`).addClass('selected');\n\t\t}\n\t}\n\n\t// Select next item in list\n\tnext() {\n\t\tconst currentItem = this.tmplInst.$(`${this.selector.item}.selected`);\n\t\tif (!currentItem.length) {\n\t\t\treturn this.tmplInst.$(`${this.selector.item}:first-child`).addClass('selected');\n\t\t}\n\t\tcurrentItem.removeClass('selected');\n\t\tconst next = currentItem.next();\n\t\tif (next.length) {\n\t\t\tnext.addClass('selected');\n\t\t} else {\n\t\t\t// End of list or lost selection; Go back to first item\n\t\t\tthis.tmplInst.$(`${this.selector.item}:first-child`).addClass('selected');\n\t\t}\n\t}\n\n\t// Select previous item in list\n\tprev() {\n\t\tconst currentItem = this.tmplInst.$(`${this.selector.item}.selected`);\n\t\tif (!currentItem.length) {\n\t\t\treturn; // Don't try to iterate an empty list\n\t\t}\n\t\tcurrentItem.removeClass('selected');\n\t\tconst prev = currentItem.prev();\n\t\tif (prev.length) {\n\t\t\tprev.addClass('selected');\n\t\t} else {\n\t\t\t// Beginning of list or lost selection; Go to end of list\n\t\t\tthis.tmplInst.$(`${this.selector.item}:last-child`).addClass('selected');\n\t\t}\n\t}\n\n\t// This doesn't need to be reactive because list already changes reactively\n\t// and will cause all of the items to re-render anyway\n\tcurrentTemplate() {\n\t\treturn this.rules[this.matched].template;\n\t}\n}\n"]},"sourceType":"module","hash":"81d6620e92ff4ea1ce79bc172ee34e38a112a165"}
