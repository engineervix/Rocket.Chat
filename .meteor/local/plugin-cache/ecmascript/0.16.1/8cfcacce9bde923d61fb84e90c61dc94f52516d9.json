{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/backend/sodiumnative.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"imports/client/sodium-plus/lib/backend/sodiumnative.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/backend/sodiumnative.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/backend/sodiumnative.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/client/sodium-plus/lib/backend/sodiumnative.js"}},"code":"!function (module1) {\n  var _regeneratorRuntime;\n\n  module1.link(\"@babel/runtime/regenerator\", {\n    default: function (v) {\n      _regeneratorRuntime = v;\n    }\n  }, 0);\n\n  var _inheritsLoose;\n\n  module1.link(\"@babel/runtime/helpers/inheritsLoose\", {\n    default: function (v) {\n      _inheritsLoose = v;\n    }\n  }, 1);\n  var loaded = false;\n\n  var _sodium;\n  /* istanbul ignore next */\n\n\n  try {\n    _sodium = require('sodium-native');\n    loaded = true;\n  } catch (e) {\n    _sodium = {};\n  }\n\n  var Backend = require('../backend');\n\n  var CryptographyKey = require('../cryptography-key');\n\n  var SodiumError = require('../sodium-error');\n\n  var Util = require('../util');\n\n  var toBuffer = require('typedarray-to-buffer');\n  /* istanbul ignore if */\n\n\n  if (typeof Buffer === 'undefined') {\n    var _Buffer = require('buffer/').Buffer;\n  }\n  /* istanbul ignore next */\n\n\n  module.exports = /*#__PURE__*/function (_Backend) {\n    _inheritsLoose(SodiumNativeBackend, _Backend);\n\n    function SodiumNativeBackend(lib) {\n      var _this;\n\n      _this = _Backend.call(this, lib) || this;\n      _this.sodium = lib;\n      _this.backendName = 'SodiumNativeBackend';\n      return _this;\n    }\n\n    SodiumNativeBackend.init = function () {\n      function init() {\n        return _regeneratorRuntime.async(function () {\n          function init$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (loaded) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  throw new SodiumError('sodium-native not installed');\n\n                case 2:\n                  return _context.abrupt(\"return\", new SodiumNativeBackend(_sodium));\n\n                case 3:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }\n\n          return init$;\n        }(), null, null, null, Promise);\n      }\n\n      return init;\n    }()\n    /**\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    var _proto = SodiumNativeBackend.prototype;\n\n    _proto.crypto_aead_xchacha20poly1305_ietf_decrypt = function () {\n      function crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, assocData, nonce, key) {\n        var plaintext;\n        return _regeneratorRuntime.async(function () {\n          function crypto_aead_xchacha20poly1305_ietf_decrypt$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  plaintext = Buffer.alloc(ciphertext.length - 16, 0);\n                  _context2.t0 = this.sodium;\n                  _context2.t1 = plaintext;\n                  _context2.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ciphertext));\n\n                case 5:\n                  _context2.t2 = _context2.sent;\n                  _context2.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(assocData));\n\n                case 8:\n                  _context2.t3 = _context2.sent;\n                  _context2.next = 11;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 11:\n                  _context2.t4 = _context2.sent;\n                  _context2.t5 = key.getBuffer();\n\n                  _context2.t0.crypto_aead_xchacha20poly1305_ietf_decrypt.call(_context2.t0, _context2.t1, null, _context2.t2, _context2.t3, _context2.t4, _context2.t5);\n\n                  return _context2.abrupt(\"return\", plaintext);\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }\n\n          return crypto_aead_xchacha20poly1305_ietf_decrypt$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_aead_xchacha20poly1305_ietf_decrypt;\n    }()\n    /**\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_aead_xchacha20poly1305_ietf_encrypt = function () {\n      function crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, assocData, nonce, key) {\n        var ciphertext;\n        return _regeneratorRuntime.async(function () {\n          function crypto_aead_xchacha20poly1305_ietf_encrypt$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  ciphertext = Buffer.alloc(plaintext.length + 16, 0);\n                  _context3.t0 = this.sodium;\n                  _context3.t1 = ciphertext;\n                  _context3.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 5:\n                  _context3.t2 = _context3.sent;\n                  _context3.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(assocData));\n\n                case 8:\n                  _context3.t3 = _context3.sent;\n                  _context3.next = 11;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 11:\n                  _context3.t4 = _context3.sent;\n                  _context3.t5 = key.getBuffer();\n\n                  _context3.t0.crypto_aead_xchacha20poly1305_ietf_encrypt.call(_context3.t0, _context3.t1, _context3.t2, _context3.t3, null, _context3.t4, _context3.t5);\n\n                  return _context3.abrupt(\"return\", ciphertext);\n\n                case 15:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }\n\n          return crypto_aead_xchacha20poly1305_ietf_encrypt$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_aead_xchacha20poly1305_ietf_encrypt;\n    }()\n    /**\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<buffer>}\n     */\n    ;\n\n    _proto.crypto_auth = function () {\n      function crypto_auth(message, key) {\n        var output;\n        return _regeneratorRuntime.async(function () {\n          function crypto_auth$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  output = Buffer.alloc(32);\n                  _context4.t0 = this.sodium;\n                  _context4.t1 = output;\n                  _context4.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 5:\n                  _context4.t2 = _context4.sent;\n                  _context4.t3 = key.getBuffer();\n\n                  _context4.t0.crypto_auth.call(_context4.t0, _context4.t1, _context4.t2, _context4.t3);\n\n                  return _context4.abrupt(\"return\", toBuffer(output));\n\n                case 9:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }\n\n          return crypto_auth$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_auth;\n    }()\n    /**\n     * @param {Buffer} mac\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_auth_verify = function () {\n      function crypto_auth_verify(mac, message, key) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_auth_verify$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.t0 = this.sodium;\n                  _context5.t1 = mac;\n                  _context5.next = 4;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 4:\n                  _context5.t2 = _context5.sent;\n                  _context5.t3 = key.getBuffer();\n                  return _context5.abrupt(\"return\", _context5.t0.crypto_auth_verify.call(_context5.t0, _context5.t1, _context5.t2, _context5.t3));\n\n                case 7:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }\n\n          return crypto_auth_verify$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_auth_verify;\n    }()\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n    ;\n\n    _proto.crypto_box = function () {\n      function crypto_box(plaintext, nonce, sk, pk) {\n        var ciphertext;\n        return _regeneratorRuntime.async(function () {\n          function crypto_box$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  ciphertext = Buffer.alloc(plaintext.length + 16);\n                  _context6.t0 = this.sodium;\n                  _context6.t1 = ciphertext;\n                  _context6.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 5:\n                  _context6.t2 = _context6.sent;\n                  _context6.t3 = nonce;\n                  _context6.t4 = pk.getBuffer();\n                  _context6.t5 = sk.getBuffer();\n\n                  _context6.t0.crypto_box_easy.call(_context6.t0, _context6.t1, _context6.t2, _context6.t3, _context6.t4, _context6.t5);\n\n                  return _context6.abrupt(\"return\", Util.toBuffer(ciphertext));\n\n                case 11:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }\n\n          return crypto_box$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box;\n    }()\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_box_open = function () {\n      function crypto_box_open(ciphertext, nonce, sk, pk) {\n        var plaintext, success;\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_open$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  plaintext = Buffer.alloc(ciphertext.length - 16);\n                  success = this.sodium.crypto_box_open_easy(plaintext, ciphertext, nonce, pk.getBuffer(), sk.getBuffer());\n\n                  if (success) {\n                    _context7.next = 4;\n                    break;\n                  }\n\n                  throw new SodiumError('Decryption failed');\n\n                case 4:\n                  return _context7.abrupt(\"return\", Util.toBuffer(plaintext));\n\n                case 5:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }\n\n          return crypto_box_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_open;\n    }()\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n    ;\n\n    _proto.crypto_box_seal = function () {\n      function crypto_box_seal(plaintext, pk) {\n        var ciphertext;\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_seal$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  ciphertext = Buffer.alloc(plaintext.length + 48);\n                  _context8.t0 = this.sodium;\n                  _context8.t1 = ciphertext;\n                  _context8.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 5:\n                  _context8.t2 = _context8.sent;\n                  _context8.t3 = pk.getBuffer();\n\n                  _context8.t0.crypto_box_seal.call(_context8.t0, _context8.t1, _context8.t2, _context8.t3);\n\n                  return _context8.abrupt(\"return\", Util.toBuffer(ciphertext));\n\n                case 9:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }\n\n          return crypto_box_seal$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_seal;\n    }()\n    /**\n     * @param {Buffer} ciphertext\n     * @param {CryptographyKey} pk\n     * @param {CryptographyKey} sk\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_box_seal_open = function () {\n      function crypto_box_seal_open(ciphertext, pk, sk) {\n        var plaintext, success;\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_seal_open$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  plaintext = Buffer.alloc(ciphertext.length - 48);\n                  _context9.t0 = this.sodium;\n                  _context9.t1 = plaintext;\n                  _context9.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ciphertext));\n\n                case 5:\n                  _context9.t2 = _context9.sent;\n                  _context9.t3 = pk.getBuffer();\n                  _context9.t4 = sk.getBuffer();\n                  success = _context9.t0.crypto_box_seal_open.call(_context9.t0, _context9.t1, _context9.t2, _context9.t3, _context9.t4);\n\n                  if (success) {\n                    _context9.next = 11;\n                    break;\n                  }\n\n                  throw new SodiumError('Decryption failed');\n\n                case 11:\n                  return _context9.abrupt(\"return\", Util.toBuffer(plaintext));\n\n                case 12:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }\n\n          return crypto_box_seal_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_seal_open;\n    }()\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_box_keypair = function () {\n      function crypto_box_keypair() {\n        var sK, pK;\n        return _regeneratorRuntime.async(function () {\n          function crypto_box_keypair$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  sK = Buffer.alloc(32, 0);\n                  pK = Buffer.alloc(32, 0);\n                  this.sodium.crypto_box_keypair(sK, pK);\n                  return _context10.abrupt(\"return\", new CryptographyKey(Buffer.concat([pK, sK])));\n\n                case 4:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }\n\n          return crypto_box_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_box_keypair;\n    }()\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_generichash = function () {\n      function crypto_generichash(message) {\n        var key,\n            outputLength,\n            hash,\n            _args11 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  key = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : null;\n                  outputLength = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : 32;\n                  hash = Buffer.alloc(outputLength);\n\n                  if (!key) {\n                    _context11.next = 13;\n                    break;\n                  }\n\n                  _context11.t0 = this.sodium;\n                  _context11.t1 = hash;\n                  _context11.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 8:\n                  _context11.t2 = _context11.sent;\n                  _context11.t3 = key.getBuffer();\n\n                  _context11.t0.crypto_generichash.call(_context11.t0, _context11.t1, _context11.t2, _context11.t3);\n\n                  _context11.next = 19;\n                  break;\n\n                case 13:\n                  _context11.t4 = this.sodium;\n                  _context11.t5 = hash;\n                  _context11.next = 17;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 17:\n                  _context11.t6 = _context11.sent;\n\n                  _context11.t4.crypto_generichash.call(_context11.t4, _context11.t5, _context11.t6);\n\n                case 19:\n                  return _context11.abrupt(\"return\", hash);\n\n                case 20:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }\n\n          return crypto_generichash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash;\n    }()\n    /**\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_generichash_init = function () {\n      function crypto_generichash_init() {\n        var key,\n            outputLength,\n            state,\n            _args12 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_init$(_context12) {\n            while (1) {\n              switch (_context12.prev = _context12.next) {\n                case 0:\n                  key = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : null;\n                  outputLength = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 32;\n                  state = Buffer.alloc(this.CRYPTO_GENERICHASH_STATEBYTES);\n\n                  if (key) {\n                    this.sodium.crypto_generichash_init(state, key.getBuffer(), outputLength);\n                  } else {\n                    this.sodium.crypto_generichash_init(state, null, outputLength);\n                  }\n\n                  return _context12.abrupt(\"return\", state);\n\n                case 5:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_init$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_init;\n    }()\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    ;\n\n    _proto.crypto_generichash_update = function () {\n      function crypto_generichash_update(state, message) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_update$(_context13) {\n            while (1) {\n              switch (_context13.prev = _context13.next) {\n                case 0:\n                  _context13.t0 = this.sodium;\n                  _context13.t1 = state;\n                  _context13.next = 4;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 4:\n                  _context13.t2 = _context13.sent;\n\n                  _context13.t0.crypto_generichash_update.call(_context13.t0, _context13.t1, _context13.t2);\n\n                  return _context13.abrupt(\"return\", state);\n\n                case 7:\n                case \"end\":\n                  return _context13.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_update$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_update;\n    }()\n    /**\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_generichash_final = function () {\n      function crypto_generichash_final(state) {\n        var outputLength,\n            output,\n            _args14 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_generichash_final$(_context14) {\n            while (1) {\n              switch (_context14.prev = _context14.next) {\n                case 0:\n                  outputLength = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : 32;\n                  output = Buffer.alloc(outputLength);\n                  this.sodium.crypto_generichash_final(state, output);\n                  return _context14.abrupt(\"return\", output);\n\n                case 4:\n                case \"end\":\n                  return _context14.stop();\n              }\n            }\n          }\n\n          return crypto_generichash_final$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_generichash_final;\n    }()\n    /**\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_kdf_derive_from_key = function () {\n      function crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        var subkey;\n        return _regeneratorRuntime.async(function () {\n          function crypto_kdf_derive_from_key$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  subkey = Buffer.alloc(length, 0);\n                  _context15.t0 = this.sodium;\n                  _context15.t1 = subkey;\n                  _context15.t2 = subKeyId | 0;\n                  _context15.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(context));\n\n                case 6:\n                  _context15.t3 = _context15.sent;\n                  _context15.t4 = key.getBuffer();\n\n                  _context15.t0.crypto_kdf_derive_from_key.call(_context15.t0, _context15.t1, _context15.t2, _context15.t3, _context15.t4);\n\n                  return _context15.abrupt(\"return\", new CryptographyKey(subkey));\n\n                case 10:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }\n\n          return crypto_kdf_derive_from_key$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kdf_derive_from_key;\n    }()\n    /**\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    ;\n\n    _proto.crypto_kx_client_session_keys = function () {\n      function crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        var rx, tx;\n        return _regeneratorRuntime.async(function () {\n          function crypto_kx_client_session_keys$(_context16) {\n            while (1) {\n              switch (_context16.prev = _context16.next) {\n                case 0:\n                  rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n                  tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n                  this.sodium.crypto_kx_client_session_keys(rx, tx, clientPublicKey.getBuffer(), clientSecretKey.getBuffer(), serverPublicKey.getBuffer());\n                  return _context16.abrupt(\"return\", [new CryptographyKey(rx), new CryptographyKey(tx)]);\n\n                case 4:\n                case \"end\":\n                  return _context16.stop();\n              }\n            }\n          }\n\n          return crypto_kx_client_session_keys$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kx_client_session_keys;\n    }()\n    /**\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    ;\n\n    _proto.crypto_kx_server_session_keys = function () {\n      function crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        var rx, tx;\n        return _regeneratorRuntime.async(function () {\n          function crypto_kx_server_session_keys$(_context17) {\n            while (1) {\n              switch (_context17.prev = _context17.next) {\n                case 0:\n                  rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n                  tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n                  this.sodium.crypto_kx_server_session_keys(rx, tx, serverPublicKey.getBuffer(), serverSecretKey.getBuffer(), clientPublicKey.getBuffer());\n                  return _context17.abrupt(\"return\", [new CryptographyKey(rx), new CryptographyKey(tx)]);\n\n                case 4:\n                case \"end\":\n                  return _context17.stop();\n              }\n            }\n          }\n\n          return crypto_kx_server_session_keys$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_kx_server_session_keys;\n    }()\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_onetimeauth = function () {\n      function crypto_onetimeauth(message, key) {\n        var output;\n        return _regeneratorRuntime.async(function () {\n          function crypto_onetimeauth$(_context18) {\n            while (1) {\n              switch (_context18.prev = _context18.next) {\n                case 0:\n                  output = Buffer.alloc(16);\n                  _context18.t0 = this.sodium;\n                  _context18.t1 = output;\n                  _context18.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 5:\n                  _context18.t2 = _context18.sent;\n                  _context18.t3 = key.getBuffer();\n\n                  _context18.t0.crypto_onetimeauth.call(_context18.t0, _context18.t1, _context18.t2, _context18.t3);\n\n                  return _context18.abrupt(\"return\", output);\n\n                case 9:\n                case \"end\":\n                  return _context18.stop();\n              }\n            }\n          }\n\n          return crypto_onetimeauth$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_onetimeauth;\n    }()\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_onetimeauth_verify = function () {\n      function crypto_onetimeauth_verify(message, key, tag) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_onetimeauth_verify$(_context19) {\n            while (1) {\n              switch (_context19.prev = _context19.next) {\n                case 0:\n                  _context19.t0 = this.sodium;\n                  _context19.t1 = tag;\n                  _context19.next = 4;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 4:\n                  _context19.t2 = _context19.sent;\n                  _context19.t3 = key.getBuffer();\n                  return _context19.abrupt(\"return\", _context19.t0.crypto_onetimeauth_verify.call(_context19.t0, _context19.t1, _context19.t2, _context19.t3));\n\n                case 7:\n                case \"end\":\n                  return _context19.stop();\n              }\n            }\n          }\n\n          return crypto_onetimeauth_verify$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_onetimeauth_verify;\n    }()\n    /**\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number} algorithm\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_pwhash = function () {\n      function crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm) {\n        var _this2 = this;\n\n        var hashed, bufPass, bufSalt;\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash$(_context20) {\n            while (1) {\n              switch (_context20.prev = _context20.next) {\n                case 0:\n                  hashed = Buffer.alloc(length, 0);\n                  _context20.next = 3;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(password));\n\n                case 3:\n                  bufPass = _context20.sent;\n                  _context20.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(salt));\n\n                case 6:\n                  bufSalt = _context20.sent;\n                  _context20.next = 9;\n                  return _regeneratorRuntime.awrap(new Promise(function (resolve, reject) {\n                    _this2.sodium.crypto_pwhash_async(hashed, bufPass, bufSalt, opslimit, memlimit, algorithm, function (e, res) {\n                      if (e) return reject(e);\n                      return resolve(res);\n                    });\n                  }));\n\n                case 9:\n                  return _context20.abrupt(\"return\", hashed);\n\n                case 10:\n                case \"end\":\n                  return _context20.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_pwhash;\n    }()\n    /**\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    ;\n\n    _proto.crypto_pwhash_str = function () {\n      function crypto_pwhash_str(password, opslimit, memlimit) {\n        var _this3 = this;\n\n        var hashed, bufPass;\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash_str$(_context21) {\n            while (1) {\n              switch (_context21.prev = _context21.next) {\n                case 0:\n                  hashed = Buffer.alloc(128, 0);\n                  _context21.next = 3;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(password));\n\n                case 3:\n                  bufPass = _context21.sent;\n                  _context21.next = 6;\n                  return _regeneratorRuntime.awrap(new Promise(function (resolve, reject) {\n                    _this3.sodium.crypto_pwhash_str_async(hashed, bufPass, opslimit, memlimit, function (e, res) {\n                      if (e) return reject(e);\n                      return resolve(res);\n                    });\n                  }));\n\n                case 6:\n                  return _context21.abrupt(\"return\", hashed.toString());\n\n                case 7:\n                case \"end\":\n                  return _context21.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash_str$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_pwhash_str;\n    }()\n    /**\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_pwhash_str_verify = function () {\n      function crypto_pwhash_str_verify(password, hash) {\n        var _this4 = this;\n\n        var allocated, bufPass;\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash_str_verify$(_context22) {\n            while (1) {\n              switch (_context22.prev = _context22.next) {\n                case 0:\n                  allocated = Buffer.alloc(128, 0);\n                  _context22.next = 3;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(hash));\n\n                case 3:\n                  _context22.sent.copy(allocated, 0, 0);\n\n                  _context22.next = 6;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(password));\n\n                case 6:\n                  bufPass = _context22.sent;\n                  return _context22.abrupt(\"return\", new Promise(function (resolve, reject) {\n                    _this4.sodium.crypto_pwhash_str_verify_async(allocated, bufPass, function (e, res) {\n                      if (e) return reject(e);\n                      return resolve(res);\n                    });\n                  }));\n\n                case 8:\n                case \"end\":\n                  return _context22.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash_str_verify$;\n        }(), null, null, null, Promise);\n      }\n\n      return crypto_pwhash_str_verify;\n    }()\n    /**\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.crypto_pwhash_str_needs_rehash = function () {\n      function crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        var allocated;\n        return _regeneratorRuntime.async(function () {\n          function crypto_pwhash_str_needs_rehash$(_context23) {\n            while (1) {\n              switch (_context23.prev = _context23.next) {\n                case 0:\n                  allocated = Buffer.alloc(128, 0);\n                  _context23.next = 3;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(hash));\n\n                case 3:\n                  _context23.sent.copy(allocated, 0, 0);\n\n                  return _context23.abrupt(\"return\", this.sodium.crypto_pwhash_str_needs_rehash(allocated, opslimit, memlimit));\n\n                case 5:\n                case \"end\":\n                  return _context23.stop();\n              }\n            }\n          }\n\n          return crypto_pwhash_str_needs_rehash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_pwhash_str_needs_rehash;\n    }()\n    /**\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_scalarmult = function () {\n      function crypto_scalarmult(secretKey, publicKey) {\n        var shared;\n        return _regeneratorRuntime.async(function () {\n          function crypto_scalarmult$(_context24) {\n            while (1) {\n              switch (_context24.prev = _context24.next) {\n                case 0:\n                  shared = Buffer.alloc(32);\n                  this.sodium.crypto_scalarmult(shared, secretKey.getBuffer(), publicKey.getBuffer());\n                  _context24.t0 = CryptographyKey;\n                  _context24.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(shared));\n\n                case 5:\n                  _context24.t1 = _context24.sent;\n                  return _context24.abrupt(\"return\", new _context24.t0(_context24.t1));\n\n                case 7:\n                case \"end\":\n                  return _context24.stop();\n              }\n            }\n          }\n\n          return crypto_scalarmult$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_scalarmult;\n    }()\n    /**\n     *\n     * @param {CryptographyKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_scalarmult_base = function () {\n      function crypto_scalarmult_base(secretKey) {\n        var buf;\n        return _regeneratorRuntime.async(function () {\n          function crypto_scalarmult_base$(_context25) {\n            while (1) {\n              switch (_context25.prev = _context25.next) {\n                case 0:\n                  buf = Buffer.alloc(32);\n                  this.sodium.crypto_scalarmult_base(buf, secretKey.getBuffer());\n                  return _context25.abrupt(\"return\", buf);\n\n                case 3:\n                case \"end\":\n                  return _context25.stop();\n              }\n            }\n          }\n\n          return crypto_scalarmult_base$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_scalarmult_base;\n    }()\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretbox = function () {\n      function crypto_secretbox(plaintext, nonce, key) {\n        var encrypted;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretbox$(_context26) {\n            while (1) {\n              switch (_context26.prev = _context26.next) {\n                case 0:\n                  encrypted = Buffer.alloc(plaintext.length + 16);\n                  _context26.t0 = this.sodium;\n                  _context26.t1 = encrypted;\n                  _context26.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 5:\n                  _context26.t2 = _context26.sent;\n                  _context26.t3 = nonce;\n                  _context26.t4 = key.getBuffer();\n\n                  _context26.t0.crypto_secretbox_easy.call(_context26.t0, _context26.t1, _context26.t2, _context26.t3, _context26.t4);\n\n                  return _context26.abrupt(\"return\", encrypted);\n\n                case 10:\n                case \"end\":\n                  return _context26.stop();\n              }\n            }\n          }\n\n          return crypto_secretbox$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretbox;\n    }()\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_shorthash = function () {\n      function crypto_shorthash(message, key) {\n        var output;\n        return _regeneratorRuntime.async(function () {\n          function crypto_shorthash$(_context27) {\n            while (1) {\n              switch (_context27.prev = _context27.next) {\n                case 0:\n                  output = Buffer.alloc(8);\n                  _context27.t0 = this.sodium;\n                  _context27.t1 = output;\n                  _context27.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 5:\n                  _context27.t2 = _context27.sent;\n                  _context27.t3 = key.getBuffer();\n\n                  _context27.t0.crypto_shorthash.call(_context27.t0, _context27.t1, _context27.t2, _context27.t3);\n\n                  return _context27.abrupt(\"return\", output);\n\n                case 9:\n                case \"end\":\n                  return _context27.stop();\n              }\n            }\n          }\n\n          return crypto_shorthash$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_shorthash;\n    }()\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretbox_open = function () {\n      function crypto_secretbox_open(ciphertext, nonce, key) {\n        var decrypted;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretbox_open$(_context28) {\n            while (1) {\n              switch (_context28.prev = _context28.next) {\n                case 0:\n                  decrypted = Buffer.alloc(ciphertext.length - 16);\n\n                  if (this.sodium.crypto_secretbox_open_easy(decrypted, ciphertext, nonce, key.getBuffer())) {\n                    _context28.next = 3;\n                    break;\n                  }\n\n                  throw new SodiumError('Decryption failure');\n\n                case 3:\n                  return _context28.abrupt(\"return\", decrypted);\n\n                case 4:\n                case \"end\":\n                  return _context28.stop();\n              }\n            }\n          }\n\n          return crypto_secretbox_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretbox_open;\n    }()\n    /**\n     * @param {CryptographyKey} key\n     * @return {Promise<array>} [state, header]\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_init_push = function () {\n      function crypto_secretstream_xchacha20poly1305_init_push(key) {\n        var state, header;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_init_push$(_context29) {\n            while (1) {\n              switch (_context29.prev = _context29.next) {\n                case 0:\n                  state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n                  header = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES);\n                  this.sodium.randombytes_buf(header);\n                  this.sodium.crypto_secretstream_xchacha20poly1305_init_push(state, header, key.getBuffer());\n                  return _context29.abrupt(\"return\", [state, header]);\n\n                case 5:\n                case \"end\":\n                  return _context29.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_init_push$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_init_push;\n    }()\n    /**\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>} Returns the opaque state object\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_init_pull = function () {\n      function crypto_secretstream_xchacha20poly1305_init_pull(header, key) {\n        var state;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_init_pull$(_context30) {\n            while (1) {\n              switch (_context30.prev = _context30.next) {\n                case 0:\n                  if (!(header.length !== this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES)) {\n                    _context30.next = 2;\n                    break;\n                  }\n\n                  throw new SodiumError(\"Header must be \" + this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES + \" bytes long\");\n\n                case 2:\n                  state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n                  this.sodium.crypto_secretstream_xchacha20poly1305_init_pull(state, header, key.getBuffer());\n                  return _context30.abrupt(\"return\", state);\n\n                case 5:\n                case \"end\":\n                  return _context30.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_init_pull$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_init_pull;\n    }()\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_push = function () {\n      function crypto_secretstream_xchacha20poly1305_push(state, message) {\n        var ad,\n            tag,\n            ciphertext,\n            _args31 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_push$(_context31) {\n            while (1) {\n              switch (_context31.prev = _context31.next) {\n                case 0:\n                  ad = _args31.length > 2 && _args31[2] !== undefined ? _args31[2] : '';\n                  tag = _args31.length > 3 && _args31[3] !== undefined ? _args31[3] : 0;\n                  ciphertext = Buffer.alloc(message.length + this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n                  _context31.t0 = this.sodium;\n                  _context31.t1 = state;\n                  _context31.t2 = ciphertext;\n                  _context31.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 8:\n                  _context31.t3 = _context31.sent;\n\n                  if (!(ad.length > 0)) {\n                    _context31.next = 15;\n                    break;\n                  }\n\n                  _context31.next = 12;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ad));\n\n                case 12:\n                  _context31.t4 = _context31.sent;\n                  _context31.next = 16;\n                  break;\n\n                case 15:\n                  _context31.t4 = null;\n\n                case 16:\n                  _context31.t5 = _context31.t4;\n                  _context31.t6 = Buffer.from([tag]);\n\n                  _context31.t0.crypto_secretstream_xchacha20poly1305_push.call(_context31.t0, _context31.t1, _context31.t2, _context31.t3, _context31.t5, _context31.t6);\n\n                  return _context31.abrupt(\"return\", ciphertext);\n\n                case 20:\n                case \"end\":\n                  return _context31.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_push$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_push;\n    }()\n    /**\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_pull = function () {\n      function crypto_secretstream_xchacha20poly1305_pull(state, ciphertext) {\n        var ad,\n            tag,\n            plaintext,\n            _args32 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_pull$(_context32) {\n            while (1) {\n              switch (_context32.prev = _context32.next) {\n                case 0:\n                  ad = _args32.length > 2 && _args32[2] !== undefined ? _args32[2] : '';\n                  tag = _args32.length > 3 && _args32[3] !== undefined ? _args32[3] : 0;\n\n                  if (!(ciphertext.length < this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES)) {\n                    _context32.next = 4;\n                    break;\n                  }\n\n                  throw new SodiumError('Invalid ciphertext size');\n\n                case 4:\n                  plaintext = Buffer.alloc(ciphertext.length - this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n                  _context32.t0 = this.sodium;\n                  _context32.t1 = state;\n                  _context32.t2 = plaintext;\n                  _context32.t3 = Buffer.from([tag]);\n                  _context32.t4 = ciphertext;\n\n                  if (!(ad.length > 0)) {\n                    _context32.next = 16;\n                    break;\n                  }\n\n                  _context32.next = 13;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(ad));\n\n                case 13:\n                  _context32.t5 = _context32.sent;\n                  _context32.next = 17;\n                  break;\n\n                case 16:\n                  _context32.t5 = null;\n\n                case 17:\n                  _context32.t6 = _context32.t5;\n\n                  _context32.t0.crypto_secretstream_xchacha20poly1305_pull.call(_context32.t0, _context32.t1, _context32.t2, _context32.t3, _context32.t4, _context32.t6);\n\n                  return _context32.abrupt(\"return\", plaintext);\n\n                case 20:\n                case \"end\":\n                  return _context32.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_pull$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_pull;\n    }()\n    /**\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    ;\n\n    _proto.crypto_secretstream_xchacha20poly1305_rekey = function () {\n      function crypto_secretstream_xchacha20poly1305_rekey(state) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_secretstream_xchacha20poly1305_rekey$(_context33) {\n            while (1) {\n              switch (_context33.prev = _context33.next) {\n                case 0:\n                  this.sodium.crypto_secretstream_xchacha20poly1305_rekey(state);\n\n                case 1:\n                case \"end\":\n                  return _context33.stop();\n              }\n            }\n          }\n\n          return crypto_secretstream_xchacha20poly1305_rekey$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_secretstream_xchacha20poly1305_rekey;\n    }()\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign = function () {\n      function crypto_sign(message, secretKey) {\n        var signed;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign$(_context34) {\n            while (1) {\n              switch (_context34.prev = _context34.next) {\n                case 0:\n                  signed = Buffer.alloc(message.length + 64);\n                  _context34.t0 = this.sodium;\n                  _context34.t1 = signed;\n                  _context34.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 5:\n                  _context34.t2 = _context34.sent;\n                  _context34.t3 = secretKey.getBuffer();\n\n                  _context34.t0.crypto_sign.call(_context34.t0, _context34.t1, _context34.t2, _context34.t3);\n\n                  return _context34.abrupt(\"return\", signed);\n\n                case 9:\n                case \"end\":\n                  return _context34.stop();\n              }\n            }\n          }\n\n          return crypto_sign$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign;\n    }()\n    /**\n     * @param {Buffer} signedMessage,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_open = function () {\n      function crypto_sign_open(signedMessage, publicKey) {\n        var original;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_open$(_context35) {\n            while (1) {\n              switch (_context35.prev = _context35.next) {\n                case 0:\n                  original = Buffer.alloc(signedMessage.length - 64);\n                  _context35.t0 = this.sodium;\n                  _context35.t1 = original;\n                  _context35.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(signedMessage));\n\n                case 5:\n                  _context35.t2 = _context35.sent;\n                  _context35.t3 = publicKey.getBuffer();\n\n                  _context35.t0.crypto_sign_open.call(_context35.t0, _context35.t1, _context35.t2, _context35.t3);\n\n                  return _context35.abrupt(\"return\", original);\n\n                case 9:\n                case \"end\":\n                  return _context35.stop();\n              }\n            }\n          }\n\n          return crypto_sign_open$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_open;\n    }()\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_detached = function () {\n      function crypto_sign_detached(message, secretKey) {\n        var signature;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_detached$(_context36) {\n            while (1) {\n              switch (_context36.prev = _context36.next) {\n                case 0:\n                  signature = Buffer.alloc(64);\n                  _context36.t0 = this.sodium;\n                  _context36.t1 = signature;\n                  _context36.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 5:\n                  _context36.t2 = _context36.sent;\n                  _context36.t3 = secretKey.getBuffer();\n\n                  _context36.t0.crypto_sign_detached.call(_context36.t0, _context36.t1, _context36.t2, _context36.t3);\n\n                  return _context36.abrupt(\"return\", signature);\n\n                case 9:\n                case \"end\":\n                  return _context36.stop();\n              }\n            }\n          }\n\n          return crypto_sign_detached$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_detached;\n    }()\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_verify_detached = function () {\n      function crypto_sign_verify_detached(message, publicKey, signature) {\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_verify_detached$(_context37) {\n            while (1) {\n              switch (_context37.prev = _context37.next) {\n                case 0:\n                  _context37.t0 = this.sodium;\n                  _context37.t1 = signature;\n                  _context37.next = 4;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(message));\n\n                case 4:\n                  _context37.t2 = _context37.sent;\n                  _context37.t3 = publicKey.getBuffer();\n                  return _context37.abrupt(\"return\", _context37.t0.crypto_sign_verify_detached.call(_context37.t0, _context37.t1, _context37.t2, _context37.t3));\n\n                case 7:\n                case \"end\":\n                  return _context37.stop();\n              }\n            }\n          }\n\n          return crypto_sign_verify_detached$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_verify_detached;\n    }()\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_sign_keypair = function () {\n      function crypto_sign_keypair() {\n        var sK, pK;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_keypair$(_context38) {\n            while (1) {\n              switch (_context38.prev = _context38.next) {\n                case 0:\n                  sK = Buffer.alloc(64, 0);\n                  pK = Buffer.alloc(32, 0);\n                  this.sodium.crypto_sign_keypair(pK, sK);\n                  return _context38.abrupt(\"return\", new CryptographyKey(Buffer.concat([sK, pK])));\n\n                case 4:\n                case \"end\":\n                  return _context38.stop();\n              }\n            }\n          }\n\n          return crypto_sign_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_keypair;\n    }()\n    /**\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    ;\n\n    _proto.crypto_sign_seed_keypair = function () {\n      function crypto_sign_seed_keypair(seed) {\n        var sK, pK;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_seed_keypair$(_context39) {\n            while (1) {\n              switch (_context39.prev = _context39.next) {\n                case 0:\n                  sK = Buffer.alloc(64, 0);\n                  pK = Buffer.alloc(32, 0);\n                  this.sodium.crypto_sign_seed_keypair(pK, sK, seed);\n                  return _context39.abrupt(\"return\", new CryptographyKey(Buffer.concat([sK, pK])));\n\n                case 4:\n                case \"end\":\n                  return _context39.stop();\n              }\n            }\n          }\n\n          return crypto_sign_seed_keypair$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_seed_keypair;\n    }()\n    /**\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_ed25519_sk_to_curve25519 = function () {\n      function crypto_sign_ed25519_sk_to_curve25519(sk) {\n        var xsk;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_ed25519_sk_to_curve25519$(_context40) {\n            while (1) {\n              switch (_context40.prev = _context40.next) {\n                case 0:\n                  xsk = Buffer.alloc(32);\n                  this.sodium.crypto_sign_ed25519_sk_to_curve25519(xsk, sk.getBuffer());\n                  return _context40.abrupt(\"return\", xsk);\n\n                case 3:\n                case \"end\":\n                  return _context40.stop();\n              }\n            }\n          }\n\n          return crypto_sign_ed25519_sk_to_curve25519$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_ed25519_sk_to_curve25519;\n    }()\n    /**\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_sign_ed25519_pk_to_curve25519 = function () {\n      function crypto_sign_ed25519_pk_to_curve25519(pk) {\n        var xpk;\n        return _regeneratorRuntime.async(function () {\n          function crypto_sign_ed25519_pk_to_curve25519$(_context41) {\n            while (1) {\n              switch (_context41.prev = _context41.next) {\n                case 0:\n                  xpk = Buffer.alloc(32);\n                  this.sodium.crypto_sign_ed25519_pk_to_curve25519(xpk, pk.getBuffer());\n                  return _context41.abrupt(\"return\", xpk);\n\n                case 3:\n                case \"end\":\n                  return _context41.stop();\n              }\n            }\n          }\n\n          return crypto_sign_ed25519_pk_to_curve25519$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_sign_ed25519_pk_to_curve25519;\n    }()\n    /**\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_stream = function () {\n      function crypto_stream(length, nonce, key) {\n        var output;\n        return _regeneratorRuntime.async(function () {\n          function crypto_stream$(_context42) {\n            while (1) {\n              switch (_context42.prev = _context42.next) {\n                case 0:\n                  output = Buffer.alloc(length);\n                  _context42.t0 = this.sodium;\n                  _context42.t1 = output;\n                  _context42.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 5:\n                  _context42.t2 = _context42.sent;\n                  _context42.t3 = key.getBuffer();\n\n                  _context42.t0.crypto_stream.call(_context42.t0, _context42.t1, _context42.t2, _context42.t3);\n\n                  return _context42.abrupt(\"return\", output);\n\n                case 9:\n                case \"end\":\n                  return _context42.stop();\n              }\n            }\n          }\n\n          return crypto_stream$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_stream;\n    }()\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.crypto_stream_xor = function () {\n      function crypto_stream_xor(plaintext, nonce, key) {\n        var output;\n        return _regeneratorRuntime.async(function () {\n          function crypto_stream_xor$(_context43) {\n            while (1) {\n              switch (_context43.prev = _context43.next) {\n                case 0:\n                  output = Buffer.alloc(plaintext.length);\n                  _context43.t0 = this.sodium;\n                  _context43.t1 = output;\n                  _context43.next = 5;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(plaintext));\n\n                case 5:\n                  _context43.t2 = _context43.sent;\n                  _context43.next = 8;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(nonce));\n\n                case 8:\n                  _context43.t3 = _context43.sent;\n                  _context43.t4 = key.getBuffer();\n\n                  _context43.t0.crypto_stream_xor.call(_context43.t0, _context43.t1, _context43.t2, _context43.t3, _context43.t4);\n\n                  return _context43.abrupt(\"return\", output);\n\n                case 12:\n                case \"end\":\n                  return _context43.stop();\n              }\n            }\n          }\n\n          return crypto_stream_xor$;\n        }(), null, this, null, Promise);\n      }\n\n      return crypto_stream_xor;\n    }()\n    /**\n     * @param {number} number\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.randombytes_buf = function () {\n      function randombytes_buf(number) {\n        var buf;\n        return _regeneratorRuntime.async(function () {\n          function randombytes_buf$(_context44) {\n            while (1) {\n              switch (_context44.prev = _context44.next) {\n                case 0:\n                  buf = Buffer.alloc(number);\n                  this.sodium.randombytes_buf(buf);\n                  return _context44.abrupt(\"return\", buf);\n\n                case 3:\n                case \"end\":\n                  return _context44.stop();\n              }\n            }\n          }\n\n          return randombytes_buf$;\n        }(), null, this, null, Promise);\n      }\n\n      return randombytes_buf;\n    }()\n    /**\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    ;\n\n    _proto.randombytes_uniform = function () {\n      function randombytes_uniform(upperBound) {\n        return _regeneratorRuntime.async(function () {\n          function randombytes_uniform$(_context45) {\n            while (1) {\n              switch (_context45.prev = _context45.next) {\n                case 0:\n                  return _context45.abrupt(\"return\", this.sodium.randombytes_uniform(upperBound));\n\n                case 1:\n                case \"end\":\n                  return _context45.stop();\n              }\n            }\n          }\n\n          return randombytes_uniform$;\n        }(), null, this, null, Promise);\n      }\n\n      return randombytes_uniform;\n    }()\n    /**\n     * @param {Uint8Array} val\n     * @param {Uint8Array} addv\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_add = function () {\n      function sodium_add(val, addv) {\n        var buf;\n        return _regeneratorRuntime.async(function () {\n          function sodium_add$(_context46) {\n            while (1) {\n              switch (_context46.prev = _context46.next) {\n                case 0:\n                  _context46.next = 2;\n                  return _regeneratorRuntime.awrap(Util.cloneBuffer(val));\n\n                case 2:\n                  buf = _context46.sent;\n                  this.sodium.sodium_add(buf, addv);\n                  return _context46.abrupt(\"return\", buf);\n\n                case 5:\n                case \"end\":\n                  return _context46.stop();\n              }\n            }\n          }\n\n          return sodium_add$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_add;\n    }()\n    /**\n     * @param {Buffer} input\n     * @return {Promise<string>}\n     */\n    ;\n\n    _proto.sodium_bin2hex = function () {\n      function sodium_bin2hex(input) {\n        var str, b, c, x, i;\n        return _regeneratorRuntime.async(function () {\n          function sodium_bin2hex$(_context47) {\n            while (1) {\n              switch (_context47.prev = _context47.next) {\n                case 0:\n                  str = \"\";\n\n                  for (i = 0; i < input.length; i++) {\n                    c = input[i] & 0xf;\n                    b = input[i] >>> 4;\n                    x = 87 + c + (c - 10 >> 8 & ~38) << 8 | 87 + b + (b - 10 >> 8 & ~38);\n                    str += String.fromCharCode(x & 0xff) + String.fromCharCode(x >>> 8);\n                  }\n\n                  return _context47.abrupt(\"return\", str);\n\n                case 3:\n                case \"end\":\n                  return _context47.stop();\n              }\n            }\n          }\n\n          return sodium_bin2hex$;\n        }(), null, null, null, Promise);\n      }\n\n      return sodium_bin2hex;\n    }()\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    ;\n\n    _proto.sodium_compare = function () {\n      function sodium_compare(b1, b2) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_compare$(_context48) {\n            while (1) {\n              switch (_context48.prev = _context48.next) {\n                case 0:\n                  return _context48.abrupt(\"return\", this.sodium.sodium_compare(b1, b2));\n\n                case 1:\n                case \"end\":\n                  return _context48.stop();\n              }\n            }\n          }\n\n          return sodium_compare$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_compare;\n    }()\n    /**\n     * @param {Buffer|string} hex\n     * @param {string|null} ignore\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_hex2bin = function () {\n      function sodium_hex2bin(hex) {\n        var ignore,\n            bin_pos,\n            hex_pos,\n            c,\n            c_acc,\n            c_alpha0,\n            c_alpha,\n            c_num0,\n            c_num,\n            c_val,\n            state,\n            bin,\n            _args49 = arguments;\n        return _regeneratorRuntime.async(function () {\n          function sodium_hex2bin$(_context49) {\n            while (1) {\n              switch (_context49.prev = _context49.next) {\n                case 0:\n                  ignore = _args49.length > 1 && _args49[1] !== undefined ? _args49[1] : null;\n                  bin_pos = 0, hex_pos = 0, c = 0, c_acc = 0, c_alpha0 = 0, c_alpha = 0, c_num0 = 0, c_num = 0, c_val = 0, state = 0;\n                  bin = Buffer.alloc(hex.length >> 1, 0);\n\n                case 3:\n                  if (!(hex_pos < hex.length)) {\n                    _context49.next = 20;\n                    break;\n                  }\n\n                  c = hex.charCodeAt(hex_pos);\n                  c_num = c ^ 48;\n                  c_num0 = c_num - 10 >> 8;\n                  c_alpha = (c & ~32) - 55;\n                  c_alpha0 = (c_alpha - 10 ^ c_alpha - 16) >> 8;\n\n                  if (!((c_num0 | c_alpha0) === 0)) {\n                    _context49.next = 14;\n                    break;\n                  }\n\n                  if (!(ignore && state === 0 && ignore.indexOf(c) >= 0)) {\n                    _context49.next = 13;\n                    break;\n                  }\n\n                  hex_pos++;\n                  return _context49.abrupt(\"continue\", 3);\n\n                case 13:\n                  return _context49.abrupt(\"break\", 20);\n\n                case 14:\n                  c_val = c_num0 & c_num | c_alpha0 & c_alpha;\n\n                  if (state === 0) {\n                    c_acc = c_val * 16;\n                  } else {\n                    bin[bin_pos++] = c_acc | c_val;\n                  }\n\n                  state = ~state;\n                  hex_pos++;\n                  _context49.next = 3;\n                  break;\n\n                case 20:\n                  return _context49.abrupt(\"return\", bin);\n\n                case 21:\n                case \"end\":\n                  return _context49.stop();\n              }\n            }\n          }\n\n          return sodium_hex2bin$;\n        }(), null, null, null, Promise);\n      }\n\n      return sodium_hex2bin;\n    }()\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_increment = function () {\n      function sodium_increment(buf) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_increment$(_context50) {\n            while (1) {\n              switch (_context50.prev = _context50.next) {\n                case 0:\n                  return _context50.abrupt(\"return\", this.sodium.sodium_increment(buf));\n\n                case 1:\n                case \"end\":\n                  return _context50.stop();\n              }\n            }\n          }\n\n          return sodium_increment$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_increment;\n    }()\n    /**\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_is_zero = function () {\n      function sodium_is_zero(buf, len) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_is_zero$(_context51) {\n            while (1) {\n              switch (_context51.prev = _context51.next) {\n                case 0:\n                  return _context51.abrupt(\"return\", this.sodium.sodium_is_zero(buf, len));\n\n                case 1:\n                case \"end\":\n                  return _context51.stop();\n              }\n            }\n          }\n\n          return sodium_is_zero$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_is_zero;\n    }()\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    ;\n\n    _proto.sodium_memcmp = function () {\n      function sodium_memcmp(b1, b2) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_memcmp$(_context52) {\n            while (1) {\n              switch (_context52.prev = _context52.next) {\n                case 0:\n                  return _context52.abrupt(\"return\", this.sodium.sodium_memcmp(b1, b2));\n\n                case 1:\n                case \"end\":\n                  return _context52.stop();\n              }\n            }\n          }\n\n          return sodium_memcmp$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_memcmp;\n    }()\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    ;\n\n    _proto.sodium_memzero = function () {\n      function sodium_memzero(buf) {\n        return _regeneratorRuntime.async(function () {\n          function sodium_memzero$(_context53) {\n            while (1) {\n              switch (_context53.prev = _context53.next) {\n                case 0:\n                  this.sodium.sodium_memzero(buf);\n\n                case 1:\n                case \"end\":\n                  return _context53.stop();\n              }\n            }\n          }\n\n          return sodium_memzero$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_memzero;\n    }()\n    /**\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_pad = function () {\n      function sodium_pad(buf, blockSize) {\n        var length, padded, sliceto;\n        return _regeneratorRuntime.async(function () {\n          function sodium_pad$(_context54) {\n            while (1) {\n              switch (_context54.prev = _context54.next) {\n                case 0:\n                  _context54.next = 2;\n                  return _regeneratorRuntime.awrap(Util.toBuffer(buf));\n\n                case 2:\n                  buf = _context54.sent;\n                  length = buf.length + buf.length % blockSize;\n\n                  if (length < blockSize) {\n                    length += blockSize;\n                  }\n\n                  padded = Buffer.alloc(length + 100);\n                  buf.copy(padded, 0, 0);\n                  sliceto = this.sodium.sodium_pad(padded, buf.length, blockSize);\n                  return _context54.abrupt(\"return\", padded.slice(0, sliceto));\n\n                case 9:\n                case \"end\":\n                  return _context54.stop();\n              }\n            }\n          }\n\n          return sodium_pad$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_pad;\n    }()\n    /**\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    ;\n\n    _proto.sodium_unpad = function () {\n      function sodium_unpad(buf, blockSize) {\n        var outlen;\n        return _regeneratorRuntime.async(function () {\n          function sodium_unpad$(_context55) {\n            while (1) {\n              switch (_context55.prev = _context55.next) {\n                case 0:\n                  outlen = this.sodium.sodium_unpad(buf, buf.length, blockSize);\n                  return _context55.abrupt(\"return\", buf.slice(0, outlen));\n\n                case 2:\n                case \"end\":\n                  return _context55.stop();\n              }\n            }\n          }\n\n          return sodium_unpad$;\n        }(), null, this, null, Promise);\n      }\n\n      return sodium_unpad;\n    }();\n\n    return SodiumNativeBackend;\n  }(Backend);\n}.call(this, module);","map":{"version":3,"sources":["imports/client/sodium-plus/lib/backend/sodiumnative.js"],"names":["_regeneratorRuntime","module1","link","default","v","_inheritsLoose","loaded","_sodium","require","e","Backend","CryptographyKey","SodiumError","Util","toBuffer","Buffer","module","exports","lib","sodium","backendName","init","SodiumNativeBackend","crypto_aead_xchacha20poly1305_ietf_decrypt","ciphertext","assocData","nonce","key","plaintext","alloc","length","getBuffer","crypto_aead_xchacha20poly1305_ietf_encrypt","crypto_auth","message","output","crypto_auth_verify","mac","crypto_box","sk","pk","crypto_box_easy","crypto_box_open","success","crypto_box_open_easy","crypto_box_seal","crypto_box_seal_open","crypto_box_keypair","sK","pK","concat","crypto_generichash","outputLength","hash","crypto_generichash_init","state","CRYPTO_GENERICHASH_STATEBYTES","crypto_generichash_update","crypto_generichash_final","crypto_kdf_derive_from_key","subKeyId","context","subkey","crypto_kx_client_session_keys","clientPublicKey","clientSecretKey","serverPublicKey","rx","CRYPTO_KX_SESSIONKEYBYTES","tx","crypto_kx_server_session_keys","serverSecretKey","crypto_onetimeauth","crypto_onetimeauth_verify","tag","crypto_pwhash","password","salt","opslimit","memlimit","algorithm","hashed","bufPass","bufSalt","Promise","resolve","reject","crypto_pwhash_async","res","crypto_pwhash_str","crypto_pwhash_str_async","toString","crypto_pwhash_str_verify","allocated","copy","crypto_pwhash_str_verify_async","crypto_pwhash_str_needs_rehash","crypto_scalarmult","secretKey","publicKey","shared","crypto_scalarmult_base","buf","crypto_secretbox","encrypted","crypto_secretbox_easy","crypto_shorthash","crypto_secretbox_open","decrypted","crypto_secretbox_open_easy","crypto_secretstream_xchacha20poly1305_init_push","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES","header","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES","randombytes_buf","crypto_secretstream_xchacha20poly1305_init_pull","crypto_secretstream_xchacha20poly1305_push","ad","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES","from","crypto_secretstream_xchacha20poly1305_pull","crypto_secretstream_xchacha20poly1305_rekey","crypto_sign","signed","crypto_sign_open","signedMessage","original","crypto_sign_detached","signature","crypto_sign_verify_detached","crypto_sign_keypair","crypto_sign_seed_keypair","seed","crypto_sign_ed25519_sk_to_curve25519","xsk","crypto_sign_ed25519_pk_to_curve25519","xpk","crypto_stream","crypto_stream_xor","number","randombytes_uniform","upperBound","sodium_add","val","addv","cloneBuffer","sodium_bin2hex","input","str","i","c","b","x","String","fromCharCode","sodium_compare","b1","b2","sodium_hex2bin","hex","ignore","bin_pos","hex_pos","c_acc","c_alpha0","c_alpha","c_num0","c_num","c_val","bin","charCodeAt","indexOf","sodium_increment","sodium_is_zero","len","sodium_memcmp","sodium_memzero","sodium_pad","blockSize","padded","sliceto","slice","sodium_unpad","outlen"],"mappings":"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","sourcesContent":["let loaded = false;\nlet _sodium;\n/* istanbul ignore next */\ntry {\n    _sodium = require('sodium-native');\n    loaded = true;\n} catch (e) {\n    _sodium = {};\n}\nconst Backend = require('../backend');\nconst CryptographyKey = require('../cryptography-key');\nconst SodiumError = require('../sodium-error');\nconst Util = require('../util');\nconst toBuffer = require('typedarray-to-buffer');\n/* istanbul ignore if */\nif (typeof (Buffer) === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n}\n\n/* istanbul ignore next */\nmodule.exports = class SodiumNativeBackend extends Backend {\n    constructor(lib) {\n        super(lib);\n        this.sodium = lib;\n        this.backendName = 'SodiumNativeBackend';\n    }\n\n    static async init() {\n        if (!loaded) {\n            throw new SodiumError('sodium-native not installed');\n        }\n        return new SodiumNativeBackend(_sodium);\n    }\n\n    /**\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, assocData, nonce, key) {\n        const plaintext = Buffer.alloc(ciphertext.length - 16, 0);\n        this.sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            plaintext,\n            null,\n            await Util.toBuffer(ciphertext),\n            await Util.toBuffer(assocData),\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return plaintext;\n    }\n\n    /**\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, assocData, nonce, key) {\n        const ciphertext = Buffer.alloc(plaintext.length + 16, 0);\n        this.sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            ciphertext,\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(assocData),\n            null,\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return ciphertext;\n    }\n\n    /**\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<buffer>}\n     */\n    async crypto_auth(message, key) {\n        const output = Buffer.alloc(32);\n        this.sodium.crypto_auth(\n            output,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n        return toBuffer(output);\n    }\n\n    /**\n     * @param {Buffer} mac\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<boolean>}\n     */\n    async crypto_auth_verify(mac, message, key) {\n        return this.sodium.crypto_auth_verify(\n            mac,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n    }\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n    async crypto_box(plaintext, nonce, sk, pk) {\n        const ciphertext = Buffer.alloc(plaintext.length + 16);\n        this.sodium.crypto_box_easy(\n            ciphertext,\n            await Util.toBuffer(plaintext),\n            nonce,\n            pk.getBuffer(),\n            sk.getBuffer()\n        );\n        return Util.toBuffer(ciphertext);\n    }\n\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_open(ciphertext, nonce, sk, pk) {\n        const plaintext = Buffer.alloc(ciphertext.length - 16);\n        const success = this.sodium.crypto_box_open_easy(\n            plaintext,\n            ciphertext,\n            nonce,\n            pk.getBuffer(),\n            sk.getBuffer()\n        );\n        if (!success) {\n            throw new SodiumError('Decryption failed');\n        }\n        return Util.toBuffer(plaintext);\n    }\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n    async crypto_box_seal(plaintext, pk) {\n        const ciphertext = Buffer.alloc(plaintext.length + 48);\n        this.sodium.crypto_box_seal(\n            ciphertext,\n            await Util.toBuffer(plaintext),\n            pk.getBuffer()\n        );\n        return Util.toBuffer(ciphertext);\n    }\n\n    /**\n     * @param {Buffer} ciphertext\n     * @param {CryptographyKey} pk\n     * @param {CryptographyKey} sk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal_open(ciphertext, pk, sk) {\n        const plaintext = Buffer.alloc(ciphertext.length - 48);\n        const success = this.sodium.crypto_box_seal_open(\n            plaintext,\n            await Util.toBuffer(ciphertext),\n            pk.getBuffer(),\n            sk.getBuffer()\n        );\n        if (!success) {\n            throw new SodiumError('Decryption failed');\n        }\n        return Util.toBuffer(plaintext);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair() {\n        const sK = Buffer.alloc(32, 0);\n        const pK = Buffer.alloc(32, 0);\n        this.sodium.crypto_box_keypair(sK, pK);\n        return new CryptographyKey(\n            Buffer.concat([pK, sK])\n        );\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash(message, key = null, outputLength = 32) {\n        const hash = Buffer.alloc(outputLength);\n        if (key) {\n            this.sodium.crypto_generichash(hash, await Util.toBuffer(message), key.getBuffer());\n        } else {\n            this.sodium.crypto_generichash(hash, await Util.toBuffer(message));\n        }\n        return hash;\n    }\n\n    /**\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_init(key = null, outputLength = 32) {\n        const state = Buffer.alloc(this.CRYPTO_GENERICHASH_STATEBYTES);\n        if (key) {\n            this.sodium.crypto_generichash_init(state, key.getBuffer(), outputLength);\n        } else {\n            this.sodium.crypto_generichash_init(state, null, outputLength);\n        }\n        return state;\n    }\n\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    async crypto_generichash_update(state, message) {\n        this.sodium.crypto_generichash_update(state, await Util.toBuffer(message));\n        return state;\n    }\n\n    /**\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_final(state, outputLength = 32) {\n        const output = Buffer.alloc(outputLength);\n        this.sodium.crypto_generichash_final(state, output);\n        return output;\n    }\n\n    /**\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        const subkey = Buffer.alloc(length, 0);\n        this.sodium.crypto_kdf_derive_from_key(\n            subkey,\n            subKeyId | 0,\n            await Util.toBuffer(context),\n            key.getBuffer()\n        );\n        return new CryptographyKey(subkey);\n    }\n\n    /**\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        const rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        const tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        this.sodium.crypto_kx_client_session_keys(\n            rx,\n            tx,\n            clientPublicKey.getBuffer(),\n            clientSecretKey.getBuffer(),\n            serverPublicKey.getBuffer(),\n        );\n        return [\n            new CryptographyKey(rx),\n            new CryptographyKey(tx)\n        ];\n    }\n\n    /**\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        const rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        const tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        this.sodium.crypto_kx_server_session_keys(\n            rx,\n            tx,\n            serverPublicKey.getBuffer(),\n            serverSecretKey.getBuffer(),\n            clientPublicKey.getBuffer(),\n        );\n        return [\n            new CryptographyKey(rx),\n            new CryptographyKey(tx)\n        ];\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_onetimeauth(message, key) {\n        const output = Buffer.alloc(16);\n        this.sodium.crypto_onetimeauth(\n            output,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    async crypto_onetimeauth_verify(message, key, tag) {\n        return this.sodium.crypto_onetimeauth_verify(\n            tag,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n    }\n\n    /**\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number} algorithm\n     * @return {Promise<Buffer>}\n     */\n    async crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm) {\n        const hashed = Buffer.alloc(length, 0);\n        const bufPass = await Util.toBuffer(password);\n        const bufSalt = await Util.toBuffer(salt);\n        await new Promise((resolve, reject) => {\n            this.sodium.crypto_pwhash_async(\n                hashed,\n                bufPass,\n                bufSalt,\n                opslimit,\n                memlimit,\n                algorithm,\n                (e, res) => {\n                    if (e) return reject(e);\n                    return resolve(res);\n                }\n            );\n        });\n        return hashed;\n    }\n\n    /**\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n        const hashed = Buffer.alloc(128, 0);\n        const bufPass = await Util.toBuffer(password);\n        await new Promise((resolve, reject) => {\n            this.sodium.crypto_pwhash_str_async(\n                hashed,\n                bufPass,\n                opslimit,\n                memlimit,\n                (e, res) => {\n                    if (e) return reject(e);\n                    return resolve(res);\n                }\n            );\n        });\n        return hashed.toString();\n\n    }\n\n    /**\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_verify(password, hash) {\n        const allocated = Buffer.alloc(128, 0);\n        (await Util.toBuffer(hash)).copy(allocated, 0, 0);\n        const bufPass = await Util.toBuffer(password);\n        return new Promise((resolve, reject) => {\n            this.sodium.crypto_pwhash_str_verify_async(\n                allocated,\n                bufPass,\n                (e, res) => {\n                    if (e) return reject(e);\n                    return resolve(res);\n                }\n            );\n        });\n    }\n\n    /**\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        const allocated = Buffer.alloc(128, 0);\n        (await Util.toBuffer(hash)).copy(allocated, 0, 0);\n        return this.sodium.crypto_pwhash_str_needs_rehash(\n            allocated,\n            opslimit,\n            memlimit\n        );\n    }\n\n    /**\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_scalarmult(secretKey, publicKey) {\n        const shared = Buffer.alloc(32);\n        this.sodium.crypto_scalarmult(shared, secretKey.getBuffer(), publicKey.getBuffer());\n        return new CryptographyKey(\n            await Util.toBuffer(shared)\n        );\n    }\n\n    /**\n     *\n     * @param {CryptographyKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_scalarmult_base(secretKey) {\n        const buf = Buffer.alloc(32);\n        this.sodium.crypto_scalarmult_base(buf, secretKey.getBuffer());\n        return buf;\n    }\n\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox(plaintext, nonce, key) {\n        const encrypted = Buffer.alloc(plaintext.length + 16);\n        this.sodium.crypto_secretbox_easy(\n            encrypted,\n            await Util.toBuffer(plaintext),\n            nonce,\n            key.getBuffer()\n        );\n        return encrypted;\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_shorthash(message, key) {\n        const output = Buffer.alloc(8);\n        this.sodium.crypto_shorthash(\n            output,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n        const decrypted = Buffer.alloc(ciphertext.length - 16);\n        if (!this.sodium.crypto_secretbox_open_easy(\n            decrypted,\n            ciphertext,\n            nonce,\n            key.getBuffer()\n        )) {\n            throw new SodiumError('Decryption failure');\n        }\n        return decrypted;\n    }\n\n    /**\n     * @param {CryptographyKey} key\n     * @return {Promise<array>} [state, header]\n     */\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n        const state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n        const header = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES);\n        this.sodium.randombytes_buf(header);\n        this.sodium.crypto_secretstream_xchacha20poly1305_init_push(state, header, key.getBuffer());\n        return [state, header];\n    }\n\n    /**\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>} Returns the opaque state object\n     */\n    async crypto_secretstream_xchacha20poly1305_init_pull(header, key) {\n        if (header.length !== this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES) {\n            throw new SodiumError(`Header must be ${this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES} bytes long`);\n        }\n        const state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n        this.sodium.crypto_secretstream_xchacha20poly1305_init_pull(state, header, key.getBuffer());\n        return state;\n    }\n\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_push(state, message, ad = '', tag = 0) {\n        const ciphertext = Buffer.alloc(message.length + this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n        this.sodium.crypto_secretstream_xchacha20poly1305_push(\n            state,\n            ciphertext,\n            await Util.toBuffer(message),\n            ad.length > 0 ? (await Util.toBuffer(ad)) : null,\n            Buffer.from([tag])\n        );\n        return ciphertext;\n    }\n\n    /**\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad = '', tag = 0) {\n        if (ciphertext.length < this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES) {\n            throw new SodiumError('Invalid ciphertext size');\n        }\n        const plaintext = Buffer.alloc(ciphertext.length - this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n        this.sodium.crypto_secretstream_xchacha20poly1305_pull(\n            state,\n            plaintext,\n            Buffer.from([tag]),\n            ciphertext,\n            ad.length > 0 ? (await Util.toBuffer(ad)) : null\n        );\n        return plaintext;\n    }\n\n    /**\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n        this.sodium.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign(message, secretKey) {\n        const signed = Buffer.alloc(message.length + 64);\n        this.sodium.crypto_sign(signed, await Util.toBuffer(message), secretKey.getBuffer());\n        return signed;\n    }\n\n    /**\n     * @param {Buffer} signedMessage,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_open(signedMessage, publicKey) {\n        const original = Buffer.alloc(signedMessage.length - 64);\n        this.sodium.crypto_sign_open(original, await Util.toBuffer(signedMessage), publicKey.getBuffer());\n        return original;\n    }\n\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_detached(message, secretKey) {\n        const signature = Buffer.alloc(64);\n        this.sodium.crypto_sign_detached(signature, await Util.toBuffer(message), secretKey.getBuffer());\n        return signature;\n    }\n\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n        return this.sodium.crypto_sign_verify_detached(\n            signature,\n            await Util.toBuffer(message),\n            publicKey.getBuffer()\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_keypair() {\n        const sK = Buffer.alloc(64, 0);\n        const pK = Buffer.alloc(32, 0);\n        this.sodium.crypto_sign_keypair(pK, sK);\n        return new CryptographyKey(\n            Buffer.concat([sK, pK])\n        );\n    }\n\n    /**\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_seed_keypair(seed) {\n        const sK = Buffer.alloc(64, 0);\n        const pK = Buffer.alloc(32, 0);\n        this.sodium.crypto_sign_seed_keypair(pK, sK, seed);\n        return new CryptographyKey(\n            Buffer.concat([sK, pK])\n        );\n    }\n\n    /**\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n        const xsk = Buffer.alloc(32);\n        this.sodium.crypto_sign_ed25519_sk_to_curve25519(xsk, sk.getBuffer());\n        return xsk;\n    }\n\n    /**\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n        const xpk = Buffer.alloc(32);\n        this.sodium.crypto_sign_ed25519_pk_to_curve25519(xpk, pk.getBuffer());\n        return xpk;\n    }\n\n    /**\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream(length, nonce, key) {\n        const output = Buffer.alloc(length);\n        this.sodium.crypto_stream(\n            output,\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream_xor(plaintext, nonce, key) {\n        const output = Buffer.alloc(plaintext.length);\n        this.sodium.crypto_stream_xor(\n            output,\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {number} number\n     * @return {Promise<Buffer>}\n     */\n    async randombytes_buf(number) {\n        let buf = Buffer.alloc(number);\n        this.sodium.randombytes_buf(buf);\n        return buf;\n    }\n\n    /**\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    async randombytes_uniform(upperBound) {\n        return this.sodium.randombytes_uniform(upperBound);\n    }\n\n    /**\n     * @param {Uint8Array} val\n     * @param {Uint8Array} addv\n     * @return {Promise<Buffer>}\n     */\n    async sodium_add(val, addv) {\n        const buf = await Util.cloneBuffer(val);\n        this.sodium.sodium_add(buf, addv);\n        return buf;\n    }\n\n    /**\n     * @param {Buffer} input\n     * @return {Promise<string>}\n     */\n    async sodium_bin2hex(input) {\n        let str = \"\", b, c, x;\n        for (let i = 0; i < input.length; i++) {\n            c = input[i] & 0xf;\n            b = input[i] >>> 4;\n            x =\n                ((87 + c + (((c - 10) >> 8) & ~38)) << 8) |\n                (87 + b + (((b - 10) >> 8) & ~38));\n            str += String.fromCharCode(x & 0xff) + String.fromCharCode(x >>> 8);\n        }\n        return str;\n    }\n\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    async sodium_compare(b1, b2) {\n        return this.sodium.sodium_compare(b1, b2);\n    }\n\n    /**\n     * @param {Buffer|string} hex\n     * @param {string|null} ignore\n     * @return {Promise<Buffer>}\n     */\n    async sodium_hex2bin(hex, ignore = null) {\n        let bin_pos = 0,\n            hex_pos = 0,\n            c = 0,\n            c_acc = 0,\n            c_alpha0 = 0,\n            c_alpha = 0,\n            c_num0 = 0,\n            c_num = 0,\n            c_val = 0,\n            state = 0;\n        const bin = Buffer.alloc(hex.length >> 1, 0);\n\n        while (hex_pos < hex.length) {\n            c = hex.charCodeAt(hex_pos);\n            c_num = c ^ 48;\n            c_num0 = (c_num - 10) >> 8;\n            c_alpha = (c & ~32) - 55;\n            c_alpha0 = ((c_alpha - 10) ^ (c_alpha - 16)) >> 8;\n            if ((c_num0 | c_alpha0) === 0) {\n                if (ignore && state === 0 && ignore.indexOf(c) >= 0) {\n                    hex_pos++;\n                    continue;\n                }\n                break;\n            }\n            c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);\n            if (state === 0) {\n                c_acc = c_val * 16;\n            } else {\n                bin[bin_pos++] = c_acc | c_val;\n            }\n            state = ~state;\n            hex_pos++;\n        }\n        return bin;\n    }\n\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    async sodium_increment(buf) {\n        return this.sodium.sodium_increment(buf);\n    }\n\n    /**\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    async sodium_is_zero(buf, len) {\n        return this.sodium.sodium_is_zero(buf, len);\n    }\n\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    async sodium_memcmp(b1, b2) {\n        return this.sodium.sodium_memcmp(b1, b2);\n    }\n\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    async sodium_memzero(buf) {\n        this.sodium.sodium_memzero(buf);\n    }\n\n    /**\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_pad(buf, blockSize) {\n        buf = await Util.toBuffer(buf);\n        let length = buf.length + (buf.length % blockSize);\n        if (length < blockSize) {\n            length += blockSize;\n        }\n        const padded = Buffer.alloc(length + 100);\n        buf.copy(padded, 0, 0);\n        const sliceto = this.sodium.sodium_pad(padded, buf.length, blockSize);\n        return padded.slice(0, sliceto);\n    }\n\n    /**\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_unpad(buf, blockSize) {\n        const outlen = this.sodium.sodium_unpad(buf, buf.length, blockSize);\n        return buf.slice(0, outlen);\n    }\n};\n"]},"sourceType":"module","hash":"8cfcacce9bde923d61fb84e90c61dc94f52516d9"}
