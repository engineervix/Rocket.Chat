{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/backend/sodiumnative.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"imports/client/sodium-plus/lib/backend/sodiumnative.js","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/backend/sodiumnative.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/imports/client/sodium-plus/lib/backend/sodiumnative.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/client/sodium-plus/lib/backend/sodiumnative.js"}},"code":"!function (module1) {\n  let loaded = false;\n\n  let _sodium;\n  /* istanbul ignore next */\n\n\n  try {\n    _sodium = require('sodium-native');\n    loaded = true;\n  } catch (e) {\n    _sodium = {};\n  }\n\n  const Backend = require('../backend');\n\n  const CryptographyKey = require('../cryptography-key');\n\n  const SodiumError = require('../sodium-error');\n\n  const Util = require('../util');\n\n  const toBuffer = require('typedarray-to-buffer');\n  /* istanbul ignore if */\n\n\n  if (typeof Buffer === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n  }\n  /* istanbul ignore next */\n\n\n  module.exports = class SodiumNativeBackend extends Backend {\n    constructor(lib) {\n      super(lib);\n      this.sodium = lib;\n      this.backendName = 'SodiumNativeBackend';\n    }\n\n    static async init() {\n      if (!loaded) {\n        throw new SodiumError('sodium-native not installed');\n      }\n\n      return new SodiumNativeBackend(_sodium);\n    }\n    /**\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, assocData, nonce, key) {\n      const plaintext = Buffer.alloc(ciphertext.length - 16, 0);\n      this.sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(plaintext, null, await Util.toBuffer(ciphertext), await Util.toBuffer(assocData), await Util.toBuffer(nonce), key.getBuffer());\n      return plaintext;\n    }\n    /**\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, assocData, nonce, key) {\n      const ciphertext = Buffer.alloc(plaintext.length + 16, 0);\n      this.sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(ciphertext, await Util.toBuffer(plaintext), await Util.toBuffer(assocData), null, await Util.toBuffer(nonce), key.getBuffer());\n      return ciphertext;\n    }\n    /**\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<buffer>}\n     */\n\n\n    async crypto_auth(message, key) {\n      const output = Buffer.alloc(32);\n      this.sodium.crypto_auth(output, await Util.toBuffer(message), key.getBuffer());\n      return toBuffer(output);\n    }\n    /**\n     * @param {Buffer} mac\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_auth_verify(mac, message, key) {\n      return this.sodium.crypto_auth_verify(mac, await Util.toBuffer(message), key.getBuffer());\n    }\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n\n\n    async crypto_box(plaintext, nonce, sk, pk) {\n      const ciphertext = Buffer.alloc(plaintext.length + 16);\n      this.sodium.crypto_box_easy(ciphertext, await Util.toBuffer(plaintext), nonce, pk.getBuffer(), sk.getBuffer());\n      return Util.toBuffer(ciphertext);\n    }\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_box_open(ciphertext, nonce, sk, pk) {\n      const plaintext = Buffer.alloc(ciphertext.length - 16);\n      const success = this.sodium.crypto_box_open_easy(plaintext, ciphertext, nonce, pk.getBuffer(), sk.getBuffer());\n\n      if (!success) {\n        throw new SodiumError('Decryption failed');\n      }\n\n      return Util.toBuffer(plaintext);\n    }\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n\n\n    async crypto_box_seal(plaintext, pk) {\n      const ciphertext = Buffer.alloc(plaintext.length + 48);\n      this.sodium.crypto_box_seal(ciphertext, await Util.toBuffer(plaintext), pk.getBuffer());\n      return Util.toBuffer(ciphertext);\n    }\n    /**\n     * @param {Buffer} ciphertext\n     * @param {CryptographyKey} pk\n     * @param {CryptographyKey} sk\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_box_seal_open(ciphertext, pk, sk) {\n      const plaintext = Buffer.alloc(ciphertext.length - 48);\n      const success = this.sodium.crypto_box_seal_open(plaintext, await Util.toBuffer(ciphertext), pk.getBuffer(), sk.getBuffer());\n\n      if (!success) {\n        throw new SodiumError('Decryption failed');\n      }\n\n      return Util.toBuffer(plaintext);\n    }\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_box_keypair() {\n      const sK = Buffer.alloc(32, 0);\n      const pK = Buffer.alloc(32, 0);\n      this.sodium.crypto_box_keypair(sK, pK);\n      return new CryptographyKey(Buffer.concat([pK, sK]));\n    }\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_generichash(message) {\n      let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let outputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n      const hash = Buffer.alloc(outputLength);\n\n      if (key) {\n        this.sodium.crypto_generichash(hash, await Util.toBuffer(message), key.getBuffer());\n      } else {\n        this.sodium.crypto_generichash(hash, await Util.toBuffer(message));\n      }\n\n      return hash;\n    }\n    /**\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_generichash_init() {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      let outputLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      const state = Buffer.alloc(this.CRYPTO_GENERICHASH_STATEBYTES);\n\n      if (key) {\n        this.sodium.crypto_generichash_init(state, key.getBuffer(), outputLength);\n      } else {\n        this.sodium.crypto_generichash_init(state, null, outputLength);\n      }\n\n      return state;\n    }\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n\n\n    async crypto_generichash_update(state, message) {\n      this.sodium.crypto_generichash_update(state, await Util.toBuffer(message));\n      return state;\n    }\n    /**\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_generichash_final(state) {\n      let outputLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      const output = Buffer.alloc(outputLength);\n      this.sodium.crypto_generichash_final(state, output);\n      return output;\n    }\n    /**\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n      const subkey = Buffer.alloc(length, 0);\n      this.sodium.crypto_kdf_derive_from_key(subkey, subKeyId | 0, await Util.toBuffer(context), key.getBuffer());\n      return new CryptographyKey(subkey);\n    }\n    /**\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n\n\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n      const rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n      const tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n      this.sodium.crypto_kx_client_session_keys(rx, tx, clientPublicKey.getBuffer(), clientSecretKey.getBuffer(), serverPublicKey.getBuffer());\n      return [new CryptographyKey(rx), new CryptographyKey(tx)];\n    }\n    /**\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n\n\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n      const rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n      const tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n      this.sodium.crypto_kx_server_session_keys(rx, tx, serverPublicKey.getBuffer(), serverSecretKey.getBuffer(), clientPublicKey.getBuffer());\n      return [new CryptographyKey(rx), new CryptographyKey(tx)];\n    }\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_onetimeauth(message, key) {\n      const output = Buffer.alloc(16);\n      this.sodium.crypto_onetimeauth(output, await Util.toBuffer(message), key.getBuffer());\n      return output;\n    }\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_onetimeauth_verify(message, key, tag) {\n      return this.sodium.crypto_onetimeauth_verify(tag, await Util.toBuffer(message), key.getBuffer());\n    }\n    /**\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number} algorithm\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm) {\n      const hashed = Buffer.alloc(length, 0);\n      const bufPass = await Util.toBuffer(password);\n      const bufSalt = await Util.toBuffer(salt);\n      await new Promise((resolve, reject) => {\n        this.sodium.crypto_pwhash_async(hashed, bufPass, bufSalt, opslimit, memlimit, algorithm, (e, res) => {\n          if (e) return reject(e);\n          return resolve(res);\n        });\n      });\n      return hashed;\n    }\n    /**\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n\n\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n      const hashed = Buffer.alloc(128, 0);\n      const bufPass = await Util.toBuffer(password);\n      await new Promise((resolve, reject) => {\n        this.sodium.crypto_pwhash_str_async(hashed, bufPass, opslimit, memlimit, (e, res) => {\n          if (e) return reject(e);\n          return resolve(res);\n        });\n      });\n      return hashed.toString();\n    }\n    /**\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_pwhash_str_verify(password, hash) {\n      const allocated = Buffer.alloc(128, 0);\n      (await Util.toBuffer(hash)).copy(allocated, 0, 0);\n      const bufPass = await Util.toBuffer(password);\n      return new Promise((resolve, reject) => {\n        this.sodium.crypto_pwhash_str_verify_async(allocated, bufPass, (e, res) => {\n          if (e) return reject(e);\n          return resolve(res);\n        });\n      });\n    }\n    /**\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n\n\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n      const allocated = Buffer.alloc(128, 0);\n      (await Util.toBuffer(hash)).copy(allocated, 0, 0);\n      return this.sodium.crypto_pwhash_str_needs_rehash(allocated, opslimit, memlimit);\n    }\n    /**\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_scalarmult(secretKey, publicKey) {\n      const shared = Buffer.alloc(32);\n      this.sodium.crypto_scalarmult(shared, secretKey.getBuffer(), publicKey.getBuffer());\n      return new CryptographyKey(await Util.toBuffer(shared));\n    }\n    /**\n     *\n     * @param {CryptographyKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_scalarmult_base(secretKey) {\n      const buf = Buffer.alloc(32);\n      this.sodium.crypto_scalarmult_base(buf, secretKey.getBuffer());\n      return buf;\n    }\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretbox(plaintext, nonce, key) {\n      const encrypted = Buffer.alloc(plaintext.length + 16);\n      this.sodium.crypto_secretbox_easy(encrypted, await Util.toBuffer(plaintext), nonce, key.getBuffer());\n      return encrypted;\n    }\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_shorthash(message, key) {\n      const output = Buffer.alloc(8);\n      this.sodium.crypto_shorthash(output, await Util.toBuffer(message), key.getBuffer());\n      return output;\n    }\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n      const decrypted = Buffer.alloc(ciphertext.length - 16);\n\n      if (!this.sodium.crypto_secretbox_open_easy(decrypted, ciphertext, nonce, key.getBuffer())) {\n        throw new SodiumError('Decryption failure');\n      }\n\n      return decrypted;\n    }\n    /**\n     * @param {CryptographyKey} key\n     * @return {Promise<array>} [state, header]\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n      const state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n      const header = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES);\n      this.sodium.randombytes_buf(header);\n      this.sodium.crypto_secretstream_xchacha20poly1305_init_push(state, header, key.getBuffer());\n      return [state, header];\n    }\n    /**\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>} Returns the opaque state object\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_init_pull(header, key) {\n      if (header.length !== this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES) {\n        throw new SodiumError(\"Header must be \".concat(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES, \" bytes long\"));\n      }\n\n      const state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n      this.sodium.crypto_secretstream_xchacha20poly1305_init_pull(state, header, key.getBuffer());\n      return state;\n    }\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_push(state, message) {\n      let ad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let tag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      const ciphertext = Buffer.alloc(message.length + this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n      this.sodium.crypto_secretstream_xchacha20poly1305_push(state, ciphertext, await Util.toBuffer(message), ad.length > 0 ? await Util.toBuffer(ad) : null, Buffer.from([tag]));\n      return ciphertext;\n    }\n    /**\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext) {\n      let ad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let tag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      if (ciphertext.length < this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES) {\n        throw new SodiumError('Invalid ciphertext size');\n      }\n\n      const plaintext = Buffer.alloc(ciphertext.length - this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n      this.sodium.crypto_secretstream_xchacha20poly1305_pull(state, plaintext, Buffer.from([tag]), ciphertext, ad.length > 0 ? await Util.toBuffer(ad) : null);\n      return plaintext;\n    }\n    /**\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n\n\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n      this.sodium.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign(message, secretKey) {\n      const signed = Buffer.alloc(message.length + 64);\n      this.sodium.crypto_sign(signed, await Util.toBuffer(message), secretKey.getBuffer());\n      return signed;\n    }\n    /**\n     * @param {Buffer} signedMessage,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_open(signedMessage, publicKey) {\n      const original = Buffer.alloc(signedMessage.length - 64);\n      this.sodium.crypto_sign_open(original, await Util.toBuffer(signedMessage), publicKey.getBuffer());\n      return original;\n    }\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_detached(message, secretKey) {\n      const signature = Buffer.alloc(64);\n      this.sodium.crypto_sign_detached(signature, await Util.toBuffer(message), secretKey.getBuffer());\n      return signature;\n    }\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n      return this.sodium.crypto_sign_verify_detached(signature, await Util.toBuffer(message), publicKey.getBuffer());\n    }\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_sign_keypair() {\n      const sK = Buffer.alloc(64, 0);\n      const pK = Buffer.alloc(32, 0);\n      this.sodium.crypto_sign_keypair(pK, sK);\n      return new CryptographyKey(Buffer.concat([sK, pK]));\n    }\n    /**\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n\n\n    async crypto_sign_seed_keypair(seed) {\n      const sK = Buffer.alloc(64, 0);\n      const pK = Buffer.alloc(32, 0);\n      this.sodium.crypto_sign_seed_keypair(pK, sK, seed);\n      return new CryptographyKey(Buffer.concat([sK, pK]));\n    }\n    /**\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n      const xsk = Buffer.alloc(32);\n      this.sodium.crypto_sign_ed25519_sk_to_curve25519(xsk, sk.getBuffer());\n      return xsk;\n    }\n    /**\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n      const xpk = Buffer.alloc(32);\n      this.sodium.crypto_sign_ed25519_pk_to_curve25519(xpk, pk.getBuffer());\n      return xpk;\n    }\n    /**\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_stream(length, nonce, key) {\n      const output = Buffer.alloc(length);\n      this.sodium.crypto_stream(output, await Util.toBuffer(nonce), key.getBuffer());\n      return output;\n    }\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n\n\n    async crypto_stream_xor(plaintext, nonce, key) {\n      const output = Buffer.alloc(plaintext.length);\n      this.sodium.crypto_stream_xor(output, await Util.toBuffer(plaintext), await Util.toBuffer(nonce), key.getBuffer());\n      return output;\n    }\n    /**\n     * @param {number} number\n     * @return {Promise<Buffer>}\n     */\n\n\n    async randombytes_buf(number) {\n      let buf = Buffer.alloc(number);\n      this.sodium.randombytes_buf(buf);\n      return buf;\n    }\n    /**\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n\n\n    async randombytes_uniform(upperBound) {\n      return this.sodium.randombytes_uniform(upperBound);\n    }\n    /**\n     * @param {Uint8Array} val\n     * @param {Uint8Array} addv\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_add(val, addv) {\n      const buf = await Util.cloneBuffer(val);\n      this.sodium.sodium_add(buf, addv);\n      return buf;\n    }\n    /**\n     * @param {Buffer} input\n     * @return {Promise<string>}\n     */\n\n\n    async sodium_bin2hex(input) {\n      let str = \"\",\n          b,\n          c,\n          x;\n\n      for (let i = 0; i < input.length; i++) {\n        c = input[i] & 0xf;\n        b = input[i] >>> 4;\n        x = 87 + c + (c - 10 >> 8 & ~38) << 8 | 87 + b + (b - 10 >> 8 & ~38);\n        str += String.fromCharCode(x & 0xff) + String.fromCharCode(x >>> 8);\n      }\n\n      return str;\n    }\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n\n\n    async sodium_compare(b1, b2) {\n      return this.sodium.sodium_compare(b1, b2);\n    }\n    /**\n     * @param {Buffer|string} hex\n     * @param {string|null} ignore\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_hex2bin(hex) {\n      let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let bin_pos = 0,\n          hex_pos = 0,\n          c = 0,\n          c_acc = 0,\n          c_alpha0 = 0,\n          c_alpha = 0,\n          c_num0 = 0,\n          c_num = 0,\n          c_val = 0,\n          state = 0;\n      const bin = Buffer.alloc(hex.length >> 1, 0);\n\n      while (hex_pos < hex.length) {\n        c = hex.charCodeAt(hex_pos);\n        c_num = c ^ 48;\n        c_num0 = c_num - 10 >> 8;\n        c_alpha = (c & ~32) - 55;\n        c_alpha0 = (c_alpha - 10 ^ c_alpha - 16) >> 8;\n\n        if ((c_num0 | c_alpha0) === 0) {\n          if (ignore && state === 0 && ignore.indexOf(c) >= 0) {\n            hex_pos++;\n            continue;\n          }\n\n          break;\n        }\n\n        c_val = c_num0 & c_num | c_alpha0 & c_alpha;\n\n        if (state === 0) {\n          c_acc = c_val * 16;\n        } else {\n          bin[bin_pos++] = c_acc | c_val;\n        }\n\n        state = ~state;\n        hex_pos++;\n      }\n\n      return bin;\n    }\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_increment(buf) {\n      return this.sodium.sodium_increment(buf);\n    }\n    /**\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_is_zero(buf, len) {\n      return this.sodium.sodium_is_zero(buf, len);\n    }\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n\n\n    async sodium_memcmp(b1, b2) {\n      return this.sodium.sodium_memcmp(b1, b2);\n    }\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n\n\n    async sodium_memzero(buf) {\n      this.sodium.sodium_memzero(buf);\n    }\n    /**\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_pad(buf, blockSize) {\n      buf = await Util.toBuffer(buf);\n      let length = buf.length + buf.length % blockSize;\n\n      if (length < blockSize) {\n        length += blockSize;\n      }\n\n      const padded = Buffer.alloc(length + 100);\n      buf.copy(padded, 0, 0);\n      const sliceto = this.sodium.sodium_pad(padded, buf.length, blockSize);\n      return padded.slice(0, sliceto);\n    }\n    /**\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n\n\n    async sodium_unpad(buf, blockSize) {\n      const outlen = this.sodium.sodium_unpad(buf, buf.length, blockSize);\n      return buf.slice(0, outlen);\n    }\n\n  };\n}.call(this, module);","map":{"version":3,"sources":["imports/client/sodium-plus/lib/backend/sodiumnative.js"],"names":["loaded","_sodium","require","e","Backend","CryptographyKey","SodiumError","Util","toBuffer","Buffer","module","exports","SodiumNativeBackend","constructor","lib","sodium","backendName","init","crypto_aead_xchacha20poly1305_ietf_decrypt","ciphertext","assocData","nonce","key","plaintext","alloc","length","getBuffer","crypto_aead_xchacha20poly1305_ietf_encrypt","crypto_auth","message","output","crypto_auth_verify","mac","crypto_box","sk","pk","crypto_box_easy","crypto_box_open","success","crypto_box_open_easy","crypto_box_seal","crypto_box_seal_open","crypto_box_keypair","sK","pK","concat","crypto_generichash","outputLength","hash","crypto_generichash_init","state","CRYPTO_GENERICHASH_STATEBYTES","crypto_generichash_update","crypto_generichash_final","crypto_kdf_derive_from_key","subKeyId","context","subkey","crypto_kx_client_session_keys","clientPublicKey","clientSecretKey","serverPublicKey","rx","CRYPTO_KX_SESSIONKEYBYTES","tx","crypto_kx_server_session_keys","serverSecretKey","crypto_onetimeauth","crypto_onetimeauth_verify","tag","crypto_pwhash","password","salt","opslimit","memlimit","algorithm","hashed","bufPass","bufSalt","Promise","resolve","reject","crypto_pwhash_async","res","crypto_pwhash_str","crypto_pwhash_str_async","toString","crypto_pwhash_str_verify","allocated","copy","crypto_pwhash_str_verify_async","crypto_pwhash_str_needs_rehash","crypto_scalarmult","secretKey","publicKey","shared","crypto_scalarmult_base","buf","crypto_secretbox","encrypted","crypto_secretbox_easy","crypto_shorthash","crypto_secretbox_open","decrypted","crypto_secretbox_open_easy","crypto_secretstream_xchacha20poly1305_init_push","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES","header","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES","randombytes_buf","crypto_secretstream_xchacha20poly1305_init_pull","crypto_secretstream_xchacha20poly1305_push","ad","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES","from","crypto_secretstream_xchacha20poly1305_pull","crypto_secretstream_xchacha20poly1305_rekey","crypto_sign","signed","crypto_sign_open","signedMessage","original","crypto_sign_detached","signature","crypto_sign_verify_detached","crypto_sign_keypair","crypto_sign_seed_keypair","seed","crypto_sign_ed25519_sk_to_curve25519","xsk","crypto_sign_ed25519_pk_to_curve25519","xpk","crypto_stream","crypto_stream_xor","number","randombytes_uniform","upperBound","sodium_add","val","addv","cloneBuffer","sodium_bin2hex","input","str","b","c","x","i","String","fromCharCode","sodium_compare","b1","b2","sodium_hex2bin","hex","ignore","bin_pos","hex_pos","c_acc","c_alpha0","c_alpha","c_num0","c_num","c_val","bin","charCodeAt","indexOf","sodium_increment","sodium_is_zero","len","sodium_memcmp","sodium_memzero","sodium_pad","blockSize","padded","sliceto","slice","sodium_unpad","outlen"],"mappings":"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","sourcesContent":["let loaded = false;\nlet _sodium;\n/* istanbul ignore next */\ntry {\n    _sodium = require('sodium-native');\n    loaded = true;\n} catch (e) {\n    _sodium = {};\n}\nconst Backend = require('../backend');\nconst CryptographyKey = require('../cryptography-key');\nconst SodiumError = require('../sodium-error');\nconst Util = require('../util');\nconst toBuffer = require('typedarray-to-buffer');\n/* istanbul ignore if */\nif (typeof (Buffer) === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n}\n\n/* istanbul ignore next */\nmodule.exports = class SodiumNativeBackend extends Backend {\n    constructor(lib) {\n        super(lib);\n        this.sodium = lib;\n        this.backendName = 'SodiumNativeBackend';\n    }\n\n    static async init() {\n        if (!loaded) {\n            throw new SodiumError('sodium-native not installed');\n        }\n        return new SodiumNativeBackend(_sodium);\n    }\n\n    /**\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, assocData, nonce, key) {\n        const plaintext = Buffer.alloc(ciphertext.length - 16, 0);\n        this.sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            plaintext,\n            null,\n            await Util.toBuffer(ciphertext),\n            await Util.toBuffer(assocData),\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return plaintext;\n    }\n\n    /**\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} assocData\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, assocData, nonce, key) {\n        const ciphertext = Buffer.alloc(plaintext.length + 16, 0);\n        this.sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            ciphertext,\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(assocData),\n            null,\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return ciphertext;\n    }\n\n    /**\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<buffer>}\n     */\n    async crypto_auth(message, key) {\n        const output = Buffer.alloc(32);\n        this.sodium.crypto_auth(\n            output,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n        return toBuffer(output);\n    }\n\n    /**\n     * @param {Buffer} mac\n     * @param {String|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<boolean>}\n     */\n    async crypto_auth_verify(mac, message, key) {\n        return this.sodium.crypto_auth_verify(\n            mac,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n    }\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n    async crypto_box(plaintext, nonce, sk, pk) {\n        const ciphertext = Buffer.alloc(plaintext.length + 16);\n        this.sodium.crypto_box_easy(\n            ciphertext,\n            await Util.toBuffer(plaintext),\n            nonce,\n            pk.getBuffer(),\n            sk.getBuffer()\n        );\n        return Util.toBuffer(ciphertext);\n    }\n\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} sk\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_open(ciphertext, nonce, sk, pk) {\n        const plaintext = Buffer.alloc(ciphertext.length - 16);\n        const success = this.sodium.crypto_box_open_easy(\n            plaintext,\n            ciphertext,\n            nonce,\n            pk.getBuffer(),\n            sk.getBuffer()\n        );\n        if (!success) {\n            throw new SodiumError('Decryption failed');\n        }\n        return Util.toBuffer(plaintext);\n    }\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {CryptographyKey} pk\n     * @return {Promise<Buffer>}\n     *\n     */\n    async crypto_box_seal(plaintext, pk) {\n        const ciphertext = Buffer.alloc(plaintext.length + 48);\n        this.sodium.crypto_box_seal(\n            ciphertext,\n            await Util.toBuffer(plaintext),\n            pk.getBuffer()\n        );\n        return Util.toBuffer(ciphertext);\n    }\n\n    /**\n     * @param {Buffer} ciphertext\n     * @param {CryptographyKey} pk\n     * @param {CryptographyKey} sk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal_open(ciphertext, pk, sk) {\n        const plaintext = Buffer.alloc(ciphertext.length - 48);\n        const success = this.sodium.crypto_box_seal_open(\n            plaintext,\n            await Util.toBuffer(ciphertext),\n            pk.getBuffer(),\n            sk.getBuffer()\n        );\n        if (!success) {\n            throw new SodiumError('Decryption failed');\n        }\n        return Util.toBuffer(plaintext);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair() {\n        const sK = Buffer.alloc(32, 0);\n        const pK = Buffer.alloc(32, 0);\n        this.sodium.crypto_box_keypair(sK, pK);\n        return new CryptographyKey(\n            Buffer.concat([pK, sK])\n        );\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash(message, key = null, outputLength = 32) {\n        const hash = Buffer.alloc(outputLength);\n        if (key) {\n            this.sodium.crypto_generichash(hash, await Util.toBuffer(message), key.getBuffer());\n        } else {\n            this.sodium.crypto_generichash(hash, await Util.toBuffer(message));\n        }\n        return hash;\n    }\n\n    /**\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_init(key = null, outputLength = 32) {\n        const state = Buffer.alloc(this.CRYPTO_GENERICHASH_STATEBYTES);\n        if (key) {\n            this.sodium.crypto_generichash_init(state, key.getBuffer(), outputLength);\n        } else {\n            this.sodium.crypto_generichash_init(state, null, outputLength);\n        }\n        return state;\n    }\n\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    async crypto_generichash_update(state, message) {\n        this.sodium.crypto_generichash_update(state, await Util.toBuffer(message));\n        return state;\n    }\n\n    /**\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_final(state, outputLength = 32) {\n        const output = Buffer.alloc(outputLength);\n        this.sodium.crypto_generichash_final(state, output);\n        return output;\n    }\n\n    /**\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        const subkey = Buffer.alloc(length, 0);\n        this.sodium.crypto_kdf_derive_from_key(\n            subkey,\n            subKeyId | 0,\n            await Util.toBuffer(context),\n            key.getBuffer()\n        );\n        return new CryptographyKey(subkey);\n    }\n\n    /**\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        const rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        const tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        this.sodium.crypto_kx_client_session_keys(\n            rx,\n            tx,\n            clientPublicKey.getBuffer(),\n            clientSecretKey.getBuffer(),\n            serverPublicKey.getBuffer(),\n        );\n        return [\n            new CryptographyKey(rx),\n            new CryptographyKey(tx)\n        ];\n    }\n\n    /**\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        const rx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        const tx = Buffer.alloc(this.CRYPTO_KX_SESSIONKEYBYTES);\n        this.sodium.crypto_kx_server_session_keys(\n            rx,\n            tx,\n            serverPublicKey.getBuffer(),\n            serverSecretKey.getBuffer(),\n            clientPublicKey.getBuffer(),\n        );\n        return [\n            new CryptographyKey(rx),\n            new CryptographyKey(tx)\n        ];\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_onetimeauth(message, key) {\n        const output = Buffer.alloc(16);\n        this.sodium.crypto_onetimeauth(\n            output,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    async crypto_onetimeauth_verify(message, key, tag) {\n        return this.sodium.crypto_onetimeauth_verify(\n            tag,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n    }\n\n    /**\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number} algorithm\n     * @return {Promise<Buffer>}\n     */\n    async crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm) {\n        const hashed = Buffer.alloc(length, 0);\n        const bufPass = await Util.toBuffer(password);\n        const bufSalt = await Util.toBuffer(salt);\n        await new Promise((resolve, reject) => {\n            this.sodium.crypto_pwhash_async(\n                hashed,\n                bufPass,\n                bufSalt,\n                opslimit,\n                memlimit,\n                algorithm,\n                (e, res) => {\n                    if (e) return reject(e);\n                    return resolve(res);\n                }\n            );\n        });\n        return hashed;\n    }\n\n    /**\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n        const hashed = Buffer.alloc(128, 0);\n        const bufPass = await Util.toBuffer(password);\n        await new Promise((resolve, reject) => {\n            this.sodium.crypto_pwhash_str_async(\n                hashed,\n                bufPass,\n                opslimit,\n                memlimit,\n                (e, res) => {\n                    if (e) return reject(e);\n                    return resolve(res);\n                }\n            );\n        });\n        return hashed.toString();\n\n    }\n\n    /**\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_verify(password, hash) {\n        const allocated = Buffer.alloc(128, 0);\n        (await Util.toBuffer(hash)).copy(allocated, 0, 0);\n        const bufPass = await Util.toBuffer(password);\n        return new Promise((resolve, reject) => {\n            this.sodium.crypto_pwhash_str_verify_async(\n                allocated,\n                bufPass,\n                (e, res) => {\n                    if (e) return reject(e);\n                    return resolve(res);\n                }\n            );\n        });\n    }\n\n    /**\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        const allocated = Buffer.alloc(128, 0);\n        (await Util.toBuffer(hash)).copy(allocated, 0, 0);\n        return this.sodium.crypto_pwhash_str_needs_rehash(\n            allocated,\n            opslimit,\n            memlimit\n        );\n    }\n\n    /**\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_scalarmult(secretKey, publicKey) {\n        const shared = Buffer.alloc(32);\n        this.sodium.crypto_scalarmult(shared, secretKey.getBuffer(), publicKey.getBuffer());\n        return new CryptographyKey(\n            await Util.toBuffer(shared)\n        );\n    }\n\n    /**\n     *\n     * @param {CryptographyKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_scalarmult_base(secretKey) {\n        const buf = Buffer.alloc(32);\n        this.sodium.crypto_scalarmult_base(buf, secretKey.getBuffer());\n        return buf;\n    }\n\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox(plaintext, nonce, key) {\n        const encrypted = Buffer.alloc(plaintext.length + 16);\n        this.sodium.crypto_secretbox_easy(\n            encrypted,\n            await Util.toBuffer(plaintext),\n            nonce,\n            key.getBuffer()\n        );\n        return encrypted;\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_shorthash(message, key) {\n        const output = Buffer.alloc(8);\n        this.sodium.crypto_shorthash(\n            output,\n            await Util.toBuffer(message),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n        const decrypted = Buffer.alloc(ciphertext.length - 16);\n        if (!this.sodium.crypto_secretbox_open_easy(\n            decrypted,\n            ciphertext,\n            nonce,\n            key.getBuffer()\n        )) {\n            throw new SodiumError('Decryption failure');\n        }\n        return decrypted;\n    }\n\n    /**\n     * @param {CryptographyKey} key\n     * @return {Promise<array>} [state, header]\n     */\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n        const state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n        const header = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES);\n        this.sodium.randombytes_buf(header);\n        this.sodium.crypto_secretstream_xchacha20poly1305_init_push(state, header, key.getBuffer());\n        return [state, header];\n    }\n\n    /**\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>} Returns the opaque state object\n     */\n    async crypto_secretstream_xchacha20poly1305_init_pull(header, key) {\n        if (header.length !== this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES) {\n            throw new SodiumError(`Header must be ${this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_HEADERBYTES} bytes long`);\n        }\n        const state = Buffer.alloc(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_STATEBYTES);\n        this.sodium.crypto_secretstream_xchacha20poly1305_init_pull(state, header, key.getBuffer());\n        return state;\n    }\n\n    /**\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_push(state, message, ad = '', tag = 0) {\n        const ciphertext = Buffer.alloc(message.length + this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n        this.sodium.crypto_secretstream_xchacha20poly1305_push(\n            state,\n            ciphertext,\n            await Util.toBuffer(message),\n            ad.length > 0 ? (await Util.toBuffer(ad)) : null,\n            Buffer.from([tag])\n        );\n        return ciphertext;\n    }\n\n    /**\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad = '', tag = 0) {\n        if (ciphertext.length < this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES) {\n            throw new SodiumError('Invalid ciphertext size');\n        }\n        const plaintext = Buffer.alloc(ciphertext.length - this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_ABYTES);\n        this.sodium.crypto_secretstream_xchacha20poly1305_pull(\n            state,\n            plaintext,\n            Buffer.from([tag]),\n            ciphertext,\n            ad.length > 0 ? (await Util.toBuffer(ad)) : null\n        );\n        return plaintext;\n    }\n\n    /**\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n        this.sodium.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign(message, secretKey) {\n        const signed = Buffer.alloc(message.length + 64);\n        this.sodium.crypto_sign(signed, await Util.toBuffer(message), secretKey.getBuffer());\n        return signed;\n    }\n\n    /**\n     * @param {Buffer} signedMessage,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_open(signedMessage, publicKey) {\n        const original = Buffer.alloc(signedMessage.length - 64);\n        this.sodium.crypto_sign_open(original, await Util.toBuffer(signedMessage), publicKey.getBuffer());\n        return original;\n    }\n\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_detached(message, secretKey) {\n        const signature = Buffer.alloc(64);\n        this.sodium.crypto_sign_detached(signature, await Util.toBuffer(message), secretKey.getBuffer());\n        return signature;\n    }\n\n    /**\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n        return this.sodium.crypto_sign_verify_detached(\n            signature,\n            await Util.toBuffer(message),\n            publicKey.getBuffer()\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_keypair() {\n        const sK = Buffer.alloc(64, 0);\n        const pK = Buffer.alloc(32, 0);\n        this.sodium.crypto_sign_keypair(pK, sK);\n        return new CryptographyKey(\n            Buffer.concat([sK, pK])\n        );\n    }\n\n    /**\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_seed_keypair(seed) {\n        const sK = Buffer.alloc(64, 0);\n        const pK = Buffer.alloc(32, 0);\n        this.sodium.crypto_sign_seed_keypair(pK, sK, seed);\n        return new CryptographyKey(\n            Buffer.concat([sK, pK])\n        );\n    }\n\n    /**\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n        const xsk = Buffer.alloc(32);\n        this.sodium.crypto_sign_ed25519_sk_to_curve25519(xsk, sk.getBuffer());\n        return xsk;\n    }\n\n    /**\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n        const xpk = Buffer.alloc(32);\n        this.sodium.crypto_sign_ed25519_pk_to_curve25519(xpk, pk.getBuffer());\n        return xpk;\n    }\n\n    /**\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream(length, nonce, key) {\n        const output = Buffer.alloc(length);\n        this.sodium.crypto_stream(\n            output,\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream_xor(plaintext, nonce, key) {\n        const output = Buffer.alloc(plaintext.length);\n        this.sodium.crypto_stream_xor(\n            output,\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(nonce),\n            key.getBuffer()\n        );\n        return output;\n    }\n\n    /**\n     * @param {number} number\n     * @return {Promise<Buffer>}\n     */\n    async randombytes_buf(number) {\n        let buf = Buffer.alloc(number);\n        this.sodium.randombytes_buf(buf);\n        return buf;\n    }\n\n    /**\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    async randombytes_uniform(upperBound) {\n        return this.sodium.randombytes_uniform(upperBound);\n    }\n\n    /**\n     * @param {Uint8Array} val\n     * @param {Uint8Array} addv\n     * @return {Promise<Buffer>}\n     */\n    async sodium_add(val, addv) {\n        const buf = await Util.cloneBuffer(val);\n        this.sodium.sodium_add(buf, addv);\n        return buf;\n    }\n\n    /**\n     * @param {Buffer} input\n     * @return {Promise<string>}\n     */\n    async sodium_bin2hex(input) {\n        let str = \"\", b, c, x;\n        for (let i = 0; i < input.length; i++) {\n            c = input[i] & 0xf;\n            b = input[i] >>> 4;\n            x =\n                ((87 + c + (((c - 10) >> 8) & ~38)) << 8) |\n                (87 + b + (((b - 10) >> 8) & ~38));\n            str += String.fromCharCode(x & 0xff) + String.fromCharCode(x >>> 8);\n        }\n        return str;\n    }\n\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    async sodium_compare(b1, b2) {\n        return this.sodium.sodium_compare(b1, b2);\n    }\n\n    /**\n     * @param {Buffer|string} hex\n     * @param {string|null} ignore\n     * @return {Promise<Buffer>}\n     */\n    async sodium_hex2bin(hex, ignore = null) {\n        let bin_pos = 0,\n            hex_pos = 0,\n            c = 0,\n            c_acc = 0,\n            c_alpha0 = 0,\n            c_alpha = 0,\n            c_num0 = 0,\n            c_num = 0,\n            c_val = 0,\n            state = 0;\n        const bin = Buffer.alloc(hex.length >> 1, 0);\n\n        while (hex_pos < hex.length) {\n            c = hex.charCodeAt(hex_pos);\n            c_num = c ^ 48;\n            c_num0 = (c_num - 10) >> 8;\n            c_alpha = (c & ~32) - 55;\n            c_alpha0 = ((c_alpha - 10) ^ (c_alpha - 16)) >> 8;\n            if ((c_num0 | c_alpha0) === 0) {\n                if (ignore && state === 0 && ignore.indexOf(c) >= 0) {\n                    hex_pos++;\n                    continue;\n                }\n                break;\n            }\n            c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);\n            if (state === 0) {\n                c_acc = c_val * 16;\n            } else {\n                bin[bin_pos++] = c_acc | c_val;\n            }\n            state = ~state;\n            hex_pos++;\n        }\n        return bin;\n    }\n\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    async sodium_increment(buf) {\n        return this.sodium.sodium_increment(buf);\n    }\n\n    /**\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    async sodium_is_zero(buf, len) {\n        return this.sodium.sodium_is_zero(buf, len);\n    }\n\n    /**\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    async sodium_memcmp(b1, b2) {\n        return this.sodium.sodium_memcmp(b1, b2);\n    }\n\n    /**\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    async sodium_memzero(buf) {\n        this.sodium.sodium_memzero(buf);\n    }\n\n    /**\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_pad(buf, blockSize) {\n        buf = await Util.toBuffer(buf);\n        let length = buf.length + (buf.length % blockSize);\n        if (length < blockSize) {\n            length += blockSize;\n        }\n        const padded = Buffer.alloc(length + 100);\n        buf.copy(padded, 0, 0);\n        const sliceto = this.sodium.sodium_pad(padded, buf.length, blockSize);\n        return padded.slice(0, sliceto);\n    }\n\n    /**\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_unpad(buf, blockSize) {\n        const outlen = this.sodium.sodium_unpad(buf, buf.length, blockSize);\n        return buf.slice(0, outlen);\n    }\n};\n"]},"sourceType":"module","hash":"76a02cf3c705a857e9ee389293c0330de65068a9"}
