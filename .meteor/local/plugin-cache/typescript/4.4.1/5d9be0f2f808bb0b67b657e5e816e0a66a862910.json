{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/client/lib/voip/VoIPUser.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"client/lib/voip/VoIPUser.ts","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/client/lib/voip/VoIPUser.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/VoIPUser.ts","sourceRoot":"","sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protol details.\n */\n\nimport { Emitter } from '@rocket.chat/emitter';\nimport {\n\tUserAgent,\n\tUserAgentOptions,\n\t// UserAgentDelegate,\n\tInvitation,\n\tInvitationAcceptOptions,\n\tSession,\n\tSessionState,\n\tRegisterer,\n\tSessionInviteOptions,\n\tRequestPendingError,\n} from 'sip.js';\nimport { OutgoingByeRequest, OutgoingRequestDelegate, URI } from 'sip.js/lib/core';\nimport { SessionDescriptionHandler, SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\n\nimport { IQueueMembershipSubscription } from '../../../definition/IVoipExtension';\nimport { CallStates } from '../../../definition/voip/CallStates';\nimport { ICallerInfo } from '../../../definition/voip/ICallerInfo';\nimport { Operation } from '../../../definition/voip/Operations';\nimport { UserState } from '../../../definition/voip/UserState';\nimport { IMediaStreamRenderer, VoIPUserConfiguration } from '../../../definition/voip/VoIPUserConfiguration';\nimport { VoIpCallerInfo, IState } from '../../../definition/voip/VoIpCallerInfo';\nimport { VoipEvents } from '../../../definition/voip/VoipEvents';\nimport { WorkflowTypes } from '../../../definition/voip/WorkflowTypes';\nimport { toggleMediaStreamTracks } from './Helper';\nimport { QueueAggregator } from './QueueAggregator';\nimport Stream from './Stream';\n\nexport class VoIPUser extends Emitter<VoipEvents> implements OutgoingRequestDelegate {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate session: Session | undefined;\n\n\tprivate remoteStream: Stream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _callState: CallStates = 'IDLE';\n\n\tprivate _callerInfo: ICallerInfo | undefined;\n\n\tprivate _userState: UserState = UserState.IDLE;\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD') {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\tprivate _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.on('connected', () => {\n\t\t\tthis.state.isReady = true;\n\t\t});\n\n\t\tthis.on('connectionerror', () => {\n\t\t\tthis.state.isReady = false;\n\t\t});\n\t}\n\n\t/* UserAgentDelegate methods end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprivate setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis.emit('callestablished');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream undefiend.');\n\t\t}\n\n\t\tthis.remoteStream = new Stream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\t/* UserAgentDelegate methods begin */\n\t\t\t\tonConnect: (): void => {\n\t\t\t\t\tthis._callState = 'SERVER_CONNECTED';\n\n\t\t\t\t\tthis.emit('connected');\n\t\t\t\t\t/**\n\t\t\t\t\t * There is an interesting problem that happens with Asterisk.\n\t\t\t\t\t * After websocket connection succeeds and if there is no SIP\n\t\t\t\t\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t\t\t\t\t *\n\t\t\t\t\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t\t\t\t\t * This problem could be solved in multiple ways. One is that\n\t\t\t\t\t * whenever disconnect happens make sure that the socket is connected back using\n\t\t\t\t\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t\t\t\t\t * every 30 seconds till we send register message.\n\t\t\t\t\t *\n\t\t\t\t\t * Another approach is to send SIP OPTIONS just to tell server that\n\t\t\t\t\t * there is a UA using this socket. This is implemented below\n\t\t\t\t\t **/\n\n\t\t\t\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\t\t\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\t\t\t\tif (outgoingMessage) {\n\t\t\t\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.userAgent) {\n\t\t\t\t\t\tthis.registerer = new Registerer(this.userAgent);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonDisconnect: (error: any): void => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.emit('connectionerror', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\tawait this.userAgent.start();\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Somethingis wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wront');\n\t}\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'OFFER_RECEIVED') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis.userAgent?.stop();\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/client/lib/voip/VoIPUser.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/voip/VoIPUser.ts"}},"code":"module.export({\n  VoIPUser: () => VoIPUser\n});\nlet Emitter;\nmodule.link(\"@rocket.chat/emitter\", {\n  Emitter(v) {\n    Emitter = v;\n  }\n\n}, 0);\nlet UserAgent, Invitation, SessionState, Registerer, RequestPendingError;\nmodule.link(\"sip.js\", {\n  UserAgent(v) {\n    UserAgent = v;\n  },\n\n  Invitation(v) {\n    Invitation = v;\n  },\n\n  SessionState(v) {\n    SessionState = v;\n  },\n\n  Registerer(v) {\n    Registerer = v;\n  },\n\n  RequestPendingError(v) {\n    RequestPendingError = v;\n  }\n\n}, 1);\nlet URI;\nmodule.link(\"sip.js/lib/core\", {\n  URI(v) {\n    URI = v;\n  }\n\n}, 2);\nlet SessionDescriptionHandler;\nmodule.link(\"sip.js/lib/platform/web\", {\n  SessionDescriptionHandler(v) {\n    SessionDescriptionHandler = v;\n  }\n\n}, 3);\nlet Operation;\nmodule.link(\"../../../definition/voip/Operations\", {\n  Operation(v) {\n    Operation = v;\n  }\n\n}, 4);\nlet UserState;\nmodule.link(\"../../../definition/voip/UserState\", {\n  UserState(v) {\n    UserState = v;\n  }\n\n}, 5);\nlet WorkflowTypes;\nmodule.link(\"../../../definition/voip/WorkflowTypes\", {\n  WorkflowTypes(v) {\n    WorkflowTypes = v;\n  }\n\n}, 6);\nlet toggleMediaStreamTracks;\nmodule.link(\"./Helper\", {\n  toggleMediaStreamTracks(v) {\n    toggleMediaStreamTracks = v;\n  }\n\n}, 7);\nlet QueueAggregator;\nmodule.link(\"./QueueAggregator\", {\n  QueueAggregator(v) {\n    QueueAggregator = v;\n  }\n\n}, 8);\nlet Stream;\nmodule.link(\"./Stream\", {\n  default(v) {\n    Stream = v;\n  }\n\n}, 9);\n\nclass VoIPUser extends Emitter {\n  get callState() {\n    return this._callState;\n  }\n\n  get callerInfo() {\n    if (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD') {\n      if (!this._callerInfo) {\n        throw new Error('[VoIPUser callerInfo] invalid state');\n      }\n\n      return {\n        state: this.callState,\n        caller: this._callerInfo,\n        userState: this._userState\n      };\n    }\n\n    return {\n      state: this.callState,\n      userState: this._userState\n    };\n  }\n\n  get operationInProgress() {\n    return this._opInProgress;\n  }\n\n  get userState() {\n    return this._userState;\n  }\n  /* Media Stream functions begin */\n\n  /** The local media stream. Undefined if call not answered. */\n\n\n  get localMediaStream() {\n    var _this$session;\n\n    const sdh = (_this$session = this.session) === null || _this$session === void 0 ? void 0 : _this$session.sessionDescriptionHandler;\n\n    if (!sdh) {\n      return undefined;\n    }\n\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n    }\n\n    return sdh.localMediaStream;\n  }\n  /* Media Stream functions end */\n\n\n  constructor(config, mediaRenderer) {\n    super();\n    this.config = void 0;\n    this.state = {\n      isReady: false,\n      enableVideo: false\n    };\n    this.session = void 0;\n    this.remoteStream = void 0;\n    this.userAgentOptions = {};\n    this.userAgent = void 0;\n    this.registerer = void 0;\n    this.mediaStreamRendered = void 0;\n    this._callState = 'IDLE';\n    this._callerInfo = void 0;\n    this._userState = UserState.IDLE;\n    this._held = false;\n    this.mode = void 0;\n    this.queueInfo = void 0;\n    this._opInProgress = Operation.OP_NONE;\n    this.config = config;\n    this.mediaStreamRendered = mediaRenderer;\n    this.on('connected', () => {\n      this.state.isReady = true;\n    });\n    this.on('connectionerror', () => {\n      this.state.isReady = false;\n    });\n  }\n  /* UserAgentDelegate methods end */\n\n  /* OutgoingRequestDelegate methods begin */\n\n\n  onAccept() {\n    if (this._opInProgress === Operation.OP_REGISTER) {\n      this._callState = 'REGISTERED';\n      this.emit('registered');\n      this.emit('stateChanged');\n    }\n\n    if (this._opInProgress === Operation.OP_UNREGISTER) {\n      this._callState = 'UNREGISTERED';\n      this.emit('unregistered');\n      this.emit('stateChanged');\n    }\n  }\n\n  onReject(error) {\n    if (this._opInProgress === Operation.OP_REGISTER) {\n      this.emit('registrationerror', error);\n    }\n\n    if (this._opInProgress === Operation.OP_UNREGISTER) {\n      this.emit('unregistrationerror', error);\n    }\n  }\n  /* OutgoingRequestDelegate methods end */\n\n\n  async handleIncomingCall(invitation) {\n    if (this.callState === 'REGISTERED') {\n      this._opInProgress = Operation.OP_PROCESS_INVITE;\n      this._callState = 'OFFER_RECEIVED';\n      this._userState = UserState.UAS;\n      this.session = invitation;\n      this.setupSessionEventHandlers(invitation);\n      const callerInfo = {\n        callerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n        callerName: invitation.remoteIdentity.displayName,\n        host: invitation.remoteIdentity.uri.host\n      };\n      this._callerInfo = callerInfo;\n      this.emit('incomingcall', callerInfo);\n      this.emit('stateChanged');\n      return;\n    }\n\n    await invitation.reject();\n  }\n  /**\n   * Sets up an listener handler for handling session's state change\n   * @remarks\n   * Called for setting up various state listeners. These listeners will\n   * decide the next action to be taken when the session state changes.\n   * e.g when session.state changes from |Establishing| to |Established|\n   * one must set up local and remote media rendering.\n   *\n   * This class handles such session state changes and takes necessary actions.\n   */\n\n\n  setupSessionEventHandlers(session) {\n    var _this$session2;\n\n    (_this$session2 = this.session) === null || _this$session2 === void 0 ? void 0 : _this$session2.stateChange.addListener(state => {\n      var _this$remoteStream;\n\n      if (this.session !== session) {\n        return; // if our session has changed, just return\n      }\n\n      switch (state) {\n        case SessionState.Initial:\n          break;\n\n        case SessionState.Establishing:\n          break;\n\n        case SessionState.Established:\n          this._opInProgress = Operation.OP_NONE;\n          this._callState = 'IN_CALL';\n          this.setupRemoteMedia();\n          this.emit('callestablished');\n          this.emit('stateChanged');\n          break;\n\n        case SessionState.Terminating: // fall through\n\n        case SessionState.Terminated:\n          this.session = undefined;\n          this._callState = 'REGISTERED';\n          this._opInProgress = Operation.OP_NONE;\n          this._userState = UserState.IDLE;\n          this.emit('callterminated');\n          (_this$remoteStream = this.remoteStream) === null || _this$remoteStream === void 0 ? void 0 : _this$remoteStream.clear();\n          this.emit('stateChanged');\n          break;\n\n        default:\n          throw new Error('Unknown session state.');\n      }\n    });\n  }\n\n  onTrackAdded(_event) {\n    console.log('onTrackAdded');\n  }\n\n  onTrackRemoved(_event) {\n    console.log('onTrackRemoved');\n  }\n  /**\n   * Carries out necessary steps for rendering remote media whe\n   * call gets established.\n   * @remarks\n   * Sets up Stream class and plays the stream on given Media element/\n   * Also sets up various event handlers.\n   */\n\n\n  setupRemoteMedia() {\n    var _this$session3, _this$mediaStreamRend;\n\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n\n    const sdh = (_this$session3 = this.session) === null || _this$session3 === void 0 ? void 0 : _this$session3.sessionDescriptionHandler;\n\n    if (!sdh) {\n      return undefined;\n    }\n\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n    }\n\n    const remoteStream = sdh.remoteMediaStream;\n\n    if (!remoteStream) {\n      throw new Error('Remote media stream undefiend.');\n    }\n\n    this.remoteStream = new Stream(remoteStream);\n    const mediaElement = (_this$mediaStreamRend = this.mediaStreamRendered) === null || _this$mediaStreamRend === void 0 ? void 0 : _this$mediaStreamRend.remoteMediaElement;\n\n    if (mediaElement) {\n      this.remoteStream.init(mediaElement);\n      this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n      this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n      this.remoteStream.play();\n    }\n  }\n  /**\n   * Handles call mute-unmute\n   */\n\n\n  async handleMuteUnmute(muteState) {\n    var _this$session4, _this$session5;\n\n    const {\n      session\n    } = this;\n\n    if (this._held === muteState) {\n      return Promise.resolve();\n    }\n\n    if (!session) {\n      throw new Error('Session not found');\n    }\n\n    const sessionDescriptionHandler = (_this$session4 = this.session) === null || _this$session4 === void 0 ? void 0 : _this$session4.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    const options = {\n      requestDelegate: {\n        onAccept: () => {\n          this._held = muteState;\n          toggleMediaStreamTracks(!this._held, session, 'receiver');\n          toggleMediaStreamTracks(!this._held, session, 'sender');\n        },\n        onReject: () => {\n          this.emit('muteerror');\n        }\n      }\n    };\n    const {\n      peerConnection\n    } = sessionDescriptionHandler;\n\n    if (!peerConnection) {\n      throw new Error('Peer connection closed.');\n    }\n\n    return (_this$session5 = this.session) === null || _this$session5 === void 0 ? void 0 : _this$session5.invite(options).then(() => {\n      toggleMediaStreamTracks(!this._held, session, 'receiver');\n      toggleMediaStreamTracks(!this._held, session, 'sender');\n    }).catch(error => {\n      if (error instanceof RequestPendingError) {\n        var _this$session6;\n\n        console.error(\"[\".concat((_this$session6 = this.session) === null || _this$session6 === void 0 ? void 0 : _this$session6.id, \"] A mute request is already in progress.\"));\n      }\n\n      this.emit('muteerror');\n      throw error;\n    });\n  }\n  /**\n   * Handles call hold-unhold\n   */\n\n\n  async handleHoldUnhold(holdState) {\n    var _this$session7, _this$session8;\n\n    const {\n      session\n    } = this;\n\n    if (this._held === holdState) {\n      return Promise.resolve();\n    }\n\n    if (!session) {\n      throw new Error('Session not found');\n    }\n\n    const sessionDescriptionHandler = (_this$session7 = this.session) === null || _this$session7 === void 0 ? void 0 : _this$session7.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    const options = {\n      requestDelegate: {\n        onAccept: () => {\n          this._held = holdState;\n          this._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n          toggleMediaStreamTracks(!this._held, session, 'receiver');\n          toggleMediaStreamTracks(!this._held, session, 'sender');\n          this._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n          this.emit('stateChanged');\n        },\n        onReject: () => {\n          toggleMediaStreamTracks(!this._held, session, 'receiver');\n          toggleMediaStreamTracks(!this._held, session, 'sender');\n          this.emit('holderror');\n        }\n      }\n    }; // Session properties used to pass options to the SessionDescriptionHandler:\n    //\n    // 1) Session.sessionDescriptionHandlerOptions\n    //    SDH options for the initial INVITE transaction.\n    //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n    //    - May be set directly at anytime.\n    //    - May optionally be set via constructor option.\n    //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n    //\n    // 2) Session.sessionDescriptionHandlerOptionsReInvite\n    //    SDH options for re-INVITE transactions.\n    //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n    //    - May be set directly at anytime.\n    //    - May optionally be set via constructor option.\n    //    - May optionally be set via options passed to Session.invite().\n\n    const sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;\n    sessionDescriptionHandlerOptions.hold = holdState;\n    session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n    const {\n      peerConnection\n    } = sessionDescriptionHandler;\n\n    if (!peerConnection) {\n      throw new Error('Peer connection closed.');\n    }\n\n    return (_this$session8 = this.session) === null || _this$session8 === void 0 ? void 0 : _this$session8.invite(options).then(() => {\n      toggleMediaStreamTracks(!this._held, session, 'receiver');\n      toggleMediaStreamTracks(!this._held, session, 'sender');\n    }).catch(error => {\n      if (error instanceof RequestPendingError) {\n        var _this$session9;\n\n        console.error(\"[\".concat((_this$session9 = this.session) === null || _this$session9 === void 0 ? void 0 : _this$session9.id, \"] A hold request is already in progress.\"));\n      }\n\n      this.emit('holderror');\n      throw error;\n    });\n  }\n  /**\n   * Configures and initializes sip.js UserAgent\n   * call gets established.\n   * @remarks\n   * This class configures transport properties such as websocket url, passed down in config,\n   * sets up ICE servers,\n   * SIP UserAgent options such as userName, Password, URI.\n   * Once initialized, it starts the userAgent.\n   */\n\n\n  async init() {\n    const sipUri = \"sip:\".concat(this.config.authUserName, \"@\").concat(this.config.sipRegistrarHostnameOrIP);\n    const transportOptions = {\n      server: this.config.webSocketURI,\n      connectionTimeout: 100,\n      keepAliveInterval: 20 // traceSip: true\n\n    };\n    const sdpFactoryOptions = {\n      iceGatheringTimeout: 10,\n      peerConnectionConfiguration: {\n        iceServers: this.config.iceServers\n      }\n    };\n    this.userAgentOptions = {\n      delegate: {\n        /* UserAgentDelegate methods begin */\n        onConnect: () => {\n          var _this$userAgent;\n\n          this._callState = 'SERVER_CONNECTED';\n          this.emit('connected');\n          /**\n           * There is an interesting problem that happens with Asterisk.\n           * After websocket connection succeeds and if there is no SIP\n           * message goes in 30 seconds, asterisk disconnects the socket.\n           *\n           * If any SIP message goes before 30 seconds, asterisk holds the connection.\n           * This problem could be solved in multiple ways. One is that\n           * whenever disconnect happens make sure that the socket is connected back using\n           * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n           * every 30 seconds till we send register message.\n           *\n           * Another approach is to send SIP OPTIONS just to tell server that\n           * there is a UA using this socket. This is implemented below\n           **/\n\n          const uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n          const outgoingMessage = (_this$userAgent = this.userAgent) === null || _this$userAgent === void 0 ? void 0 : _this$userAgent.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\n          if (outgoingMessage) {\n            var _this$userAgent2;\n\n            (_this$userAgent2 = this.userAgent) === null || _this$userAgent2 === void 0 ? void 0 : _this$userAgent2.userAgentCore.request(outgoingMessage);\n          }\n\n          if (this.userAgent) {\n            this.registerer = new Registerer(this.userAgent);\n          }\n        },\n        onDisconnect: error => {\n          if (error) {\n            this.emit('connectionerror', error);\n          }\n        },\n        onInvite: async invitation => {\n          await this.handleIncomingCall(invitation);\n        }\n      },\n      authorizationPassword: this.config.authPassword,\n      authorizationUsername: this.config.authUserName,\n      uri: UserAgent.makeURI(sipUri),\n      transportOptions,\n      sessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n      logConfiguration: false,\n      logLevel: 'error'\n    };\n    this.userAgent = new UserAgent(this.userAgentOptions);\n    this._opInProgress = Operation.OP_CONNECT;\n    await this.userAgent.start();\n  }\n\n  static async create(config, mediaRenderer) {\n    const voip = new VoIPUser(config, mediaRenderer);\n    await voip.init();\n    return voip;\n  }\n  /**\n   * Public method called from outside to register the SIP UA with call server.\n   * @remarks\n   */\n\n\n  register() {\n    var _this$registerer;\n\n    this._opInProgress = Operation.OP_REGISTER;\n    (_this$registerer = this.registerer) === null || _this$registerer === void 0 ? void 0 : _this$registerer.register({\n      requestDelegate: this\n    });\n  }\n  /**\n   * Public method called from outside to unregister the SIP UA.\n   * @remarks\n   */\n\n\n  unregister() {\n    var _this$registerer2;\n\n    this._opInProgress = Operation.OP_UNREGISTER;\n    (_this$registerer2 = this.registerer) === null || _this$registerer2 === void 0 ? void 0 : _this$registerer2.unregister({\n      all: true,\n      requestDelegate: this\n    });\n  }\n  /**\n   * Public method called from outside to accept incoming call.\n   * @remarks\n   */\n\n\n  async acceptCall(mediaRenderer) {\n    if (mediaRenderer) {\n      this.mediaStreamRendered = mediaRenderer;\n    } // Call state must be in offer_received.\n\n\n    if (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n      this._callState = 'ANSWER_SENT'; // Somethingis wrong, this session is not an instance of INVITE\n\n      if (!(this.session instanceof Invitation)) {\n        throw new Error('Session not instance of Invitation.');\n      }\n      /**\n       * It is important to decide when to add video option to the outgoing offer.\n       * This would matter when the reinvite goes out (In case of hold/unhold)\n       * This was added because there were failures in hold-unhold.\n       * The scenario was that if this client does hold-unhold first, and remote client does\n       * later, remote client goes in inconsistent state and hold-unhold does not work\n       * Where as if the remote client does hold-unhold first, this client can do it any number\n       * of times.\n       *\n       * Logic below works as follows\n       * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n       * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n       * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n       * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n       *\n       */\n\n\n      let videoInvite = !!this.config.enableVideo;\n      const {\n        body\n      } = this.session;\n\n      if (body && body.indexOf('m=video') === -1) {\n        videoInvite = false;\n      }\n\n      const invitationAcceptOptions = {\n        sessionDescriptionHandlerOptions: {\n          constraints: {\n            audio: true,\n            video: !!this.config.enableVideo && videoInvite\n          }\n        }\n      };\n      return this.session.accept(invitationAcceptOptions);\n    }\n\n    throw new Error('Something went wront');\n  }\n  /**\n   * Public method called from outside to reject a call.\n   * @remarks\n   */\n\n\n  rejectCall() {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n\n    if (this._callState !== 'OFFER_RECEIVED') {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n\n    if (!(this.session instanceof Invitation)) {\n      throw new Error('Session not instance of Invitation.');\n    }\n\n    return this.session.reject();\n  }\n  /**\n   * Public method called from outside to end a call.\n   * @remarks\n   */\n\n\n  async endCall() {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n\n    if (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    } // When call ends, force state to be revisited\n\n\n    this.emit('stateChanged');\n\n    switch (this.session.state) {\n      case SessionState.Initial:\n        if (this.session instanceof Invitation) {\n          return this.session.reject();\n        }\n\n        throw new Error('Session not instance of Invitation.');\n\n      case SessionState.Establishing:\n        if (this.session instanceof Invitation) {\n          return this.session.reject();\n        }\n\n        throw new Error('Session not instance of Invitation.');\n\n      case SessionState.Established:\n        return this.session.bye();\n\n      case SessionState.Terminating:\n        break;\n\n      case SessionState.Terminated:\n        break;\n\n      default:\n        throw new Error('Unknown state');\n    }\n  }\n  /**\n   * Public method called from outside to mute the call.\n   * @remarks\n   */\n\n\n  async muteCall(muteState) {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n\n    if (this._callState !== 'IN_CALL') {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n\n    this.handleMuteUnmute(muteState);\n  }\n  /**\n   * Public method called from outside to hold the call.\n   * @remarks\n   */\n\n\n  async holdCall(holdState) {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n\n    if (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n\n    this.handleHoldUnhold(holdState);\n  }\n  /* CallEventDelegate implementation end */\n\n\n  isReady() {\n    return this.state.isReady;\n  }\n  /**\n   * This function allows to change the media renderer media elements.\n   */\n\n\n  switchMediaRenderer(mediaRenderer) {\n    if (this.remoteStream) {\n      this.mediaStreamRendered = mediaRenderer;\n      this.remoteStream.init(mediaRenderer.remoteMediaElement);\n      this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n      this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n      this.remoteStream.play();\n    }\n  }\n\n  setWorkflowMode(mode) {\n    this.mode = mode;\n\n    if (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n      this.queueInfo = new QueueAggregator();\n    }\n  }\n\n  setMembershipSubscription(subscription) {\n    var _this$queueInfo;\n\n    if (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n      return;\n    }\n\n    (_this$queueInfo = this.queueInfo) === null || _this$queueInfo === void 0 ? void 0 : _this$queueInfo.setMembership(subscription);\n  }\n\n  getAggregator() {\n    return this.queueInfo;\n  }\n\n  getRegistrarState() {\n    var _this$registerer3;\n\n    return (_this$registerer3 = this.registerer) === null || _this$registerer3 === void 0 ? void 0 : _this$registerer3.state.toString().toLocaleLowerCase();\n  }\n\n  clear() {\n    var _this$userAgent3;\n\n    (_this$userAgent3 = this.userAgent) === null || _this$userAgent3 === void 0 ? void 0 : _this$userAgent3.stop();\n  }\n\n}","map":{"version":3,"sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protol details.\n */\n\nimport { Emitter } from '@rocket.chat/emitter';\nimport {\n\tUserAgent,\n\tUserAgentOptions,\n\t// UserAgentDelegate,\n\tInvitation,\n\tInvitationAcceptOptions,\n\tSession,\n\tSessionState,\n\tRegisterer,\n\tSessionInviteOptions,\n\tRequestPendingError,\n} from 'sip.js';\nimport { OutgoingByeRequest, OutgoingRequestDelegate, URI } from 'sip.js/lib/core';\nimport { SessionDescriptionHandler, SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\n\nimport { IQueueMembershipSubscription } from '../../../definition/IVoipExtension';\nimport { CallStates } from '../../../definition/voip/CallStates';\nimport { ICallerInfo } from '../../../definition/voip/ICallerInfo';\nimport { Operation } from '../../../definition/voip/Operations';\nimport { UserState } from '../../../definition/voip/UserState';\nimport { IMediaStreamRenderer, VoIPUserConfiguration } from '../../../definition/voip/VoIPUserConfiguration';\nimport { VoIpCallerInfo, IState } from '../../../definition/voip/VoIpCallerInfo';\nimport { VoipEvents } from '../../../definition/voip/VoipEvents';\nimport { WorkflowTypes } from '../../../definition/voip/WorkflowTypes';\nimport { toggleMediaStreamTracks } from './Helper';\nimport { QueueAggregator } from './QueueAggregator';\nimport Stream from './Stream';\n\nexport class VoIPUser extends Emitter<VoipEvents> implements OutgoingRequestDelegate {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate session: Session | undefined;\n\n\tprivate remoteStream: Stream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _callState: CallStates = 'IDLE';\n\n\tprivate _callerInfo: ICallerInfo | undefined;\n\n\tprivate _userState: UserState = UserState.IDLE;\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD') {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\tprivate _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.on('connected', () => {\n\t\t\tthis.state.isReady = true;\n\t\t});\n\n\t\tthis.on('connectionerror', () => {\n\t\t\tthis.state.isReady = false;\n\t\t});\n\t}\n\n\t/* UserAgentDelegate methods end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprivate setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis.emit('callestablished');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream undefiend.');\n\t\t}\n\n\t\tthis.remoteStream = new Stream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\t/* UserAgentDelegate methods begin */\n\t\t\t\tonConnect: (): void => {\n\t\t\t\t\tthis._callState = 'SERVER_CONNECTED';\n\n\t\t\t\t\tthis.emit('connected');\n\t\t\t\t\t/**\n\t\t\t\t\t * There is an interesting problem that happens with Asterisk.\n\t\t\t\t\t * After websocket connection succeeds and if there is no SIP\n\t\t\t\t\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t\t\t\t\t *\n\t\t\t\t\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t\t\t\t\t * This problem could be solved in multiple ways. One is that\n\t\t\t\t\t * whenever disconnect happens make sure that the socket is connected back using\n\t\t\t\t\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t\t\t\t\t * every 30 seconds till we send register message.\n\t\t\t\t\t *\n\t\t\t\t\t * Another approach is to send SIP OPTIONS just to tell server that\n\t\t\t\t\t * there is a UA using this socket. This is implemented below\n\t\t\t\t\t **/\n\n\t\t\t\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\t\t\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\t\t\t\tif (outgoingMessage) {\n\t\t\t\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.userAgent) {\n\t\t\t\t\t\tthis.registerer = new Registerer(this.userAgent);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonDisconnect: (error: any): void => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.emit('connectionerror', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\tawait this.userAgent.start();\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Somethingis wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wront');\n\t}\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'OFFER_RECEIVED') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis.userAgent?.stop();\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"5d9be0f2f808bb0b67b657e5e816e0a66a862910"}
