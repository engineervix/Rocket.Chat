{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/lib/callbacks.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"lib/callbacks.ts","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/lib/callbacks.ts","inputSourceMap":{"version":3,"file":"lib/callbacks.ts","sourceRoot":"","sources":["lib/callbacks.ts"],"names":[],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { FilterQuery } from 'mongodb';\n\nimport type { IBusinessHourBehavior } from '../app/livechat/server/business-hour/AbstractBusinessHour';\nimport type { Logger } from '../app/logger/server';\nimport type { IMessage } from '../definition/IMessage';\nimport type { IRoom } from '../definition/IRoom';\nimport type { IUser } from '../definition/IUser';\nimport type { ILivechatDepartmentRecord } from '../definition/ILivechatDepartmentRecord';\nimport type { ILivechatAgent } from '../definition/ILivechatAgent';\nimport type { OmnichannelAgentStatus } from '../definition/IOmnichannelAgent';\nimport type { ILivechatInquiryRecord } from '../definition/IInquiry';\nimport type { ILivechatVisitor } from '../definition/ILivechatVisitor';\nimport { getRandomId } from './random';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\n/**\n * Callbacks returning void, like event listeners.\n *\n * TODO: move those to event-based systems\n */\ntype EventLikeCallbackSignatures = {\n\t'afterActivateUser': (user: IUser) => void;\n\t'afterCreateChannel': (owner: IUser, room: IRoom) => void;\n\t'afterCreatePrivateGroup': (owner: IUser, room: IRoom) => void;\n\t'afterDeactivateUser': (user: IUser) => void;\n\t'afterDeleteMessage': (message: IMessage, room: IRoom) => void;\n\t'validateUserRoles': (userData: Partial<IUser>) => void;\n\t'workspaceLicenseChanged': (license: string) => void;\n\t'afterReadMessages': (rid: IRoom['_id'], params: { uid: IUser['_id']; lastSeen: Date }) => void;\n\t'beforeReadMessages': (rid: IRoom['_id'], uid: IUser['_id']) => void;\n\t'afterDeleteUser': (user: IUser) => void;\n\t'afterFileUpload': (params: { user: IUser; room: IRoom; message: IMessage }) => void;\n\t'afterSaveMessage': (message: IMessage, room: IRoom, uid: string) => void;\n\t'livechat.removeAgentDepartment': (params: { departmentId: ILivechatDepartmentRecord['_id']; agentsId: ILivechatAgent['_id'][] }) => void;\n\t'livechat.saveAgentDepartment': (params: { departmentId: ILivechatDepartmentRecord['_id']; agentsId: ILivechatAgent['_id'][] }) => void;\n\t'livechat.closeRoom': (room: IRoom) => void;\n\t'livechat.saveRoom': (room: IRoom) => void;\n\t'livechat:afterReturnRoomAsInquiry': (params: { room: IRoom }) => void;\n\t'livechat.setUserStatusLivechat': (params: { userId: IUser['_id']; status: OmnichannelAgentStatus }) => void;\n\t'livechat.agentStatusChanged': (params: { userId: IUser['_id']; status: OmnichannelAgentStatus }) => void;\n\t'livechat.afterTakeInquiry': (inq: ILivechatInquiryRecord, agent: ILivechatAgent) => void;\n\t'afterAddedToRoom': (params: { user: IUser; inviter: IUser }) => void;\n\t'beforeAddedToRoom': (params: { user: IUser; inviter: IUser }) => void;\n\t'afterCreateDirectRoom': (params: IRoom, second: { members: IUser[] }) => void;\n\t'beforeDeleteRoom': (params: IRoom) => void;\n\t'beforeJoinDefaultChannels': (user: IUser) => void;\n\t'beforeCreateChannel': (owner: IUser, room: IRoom) => void;\n\t'afterCreateRoom': (owner: IUser, room: IRoom) => void;\n};\n\n/**\n * Callbacks that are supposed to be composed like a chain.\n *\n * TODO: develop a middleware alternative and grant independence of execution order\n */\ntype ChainedCallbackSignatures = {\n\t'afterCreateUser': (user: IUser) => IUser;\n\t'afterDeleteRoom': (rid: IRoom['_id']) => IRoom['_id'];\n\t'livechat:afterOnHold': (room: IRoom) => IRoom;\n\t'livechat:afterOnHoldChatResumed': (room: IRoom) => IRoom;\n\t'livechat:onTransferFailure': (params: { room: IRoom; guest: ILivechatVisitor; transferData: { [k: string]: string | any } }) => {\n\t\troom: IRoom;\n\t\tguest: ILivechatVisitor;\n\t\ttransferData: { [k: string]: string | any };\n\t};\n\t'livechat.afterForwardChatToAgent': (params: { rid: IRoom['_id']; servedBy: unknown; oldServedBy: unknown }) => {\n\t\trid: IRoom['_id'];\n\t\tservedBy: unknown;\n\t\toldServedBy: unknown;\n\t};\n\t'livechat.afterForwardChatToDepartment': (params: {\n\t\trid: IRoom['_id'];\n\t\tnewDepartmentId: ILivechatDepartmentRecord['_id'];\n\t\toldDepartmentId: ILivechatDepartmentRecord['_id'];\n\t}) => {\n\t\trid: IRoom['_id'];\n\t\tnewDepartmentId: ILivechatDepartmentRecord['_id'];\n\t\toldDepartmentId: ILivechatDepartmentRecord['_id'];\n\t};\n\t'livechat.afterInquiryQueued': (inquiry: ILivechatInquiryRecord) => ILivechatInquiryRecord;\n\t'livechat.afterRemoveDepartment': (params: { departmentId: ILivechatDepartmentRecord['_id']; agentsId: ILivechatAgent['_id'][] }) => {\n\t\tdepartmentId: ILivechatDepartmentRecord['_id'];\n\t\tagentsId: ILivechatAgent['_id'][];\n\t};\n\t'livechat.applySimultaneousChatRestrictions': (_: undefined, params: { departmentId?: ILivechatDepartmentRecord['_id'] }) => undefined;\n\t'livechat.beforeCloseRoom': (params: { room: IRoom; options: unknown }) => { room: IRoom; options: unknown };\n\t'livechat.beforeDelegateAgent': (agent: ILivechatAgent, params: { department?: ILivechatDepartmentRecord }) => ILivechatAgent;\n\t'livechat.applyDepartmentRestrictions': (\n\t\tquery: FilterQuery<ILivechatDepartmentRecord>,\n\t\tparams: { userId: IUser['_id'] },\n\t) => FilterQuery<ILivechatDepartmentRecord>;\n\t'livechat.onMaxNumberSimultaneousChatsReached': (inquiry: ILivechatInquiryRecord) => ILivechatInquiryRecord;\n\t'on-business-hour-start': (params: { BusinessHourBehaviorClass: { new (): IBusinessHourBehavior } }) => {\n\t\tBusinessHourBehaviorClass: { new (): IBusinessHourBehavior };\n\t};\n};\n\ntype Hook =\n\t| keyof EventLikeCallbackSignatures\n\t| keyof ChainedCallbackSignatures\n\t| 'afterJoinRoom'\n\t| 'afterLeaveRoom'\n\t| 'afterLogoutCleanUp'\n\t| 'afterProcessOAuthUser'\n\t| 'afterRemoveFromRoom'\n\t| 'afterRoomArchived'\n\t| 'afterRoomNameChange'\n\t| 'afterSaveUser'\n\t| 'afterValidateLogin'\n\t| 'afterValidateNewOAuthUser'\n\t| 'archiveRoom'\n\t| 'beforeActivateUser'\n\t| 'beforeCreateRoom'\n\t| 'beforeCreateUser'\n\t| 'beforeGetMentions'\n\t| 'beforeJoinRoom'\n\t| 'beforeLeaveRoom'\n\t| 'beforeReadMessages'\n\t| 'beforeRemoveFromRoom'\n\t| 'beforeSaveMessage'\n\t| 'beforeSendMessageNotifications'\n\t| 'beforeValidateLogin'\n\t| 'cachedCollection-loadFromServer-rooms'\n\t| 'cachedCollection-loadFromServer-subscriptions'\n\t| 'cachedCollection-received-rooms'\n\t| 'cachedCollection-received-subscriptions'\n\t| 'cachedCollection-sync-rooms'\n\t| 'cachedCollection-sync-subscriptions'\n\t| 'enter-room'\n\t| 'livechat.beforeForwardRoomToDepartment'\n\t| 'livechat.beforeInquiry'\n\t| 'livechat.beforeListTags'\n\t| 'livechat.beforeRoom'\n\t| 'livechat.beforeRouteChat'\n\t| 'livechat.chatQueued'\n\t| 'livechat.checkAgentBeforeTakeInquiry'\n\t| 'livechat.checkDefaultAgentOnNewRoom'\n\t| 'livechat.closeRoom'\n\t| 'livechat.leadCapture'\n\t| 'livechat.newRoom'\n\t| 'livechat.offlineMessage'\n\t| 'livechat.onAgentAssignmentFailed'\n\t| 'livechat.onCheckRoomApiParams'\n\t| 'livechat.onLoadConfigApi'\n\t| 'livechat.onLoadForwardDepartmentRestrictions'\n\t| 'livechat.saveInfo'\n\t| 'loginPageStateChange'\n\t| 'mapLDAPUserData'\n\t| 'oembed:afterParseContent'\n\t| 'oembed:beforeGetUrlContent'\n\t| 'onCreateUser'\n\t| 'onLDAPLogin'\n\t| 'onValidateLogin'\n\t| 'openBroadcast'\n\t| 'renderMessage'\n\t| 'renderNotification'\n\t| 'roomAnnouncementChanged'\n\t| 'roomAvatarChanged'\n\t| 'roomNameChanged'\n\t| 'roomTopicChanged'\n\t| 'roomTypeChanged'\n\t| 'setReaction'\n\t| 'streamMessage'\n\t| 'streamNewMessage'\n\t| 'unarchiveRoom'\n\t| 'unsetReaction'\n\t| 'userAvatarSet'\n\t| 'userConfirmationEmailRequested'\n\t| 'userForgotPasswordEmailRequested'\n\t| 'usernameSet'\n\t| 'userPasswordReset'\n\t| 'userRegistered'\n\t| 'userStatusManuallySet';\n\ntype Callback = {\n\t(item: unknown, constant?: unknown): unknown;\n\thook: Hook;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker = (callback: Callback) => () => void;\n\ntype HookTracker = (params: { hook: Hook; length: number }) => () => void;\n\nclass Callbacks {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker | undefined = undefined;\n\n\tprivate trackHook: HookTracker | undefined = undefined;\n\n\tprivate callbacks = new Map<Hook, Callback[]>();\n\n\tprivate sequentialRunners = new Map<Hook, (item: unknown, constant?: unknown) => unknown>();\n\n\tprivate asyncRunners = new Map<Hook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker; trackHook?: HookTracker }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback, item: unknown, constant: unknown): unknown {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\ttry {\n\t\t\treturn callback(item, constant);\n\t\t} finally {\n\t\t\tstopTracking?.();\n\t\t}\n\t}\n\n\tprivate createSequentialRunner(hook: Hook, callbacks: Callback[]): (item: unknown, constant?: unknown) => unknown {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback) =>\n\t\t\t(item: unknown, constant?: unknown): unknown => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn this.runOne(callback, item, constant) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): TItem => item;\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => unknown, next: (item: unknown, constant?: unknown) => unknown) =>\n\t\t\t(item: unknown, constant?: unknown): unknown =>\n\t\t\t\tnext(curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\ttry {\n\t\t\t\treturn fn(item, constant);\n\t\t\t} finally {\n\t\t\t\tstopTracking?.();\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: Hook, callbacks: Callback[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tMeteor.defer(() => {\n\t\t\t\t\tthis.runOne(callback, item, constant);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: Hook): Callback[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: Hook, callbacks: Callback[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<THook extends keyof EventLikeCallbackSignatures>(\n\t\thook: THook,\n\t\tcallback: EventLikeCallbackSignatures[THook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<THook extends keyof ChainedCallbackSignatures>(\n\t\thook: THook,\n\t\tcallback: ChainedCallbackSignatures[THook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: Hook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: Hook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = getRandomId()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tconst rank = (callback: Callback): number => callback.priority ?? this.priority.MEDIUM;\n\t\tcallbacks.sort((a, b) => rank(a) - rank(b));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: Hook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun<THook extends keyof EventLikeCallbackSignatures>(hook: THook, ...args: Parameters<EventLikeCallbackSignatures[THook]>): void;\n\n\trun<THook extends keyof ChainedCallbackSignatures>(\n\t\thook: THook,\n\t\t...args: Parameters<ChainedCallbackSignatures[THook]>\n\t): ReturnType<ChainedCallbackSignatures[THook]>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: Hook, item: TItem, constant?: TConstant): TNextItem;\n\n\trun(hook: Hook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync<THook extends keyof EventLikeCallbackSignatures>(hook: THook, ...args: Parameters<EventLikeCallbackSignatures[THook]>): void;\n\n\trunAsync(hook: Hook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\nexport const callbacks = new Callbacks();\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/lib/callbacks.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/callbacks.ts"}},"code":"module.export({\n  callbacks: () => callbacks\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet getRandomId;\nmodule.link(\"./random\", {\n  getRandomId(v) {\n    getRandomId = v;\n  }\n\n}, 1);\nvar CallbackPriority;\n\n(function (CallbackPriority) {\n  CallbackPriority[CallbackPriority[\"HIGH\"] = -1000] = \"HIGH\";\n  CallbackPriority[CallbackPriority[\"MEDIUM\"] = 0] = \"MEDIUM\";\n  CallbackPriority[CallbackPriority[\"LOW\"] = 1000] = \"LOW\";\n})(CallbackPriority || (CallbackPriority = {}));\n\nclass Callbacks {\n  constructor() {\n    this.logger = undefined;\n    this.trackCallback = undefined;\n    this.trackHook = undefined;\n    this.callbacks = new Map();\n    this.sequentialRunners = new Map();\n    this.asyncRunners = new Map();\n    this.priority = CallbackPriority;\n  }\n\n  setLogger(logger) {\n    this.logger = logger;\n  }\n\n  setMetricsTrackers(_ref) {\n    let {\n      trackCallback,\n      trackHook\n    } = _ref;\n    this.trackCallback = trackCallback;\n    this.trackHook = trackHook;\n  }\n\n  runOne(callback, item, constant) {\n    var _this$trackCallback;\n\n    const stopTracking = (_this$trackCallback = this.trackCallback) === null || _this$trackCallback === void 0 ? void 0 : _this$trackCallback.call(this, callback);\n\n    try {\n      return callback(item, constant);\n    } finally {\n      stopTracking === null || stopTracking === void 0 ? void 0 : stopTracking();\n    }\n  }\n\n  createSequentialRunner(hook, callbacks) {\n    const wrapCallback = callback => (item, constant) => {\n      var _this$logger, _this$runOne;\n\n      (_this$logger = this.logger) === null || _this$logger === void 0 ? void 0 : _this$logger.debug(\"Executing callback with id \".concat(callback.id, \" for hook \").concat(callback.hook));\n      return (_this$runOne = this.runOne(callback, item, constant)) !== null && _this$runOne !== void 0 ? _this$runOne : item;\n    };\n\n    const identity = item => item;\n\n    const pipe = (curr, next) => (item, constant) => next(curr(item, constant), constant);\n\n    const fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n    return (item, constant) => {\n      var _this$trackHook;\n\n      const stopTracking = (_this$trackHook = this.trackHook) === null || _this$trackHook === void 0 ? void 0 : _this$trackHook.call(this, {\n        hook,\n        length: callbacks.length\n      });\n\n      try {\n        return fn(item, constant);\n      } finally {\n        stopTracking === null || stopTracking === void 0 ? void 0 : stopTracking();\n      }\n    };\n  }\n\n  createAsyncRunner(_, callbacks) {\n    return (item, constant) => {\n      if (typeof window !== 'undefined') {\n        throw new Error('callbacks.runAsync on client server not allowed');\n      }\n\n      for (const callback of callbacks) {\n        Meteor.defer(() => {\n          this.runOne(callback, item, constant);\n        });\n      }\n\n      return item;\n    };\n  }\n\n  getCallbacks(hook) {\n    var _this$callbacks$get;\n\n    return (_this$callbacks$get = this.callbacks.get(hook)) !== null && _this$callbacks$get !== void 0 ? _this$callbacks$get : [];\n  }\n\n  setCallbacks(hook, callbacks) {\n    this.callbacks.set(hook, callbacks);\n    this.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n    this.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n  }\n\n  add(hook, callback) {\n    let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.priority.MEDIUM;\n    let id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getRandomId();\n    const callbacks = this.getCallbacks(hook);\n\n    if (callbacks.some(cb => cb.id === id)) {\n      return;\n    }\n\n    callbacks.push(Object.assign(callback, {\n      hook,\n      priority,\n      id,\n      stack: new Error().stack\n    }));\n\n    const rank = callback => {\n      var _callback$priority;\n\n      return (_callback$priority = callback.priority) !== null && _callback$priority !== void 0 ? _callback$priority : this.priority.MEDIUM;\n    };\n\n    callbacks.sort((a, b) => rank(a) - rank(b));\n    this.setCallbacks(hook, callbacks);\n  }\n  /**\n   * Remove a callback from a hook\n   *\n   * @param hook the name of the hook\n   * @param id the callback's id\n   */\n\n\n  remove(hook, id) {\n    const hooks = this.getCallbacks(hook).filter(callback => callback.id !== id);\n    this.setCallbacks(hook, hooks);\n  }\n\n  run(hook, item, constant) {\n    var _this$sequentialRunne;\n\n    const runner = (_this$sequentialRunne = this.sequentialRunners.get(hook)) !== null && _this$sequentialRunne !== void 0 ? _this$sequentialRunne : (item, _constant) => item;\n    return runner(item, constant);\n  }\n\n  runAsync(hook, item, constant) {\n    var _this$asyncRunners$ge;\n\n    const runner = (_this$asyncRunners$ge = this.asyncRunners.get(hook)) !== null && _this$asyncRunners$ge !== void 0 ? _this$asyncRunners$ge : (item, _constant) => item;\n    return runner(item, constant);\n  }\n\n}\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\n\n\nconst callbacks = new Callbacks();","map":{"version":3,"sources":["lib/callbacks.ts"],"names":[],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { FilterQuery } from 'mongodb';\n\nimport type { IBusinessHourBehavior } from '../app/livechat/server/business-hour/AbstractBusinessHour';\nimport type { Logger } from '../app/logger/server';\nimport type { IMessage } from '../definition/IMessage';\nimport type { IRoom } from '../definition/IRoom';\nimport type { IUser } from '../definition/IUser';\nimport type { ILivechatDepartmentRecord } from '../definition/ILivechatDepartmentRecord';\nimport type { ILivechatAgent } from '../definition/ILivechatAgent';\nimport type { OmnichannelAgentStatus } from '../definition/IOmnichannelAgent';\nimport type { ILivechatInquiryRecord } from '../definition/IInquiry';\nimport type { ILivechatVisitor } from '../definition/ILivechatVisitor';\nimport { getRandomId } from './random';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\n/**\n * Callbacks returning void, like event listeners.\n *\n * TODO: move those to event-based systems\n */\ntype EventLikeCallbackSignatures = {\n\t'afterActivateUser': (user: IUser) => void;\n\t'afterCreateChannel': (owner: IUser, room: IRoom) => void;\n\t'afterCreatePrivateGroup': (owner: IUser, room: IRoom) => void;\n\t'afterDeactivateUser': (user: IUser) => void;\n\t'afterDeleteMessage': (message: IMessage, room: IRoom) => void;\n\t'validateUserRoles': (userData: Partial<IUser>) => void;\n\t'workspaceLicenseChanged': (license: string) => void;\n\t'afterReadMessages': (rid: IRoom['_id'], params: { uid: IUser['_id']; lastSeen: Date }) => void;\n\t'beforeReadMessages': (rid: IRoom['_id'], uid: IUser['_id']) => void;\n\t'afterDeleteUser': (user: IUser) => void;\n\t'afterFileUpload': (params: { user: IUser; room: IRoom; message: IMessage }) => void;\n\t'afterSaveMessage': (message: IMessage, room: IRoom, uid: string) => void;\n\t'livechat.removeAgentDepartment': (params: { departmentId: ILivechatDepartmentRecord['_id']; agentsId: ILivechatAgent['_id'][] }) => void;\n\t'livechat.saveAgentDepartment': (params: { departmentId: ILivechatDepartmentRecord['_id']; agentsId: ILivechatAgent['_id'][] }) => void;\n\t'livechat.closeRoom': (room: IRoom) => void;\n\t'livechat.saveRoom': (room: IRoom) => void;\n\t'livechat:afterReturnRoomAsInquiry': (params: { room: IRoom }) => void;\n\t'livechat.setUserStatusLivechat': (params: { userId: IUser['_id']; status: OmnichannelAgentStatus }) => void;\n\t'livechat.agentStatusChanged': (params: { userId: IUser['_id']; status: OmnichannelAgentStatus }) => void;\n\t'livechat.afterTakeInquiry': (inq: ILivechatInquiryRecord, agent: ILivechatAgent) => void;\n\t'afterAddedToRoom': (params: { user: IUser; inviter: IUser }) => void;\n\t'beforeAddedToRoom': (params: { user: IUser; inviter: IUser }) => void;\n\t'afterCreateDirectRoom': (params: IRoom, second: { members: IUser[] }) => void;\n\t'beforeDeleteRoom': (params: IRoom) => void;\n\t'beforeJoinDefaultChannels': (user: IUser) => void;\n\t'beforeCreateChannel': (owner: IUser, room: IRoom) => void;\n\t'afterCreateRoom': (owner: IUser, room: IRoom) => void;\n};\n\n/**\n * Callbacks that are supposed to be composed like a chain.\n *\n * TODO: develop a middleware alternative and grant independence of execution order\n */\ntype ChainedCallbackSignatures = {\n\t'afterCreateUser': (user: IUser) => IUser;\n\t'afterDeleteRoom': (rid: IRoom['_id']) => IRoom['_id'];\n\t'livechat:afterOnHold': (room: IRoom) => IRoom;\n\t'livechat:afterOnHoldChatResumed': (room: IRoom) => IRoom;\n\t'livechat:onTransferFailure': (params: { room: IRoom; guest: ILivechatVisitor; transferData: { [k: string]: string | any } }) => {\n\t\troom: IRoom;\n\t\tguest: ILivechatVisitor;\n\t\ttransferData: { [k: string]: string | any };\n\t};\n\t'livechat.afterForwardChatToAgent': (params: { rid: IRoom['_id']; servedBy: unknown; oldServedBy: unknown }) => {\n\t\trid: IRoom['_id'];\n\t\tservedBy: unknown;\n\t\toldServedBy: unknown;\n\t};\n\t'livechat.afterForwardChatToDepartment': (params: {\n\t\trid: IRoom['_id'];\n\t\tnewDepartmentId: ILivechatDepartmentRecord['_id'];\n\t\toldDepartmentId: ILivechatDepartmentRecord['_id'];\n\t}) => {\n\t\trid: IRoom['_id'];\n\t\tnewDepartmentId: ILivechatDepartmentRecord['_id'];\n\t\toldDepartmentId: ILivechatDepartmentRecord['_id'];\n\t};\n\t'livechat.afterInquiryQueued': (inquiry: ILivechatInquiryRecord) => ILivechatInquiryRecord;\n\t'livechat.afterRemoveDepartment': (params: { departmentId: ILivechatDepartmentRecord['_id']; agentsId: ILivechatAgent['_id'][] }) => {\n\t\tdepartmentId: ILivechatDepartmentRecord['_id'];\n\t\tagentsId: ILivechatAgent['_id'][];\n\t};\n\t'livechat.applySimultaneousChatRestrictions': (_: undefined, params: { departmentId?: ILivechatDepartmentRecord['_id'] }) => undefined;\n\t'livechat.beforeCloseRoom': (params: { room: IRoom; options: unknown }) => { room: IRoom; options: unknown };\n\t'livechat.beforeDelegateAgent': (agent: ILivechatAgent, params: { department?: ILivechatDepartmentRecord }) => ILivechatAgent;\n\t'livechat.applyDepartmentRestrictions': (\n\t\tquery: FilterQuery<ILivechatDepartmentRecord>,\n\t\tparams: { userId: IUser['_id'] },\n\t) => FilterQuery<ILivechatDepartmentRecord>;\n\t'livechat.onMaxNumberSimultaneousChatsReached': (inquiry: ILivechatInquiryRecord) => ILivechatInquiryRecord;\n\t'on-business-hour-start': (params: { BusinessHourBehaviorClass: { new (): IBusinessHourBehavior } }) => {\n\t\tBusinessHourBehaviorClass: { new (): IBusinessHourBehavior };\n\t};\n};\n\ntype Hook =\n\t| keyof EventLikeCallbackSignatures\n\t| keyof ChainedCallbackSignatures\n\t| 'afterJoinRoom'\n\t| 'afterLeaveRoom'\n\t| 'afterLogoutCleanUp'\n\t| 'afterProcessOAuthUser'\n\t| 'afterRemoveFromRoom'\n\t| 'afterRoomArchived'\n\t| 'afterRoomNameChange'\n\t| 'afterSaveUser'\n\t| 'afterValidateLogin'\n\t| 'afterValidateNewOAuthUser'\n\t| 'archiveRoom'\n\t| 'beforeActivateUser'\n\t| 'beforeCreateRoom'\n\t| 'beforeCreateUser'\n\t| 'beforeGetMentions'\n\t| 'beforeJoinRoom'\n\t| 'beforeLeaveRoom'\n\t| 'beforeReadMessages'\n\t| 'beforeRemoveFromRoom'\n\t| 'beforeSaveMessage'\n\t| 'beforeSendMessageNotifications'\n\t| 'beforeValidateLogin'\n\t| 'cachedCollection-loadFromServer-rooms'\n\t| 'cachedCollection-loadFromServer-subscriptions'\n\t| 'cachedCollection-received-rooms'\n\t| 'cachedCollection-received-subscriptions'\n\t| 'cachedCollection-sync-rooms'\n\t| 'cachedCollection-sync-subscriptions'\n\t| 'enter-room'\n\t| 'livechat.beforeForwardRoomToDepartment'\n\t| 'livechat.beforeInquiry'\n\t| 'livechat.beforeListTags'\n\t| 'livechat.beforeRoom'\n\t| 'livechat.beforeRouteChat'\n\t| 'livechat.chatQueued'\n\t| 'livechat.checkAgentBeforeTakeInquiry'\n\t| 'livechat.checkDefaultAgentOnNewRoom'\n\t| 'livechat.closeRoom'\n\t| 'livechat.leadCapture'\n\t| 'livechat.newRoom'\n\t| 'livechat.offlineMessage'\n\t| 'livechat.onAgentAssignmentFailed'\n\t| 'livechat.onCheckRoomApiParams'\n\t| 'livechat.onLoadConfigApi'\n\t| 'livechat.onLoadForwardDepartmentRestrictions'\n\t| 'livechat.saveInfo'\n\t| 'loginPageStateChange'\n\t| 'mapLDAPUserData'\n\t| 'oembed:afterParseContent'\n\t| 'oembed:beforeGetUrlContent'\n\t| 'onCreateUser'\n\t| 'onLDAPLogin'\n\t| 'onValidateLogin'\n\t| 'openBroadcast'\n\t| 'renderMessage'\n\t| 'renderNotification'\n\t| 'roomAnnouncementChanged'\n\t| 'roomAvatarChanged'\n\t| 'roomNameChanged'\n\t| 'roomTopicChanged'\n\t| 'roomTypeChanged'\n\t| 'setReaction'\n\t| 'streamMessage'\n\t| 'streamNewMessage'\n\t| 'unarchiveRoom'\n\t| 'unsetReaction'\n\t| 'userAvatarSet'\n\t| 'userConfirmationEmailRequested'\n\t| 'userForgotPasswordEmailRequested'\n\t| 'usernameSet'\n\t| 'userPasswordReset'\n\t| 'userRegistered'\n\t| 'userStatusManuallySet';\n\ntype Callback = {\n\t(item: unknown, constant?: unknown): unknown;\n\thook: Hook;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker = (callback: Callback) => () => void;\n\ntype HookTracker = (params: { hook: Hook; length: number }) => () => void;\n\nclass Callbacks {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker | undefined = undefined;\n\n\tprivate trackHook: HookTracker | undefined = undefined;\n\n\tprivate callbacks = new Map<Hook, Callback[]>();\n\n\tprivate sequentialRunners = new Map<Hook, (item: unknown, constant?: unknown) => unknown>();\n\n\tprivate asyncRunners = new Map<Hook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker; trackHook?: HookTracker }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback, item: unknown, constant: unknown): unknown {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\ttry {\n\t\t\treturn callback(item, constant);\n\t\t} finally {\n\t\t\tstopTracking?.();\n\t\t}\n\t}\n\n\tprivate createSequentialRunner(hook: Hook, callbacks: Callback[]): (item: unknown, constant?: unknown) => unknown {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback) =>\n\t\t\t(item: unknown, constant?: unknown): unknown => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn this.runOne(callback, item, constant) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): TItem => item;\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => unknown, next: (item: unknown, constant?: unknown) => unknown) =>\n\t\t\t(item: unknown, constant?: unknown): unknown =>\n\t\t\t\tnext(curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\ttry {\n\t\t\t\treturn fn(item, constant);\n\t\t\t} finally {\n\t\t\t\tstopTracking?.();\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: Hook, callbacks: Callback[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tMeteor.defer(() => {\n\t\t\t\t\tthis.runOne(callback, item, constant);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: Hook): Callback[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: Hook, callbacks: Callback[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<THook extends keyof EventLikeCallbackSignatures>(\n\t\thook: THook,\n\t\tcallback: EventLikeCallbackSignatures[THook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<THook extends keyof ChainedCallbackSignatures>(\n\t\thook: THook,\n\t\tcallback: ChainedCallbackSignatures[THook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: Hook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: Hook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = getRandomId()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tconst rank = (callback: Callback): number => callback.priority ?? this.priority.MEDIUM;\n\t\tcallbacks.sort((a, b) => rank(a) - rank(b));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: Hook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun<THook extends keyof EventLikeCallbackSignatures>(hook: THook, ...args: Parameters<EventLikeCallbackSignatures[THook]>): void;\n\n\trun<THook extends keyof ChainedCallbackSignatures>(\n\t\thook: THook,\n\t\t...args: Parameters<ChainedCallbackSignatures[THook]>\n\t): ReturnType<ChainedCallbackSignatures[THook]>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: Hook, item: TItem, constant?: TConstant): TNextItem;\n\n\trun(hook: Hook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync<THook extends keyof EventLikeCallbackSignatures>(hook: THook, ...args: Parameters<EventLikeCallbackSignatures[THook]>): void;\n\n\trunAsync(hook: Hook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\nexport const callbacks = new Callbacks();\n"],"sourceRoot":""},"sourceType":"module","hash":"52ffda24cec0c898c340ba46308b88faed15258f"}
