{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/client/lib/voip/VoIPUser.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"client/lib/voip/VoIPUser.ts","filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/client/lib/voip/VoIPUser.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/VoIPUser.ts","sourceRoot":"","sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protol details.\n */\n\nimport { Emitter } from '@rocket.chat/emitter';\nimport {\n\tUserAgent,\n\tUserAgentOptions,\n\t// UserAgentDelegate,\n\tInvitation,\n\tInvitationAcceptOptions,\n\tSession,\n\tSessionState,\n\tRegisterer,\n\tSessionInviteOptions,\n\tRequestPendingError,\n} from 'sip.js';\nimport { OutgoingByeRequest, OutgoingRequestDelegate, URI } from 'sip.js/lib/core';\nimport { SessionDescriptionHandler, SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\n\nimport { IQueueMembershipSubscription } from '../../../definition/IVoipExtension';\nimport { CallStates } from '../../../definition/voip/CallStates';\nimport { ICallerInfo } from '../../../definition/voip/ICallerInfo';\nimport { Operation } from '../../../definition/voip/Operations';\nimport { UserState } from '../../../definition/voip/UserState';\nimport { IMediaStreamRenderer, VoIPUserConfiguration } from '../../../definition/voip/VoIPUserConfiguration';\nimport { VoIpCallerInfo, IState } from '../../../definition/voip/VoIpCallerInfo';\nimport { VoipEvents } from '../../../definition/voip/VoipEvents';\nimport { WorkflowTypes } from '../../../definition/voip/WorkflowTypes';\nimport { toggleMediaStreamTracks } from './Helper';\nimport { QueueAggregator } from './QueueAggregator';\nimport Stream from './Stream';\n\nexport class VoIPUser extends Emitter<VoipEvents> implements OutgoingRequestDelegate {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate session: Session | undefined;\n\n\tprivate remoteStream: Stream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _callState: CallStates = 'IDLE';\n\n\tprivate _callerInfo: ICallerInfo | undefined;\n\n\tprivate _userState: UserState = UserState.IDLE;\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD') {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\tprivate _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.on('connected', () => {\n\t\t\tthis.state.isReady = true;\n\t\t});\n\n\t\tthis.on('connectionerror', () => {\n\t\t\tthis.state.isReady = false;\n\t\t});\n\t}\n\n\t/* UserAgentDelegate methods end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprivate setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis.emit('callestablished');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream undefiend.');\n\t\t}\n\n\t\tthis.remoteStream = new Stream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\t/* UserAgentDelegate methods begin */\n\t\t\t\tonConnect: (): void => {\n\t\t\t\t\tthis._callState = 'SERVER_CONNECTED';\n\n\t\t\t\t\tthis.emit('connected');\n\t\t\t\t\t/**\n\t\t\t\t\t * There is an interesting problem that happens with Asterisk.\n\t\t\t\t\t * After websocket connection succeeds and if there is no SIP\n\t\t\t\t\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t\t\t\t\t *\n\t\t\t\t\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t\t\t\t\t * This problem could be solved in multiple ways. One is that\n\t\t\t\t\t * whenever disconnect happens make sure that the socket is connected back using\n\t\t\t\t\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t\t\t\t\t * every 30 seconds till we send register message.\n\t\t\t\t\t *\n\t\t\t\t\t * Another approach is to send SIP OPTIONS just to tell server that\n\t\t\t\t\t * there is a UA using this socket. This is implemented below\n\t\t\t\t\t **/\n\n\t\t\t\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\t\t\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\t\t\t\tif (outgoingMessage) {\n\t\t\t\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.userAgent) {\n\t\t\t\t\t\tthis.registerer = new Registerer(this.userAgent);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonDisconnect: (error: any): void => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.emit('connectionerror', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\tawait this.userAgent.start();\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Somethingis wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wront');\n\t}\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'OFFER_RECEIVED') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis.userAgent?.stop();\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","root":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/carlosrodrigues/Desktop/work/rocketchat/Rocket.Chat/client/lib/voip/VoIPUser.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/voip/VoIPUser.ts"}},"code":"var _regeneratorRuntime;\n\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\n\nvar _createClass;\n\nmodule.link(\"@babel/runtime/helpers/createClass\", {\n  default: function (v) {\n    _createClass = v;\n  }\n}, 1);\n\nvar _inheritsLoose;\n\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 2);\nmodule.export({\n  VoIPUser: function () {\n    return VoIPUser;\n  }\n});\nvar Emitter;\nmodule.link(\"@rocket.chat/emitter\", {\n  Emitter: function (v) {\n    Emitter = v;\n  }\n}, 0);\nvar UserAgent, Invitation, SessionState, Registerer, RequestPendingError;\nmodule.link(\"sip.js\", {\n  UserAgent: function (v) {\n    UserAgent = v;\n  },\n  Invitation: function (v) {\n    Invitation = v;\n  },\n  SessionState: function (v) {\n    SessionState = v;\n  },\n  Registerer: function (v) {\n    Registerer = v;\n  },\n  RequestPendingError: function (v) {\n    RequestPendingError = v;\n  }\n}, 1);\nvar URI;\nmodule.link(\"sip.js/lib/core\", {\n  URI: function (v) {\n    URI = v;\n  }\n}, 2);\nvar SessionDescriptionHandler;\nmodule.link(\"sip.js/lib/platform/web\", {\n  SessionDescriptionHandler: function (v) {\n    SessionDescriptionHandler = v;\n  }\n}, 3);\nvar Operation;\nmodule.link(\"../../../definition/voip/Operations\", {\n  Operation: function (v) {\n    Operation = v;\n  }\n}, 4);\nvar UserState;\nmodule.link(\"../../../definition/voip/UserState\", {\n  UserState: function (v) {\n    UserState = v;\n  }\n}, 5);\nvar WorkflowTypes;\nmodule.link(\"../../../definition/voip/WorkflowTypes\", {\n  WorkflowTypes: function (v) {\n    WorkflowTypes = v;\n  }\n}, 6);\nvar toggleMediaStreamTracks;\nmodule.link(\"./Helper\", {\n  toggleMediaStreamTracks: function (v) {\n    toggleMediaStreamTracks = v;\n  }\n}, 7);\nvar QueueAggregator;\nmodule.link(\"./QueueAggregator\", {\n  QueueAggregator: function (v) {\n    QueueAggregator = v;\n  }\n}, 8);\nvar Stream;\nmodule.link(\"./Stream\", {\n  \"default\": function (v) {\n    Stream = v;\n  }\n}, 9);\n\nvar VoIPUser = /*#__PURE__*/function (_Emitter) {\n  _inheritsLoose(VoIPUser, _Emitter);\n\n  /* Media Stream functions end */\n  function VoIPUser(config, mediaRenderer) {\n    var _this;\n\n    _this = _Emitter.call(this) || this;\n    _this.config = void 0;\n    _this.state = {\n      isReady: false,\n      enableVideo: false\n    };\n    _this.session = void 0;\n    _this.remoteStream = void 0;\n    _this.userAgentOptions = {};\n    _this.userAgent = void 0;\n    _this.registerer = void 0;\n    _this.mediaStreamRendered = void 0;\n    _this._callState = 'IDLE';\n    _this._callerInfo = void 0;\n    _this._userState = UserState.IDLE;\n    _this._held = false;\n    _this.mode = void 0;\n    _this.queueInfo = void 0;\n    _this._opInProgress = Operation.OP_NONE;\n    _this.config = config;\n    _this.mediaStreamRendered = mediaRenderer;\n\n    _this.on('connected', function () {\n      _this.state.isReady = true;\n    });\n\n    _this.on('connectionerror', function () {\n      _this.state.isReady = false;\n    });\n\n    return _this;\n  }\n  /* UserAgentDelegate methods end */\n\n  /* OutgoingRequestDelegate methods begin */\n\n\n  var _proto = VoIPUser.prototype;\n\n  _proto.onAccept = function () {\n    function onAccept() {\n      if (this._opInProgress === Operation.OP_REGISTER) {\n        this._callState = 'REGISTERED';\n        this.emit('registered');\n        this.emit('stateChanged');\n      }\n\n      if (this._opInProgress === Operation.OP_UNREGISTER) {\n        this._callState = 'UNREGISTERED';\n        this.emit('unregistered');\n        this.emit('stateChanged');\n      }\n    }\n\n    return onAccept;\n  }();\n\n  _proto.onReject = function () {\n    function onReject(error) {\n      if (this._opInProgress === Operation.OP_REGISTER) {\n        this.emit('registrationerror', error);\n      }\n\n      if (this._opInProgress === Operation.OP_UNREGISTER) {\n        this.emit('unregistrationerror', error);\n      }\n    }\n\n    return onReject;\n  }()\n  /* OutgoingRequestDelegate methods end */\n  ;\n\n  _proto.handleIncomingCall = function () {\n    function handleIncomingCall(invitation) {\n      var callerInfo;\n      return _regeneratorRuntime.async(function () {\n        function handleIncomingCall$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.callState === 'REGISTERED')) {\n                  _context.next = 11;\n                  break;\n                }\n\n                this._opInProgress = Operation.OP_PROCESS_INVITE;\n                this._callState = 'OFFER_RECEIVED';\n                this._userState = UserState.UAS;\n                this.session = invitation;\n                this.setupSessionEventHandlers(invitation);\n                callerInfo = {\n                  callerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n                  callerName: invitation.remoteIdentity.displayName,\n                  host: invitation.remoteIdentity.uri.host\n                };\n                this._callerInfo = callerInfo;\n                this.emit('incomingcall', callerInfo);\n                this.emit('stateChanged');\n                return _context.abrupt(\"return\");\n\n              case 11:\n                _context.next = 13;\n                return _regeneratorRuntime.awrap(invitation.reject());\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }\n\n        return handleIncomingCall$;\n      }(), null, this, null, Promise);\n    }\n\n    return handleIncomingCall;\n  }()\n  /**\n   * Sets up an listener handler for handling session's state change\n   * @remarks\n   * Called for setting up various state listeners. These listeners will\n   * decide the next action to be taken when the session state changes.\n   * e.g when session.state changes from |Establishing| to |Established|\n   * one must set up local and remote media rendering.\n   *\n   * This class handles such session state changes and takes necessary actions.\n   */\n  ;\n\n  _proto.setupSessionEventHandlers = function () {\n    function setupSessionEventHandlers(session) {\n      var _this$session,\n          _this2 = this;\n\n      (_this$session = this.session) === null || _this$session === void 0 ? void 0 : _this$session.stateChange.addListener(function (state) {\n        var _this2$remoteStream;\n\n        if (_this2.session !== session) {\n          return; // if our session has changed, just return\n        }\n\n        switch (state) {\n          case SessionState.Initial:\n            break;\n\n          case SessionState.Establishing:\n            break;\n\n          case SessionState.Established:\n            _this2._opInProgress = Operation.OP_NONE;\n            _this2._callState = 'IN_CALL';\n\n            _this2.setupRemoteMedia();\n\n            _this2.emit('callestablished');\n\n            _this2.emit('stateChanged');\n\n            break;\n\n          case SessionState.Terminating: // fall through\n\n          case SessionState.Terminated:\n            _this2.session = undefined;\n            _this2._callState = 'REGISTERED';\n            _this2._opInProgress = Operation.OP_NONE;\n            _this2._userState = UserState.IDLE;\n\n            _this2.emit('callterminated');\n\n            (_this2$remoteStream = _this2.remoteStream) === null || _this2$remoteStream === void 0 ? void 0 : _this2$remoteStream.clear();\n\n            _this2.emit('stateChanged');\n\n            break;\n\n          default:\n            throw new Error('Unknown session state.');\n        }\n      });\n    }\n\n    return setupSessionEventHandlers;\n  }();\n\n  _proto.onTrackAdded = function () {\n    function onTrackAdded(_event) {\n      console.log('onTrackAdded');\n    }\n\n    return onTrackAdded;\n  }();\n\n  _proto.onTrackRemoved = function () {\n    function onTrackRemoved(_event) {\n      console.log('onTrackRemoved');\n    }\n\n    return onTrackRemoved;\n  }()\n  /**\n   * Carries out necessary steps for rendering remote media whe\n   * call gets established.\n   * @remarks\n   * Sets up Stream class and plays the stream on given Media element/\n   * Also sets up various event handlers.\n   */\n  ;\n\n  _proto.setupRemoteMedia = function () {\n    function setupRemoteMedia() {\n      var _this$session2, _this$mediaStreamRend;\n\n      if (!this.session) {\n        throw new Error('Session does not exist.');\n      }\n\n      var sdh = (_this$session2 = this.session) === null || _this$session2 === void 0 ? void 0 : _this$session2.sessionDescriptionHandler;\n\n      if (!sdh) {\n        return undefined;\n      }\n\n      if (!(sdh instanceof SessionDescriptionHandler)) {\n        throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n      }\n\n      var remoteStream = sdh.remoteMediaStream;\n\n      if (!remoteStream) {\n        throw new Error('Remote media stream undefiend.');\n      }\n\n      this.remoteStream = new Stream(remoteStream);\n      var mediaElement = (_this$mediaStreamRend = this.mediaStreamRendered) === null || _this$mediaStreamRend === void 0 ? void 0 : _this$mediaStreamRend.remoteMediaElement;\n\n      if (mediaElement) {\n        this.remoteStream.init(mediaElement);\n        this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n        this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n        this.remoteStream.play();\n      }\n    }\n\n    return setupRemoteMedia;\n  }()\n  /**\n   * Handles call mute-unmute\n   */\n  ;\n\n  _proto.handleMuteUnmute = function () {\n    function handleMuteUnmute(muteState) {\n      var _this$session3,\n          _this3 = this,\n          _this$session4;\n\n      var session, sessionDescriptionHandler, options, peerConnection;\n      return _regeneratorRuntime.async(function () {\n        function handleMuteUnmute$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                session = this.session;\n\n                if (!(this._held === muteState)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", Promise.resolve());\n\n              case 3:\n                if (session) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error('Session not found');\n\n              case 5:\n                sessionDescriptionHandler = (_this$session3 = this.session) === null || _this$session3 === void 0 ? void 0 : _this$session3.sessionDescriptionHandler;\n\n                if (sessionDescriptionHandler instanceof SessionDescriptionHandler) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\n              case 8:\n                options = {\n                  requestDelegate: {\n                    onAccept: function () {\n                      _this3._held = muteState;\n                      toggleMediaStreamTracks(!_this3._held, session, 'receiver');\n                      toggleMediaStreamTracks(!_this3._held, session, 'sender');\n                    },\n                    onReject: function () {\n                      _this3.emit('muteerror');\n                    }\n                  }\n                };\n                peerConnection = sessionDescriptionHandler.peerConnection;\n\n                if (peerConnection) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                throw new Error('Peer connection closed.');\n\n              case 12:\n                return _context2.abrupt(\"return\", (_this$session4 = this.session) === null || _this$session4 === void 0 ? void 0 : _this$session4.invite(options).then(function () {\n                  toggleMediaStreamTracks(!_this3._held, session, 'receiver');\n                  toggleMediaStreamTracks(!_this3._held, session, 'sender');\n                }).catch(function (error) {\n                  if (error instanceof RequestPendingError) {\n                    var _this3$session;\n\n                    console.error(\"[\" + ((_this3$session = _this3.session) === null || _this3$session === void 0 ? void 0 : _this3$session.id) + \"] A mute request is already in progress.\");\n                  }\n\n                  _this3.emit('muteerror');\n\n                  throw error;\n                }));\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }\n\n        return handleMuteUnmute$;\n      }(), null, this, null, Promise);\n    }\n\n    return handleMuteUnmute;\n  }()\n  /**\n   * Handles call hold-unhold\n   */\n  ;\n\n  _proto.handleHoldUnhold = function () {\n    function handleHoldUnhold(holdState) {\n      var _this$session5,\n          _this4 = this,\n          _this$session6;\n\n      var session, sessionDescriptionHandler, options, sessionDescriptionHandlerOptions, peerConnection;\n      return _regeneratorRuntime.async(function () {\n        function handleHoldUnhold$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                session = this.session;\n\n                if (!(this._held === holdState)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.resolve());\n\n              case 3:\n                if (session) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Session not found');\n\n              case 5:\n                sessionDescriptionHandler = (_this$session5 = this.session) === null || _this$session5 === void 0 ? void 0 : _this$session5.sessionDescriptionHandler;\n\n                if (sessionDescriptionHandler instanceof SessionDescriptionHandler) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\n              case 8:\n                options = {\n                  requestDelegate: {\n                    onAccept: function () {\n                      _this4._held = holdState;\n                      _this4._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n                      toggleMediaStreamTracks(!_this4._held, session, 'receiver');\n                      toggleMediaStreamTracks(!_this4._held, session, 'sender');\n                      _this4._callState === 'ON_HOLD' ? _this4.emit('hold') : _this4.emit('unhold');\n\n                      _this4.emit('stateChanged');\n                    },\n                    onReject: function () {\n                      toggleMediaStreamTracks(!_this4._held, session, 'receiver');\n                      toggleMediaStreamTracks(!_this4._held, session, 'sender');\n\n                      _this4.emit('holderror');\n                    }\n                  }\n                }; // Session properties used to pass options to the SessionDescriptionHandler:\n                //\n                // 1) Session.sessionDescriptionHandlerOptions\n                //    SDH options for the initial INVITE transaction.\n                //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n                //    - May be set directly at anytime.\n                //    - May optionally be set via constructor option.\n                //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n                //\n                // 2) Session.sessionDescriptionHandlerOptionsReInvite\n                //    SDH options for re-INVITE transactions.\n                //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n                //    - May be set directly at anytime.\n                //    - May optionally be set via constructor option.\n                //    - May optionally be set via options passed to Session.invite().\n\n                sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;\n                sessionDescriptionHandlerOptions.hold = holdState;\n                session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n                peerConnection = sessionDescriptionHandler.peerConnection;\n\n                if (peerConnection) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                throw new Error('Peer connection closed.');\n\n              case 15:\n                return _context3.abrupt(\"return\", (_this$session6 = this.session) === null || _this$session6 === void 0 ? void 0 : _this$session6.invite(options).then(function () {\n                  toggleMediaStreamTracks(!_this4._held, session, 'receiver');\n                  toggleMediaStreamTracks(!_this4._held, session, 'sender');\n                }).catch(function (error) {\n                  if (error instanceof RequestPendingError) {\n                    var _this4$session;\n\n                    console.error(\"[\" + ((_this4$session = _this4.session) === null || _this4$session === void 0 ? void 0 : _this4$session.id) + \"] A hold request is already in progress.\");\n                  }\n\n                  _this4.emit('holderror');\n\n                  throw error;\n                }));\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }\n\n        return handleHoldUnhold$;\n      }(), null, this, null, Promise);\n    }\n\n    return handleHoldUnhold;\n  }()\n  /**\n   * Configures and initializes sip.js UserAgent\n   * call gets established.\n   * @remarks\n   * This class configures transport properties such as websocket url, passed down in config,\n   * sets up ICE servers,\n   * SIP UserAgent options such as userName, Password, URI.\n   * Once initialized, it starts the userAgent.\n   */\n  ;\n\n  _proto.init = function () {\n    function init() {\n      var _this5 = this;\n\n      var sipUri, transportOptions, sdpFactoryOptions;\n      return _regeneratorRuntime.async(function () {\n        function init$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                sipUri = \"sip:\" + this.config.authUserName + \"@\" + this.config.sipRegistrarHostnameOrIP;\n                transportOptions = {\n                  server: this.config.webSocketURI,\n                  connectionTimeout: 100,\n                  keepAliveInterval: 20 // traceSip: true\n\n                };\n                sdpFactoryOptions = {\n                  iceGatheringTimeout: 10,\n                  peerConnectionConfiguration: {\n                    iceServers: this.config.iceServers\n                  }\n                };\n                this.userAgentOptions = {\n                  delegate: {\n                    /* UserAgentDelegate methods begin */\n                    onConnect: function () {\n                      var _this5$userAgent;\n\n                      _this5._callState = 'SERVER_CONNECTED';\n\n                      _this5.emit('connected');\n                      /**\n                       * There is an interesting problem that happens with Asterisk.\n                       * After websocket connection succeeds and if there is no SIP\n                       * message goes in 30 seconds, asterisk disconnects the socket.\n                       *\n                       * If any SIP message goes before 30 seconds, asterisk holds the connection.\n                       * This problem could be solved in multiple ways. One is that\n                       * whenever disconnect happens make sure that the socket is connected back using\n                       * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n                       * every 30 seconds till we send register message.\n                       *\n                       * Another approach is to send SIP OPTIONS just to tell server that\n                       * there is a UA using this socket. This is implemented below\n                       **/\n\n\n                      var uri = new URI('sip', _this5.config.authUserName, _this5.config.sipRegistrarHostnameOrIP);\n                      var outgoingMessage = (_this5$userAgent = _this5.userAgent) === null || _this5$userAgent === void 0 ? void 0 : _this5$userAgent.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\n                      if (outgoingMessage) {\n                        var _this5$userAgent2;\n\n                        (_this5$userAgent2 = _this5.userAgent) === null || _this5$userAgent2 === void 0 ? void 0 : _this5$userAgent2.userAgentCore.request(outgoingMessage);\n                      }\n\n                      if (_this5.userAgent) {\n                        _this5.registerer = new Registerer(_this5.userAgent);\n                      }\n                    },\n                    onDisconnect: function (error) {\n                      if (error) {\n                        _this5.emit('connectionerror', error);\n                      }\n                    },\n                    onInvite: function () {\n                      function _callee(invitation) {\n                        return _regeneratorRuntime.async(function () {\n                          function _callee$(_context4) {\n                            while (1) {\n                              switch (_context4.prev = _context4.next) {\n                                case 0:\n                                  _context4.next = 2;\n                                  return _regeneratorRuntime.awrap(_this5.handleIncomingCall(invitation));\n\n                                case 2:\n                                case \"end\":\n                                  return _context4.stop();\n                              }\n                            }\n                          }\n\n                          return _callee$;\n                        }(), null, null, null, Promise);\n                      }\n\n                      return _callee;\n                    }()\n                  },\n                  authorizationPassword: this.config.authPassword,\n                  authorizationUsername: this.config.authUserName,\n                  uri: UserAgent.makeURI(sipUri),\n                  transportOptions: transportOptions,\n                  sessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n                  logConfiguration: false,\n                  logLevel: 'error'\n                };\n                this.userAgent = new UserAgent(this.userAgentOptions);\n                this._opInProgress = Operation.OP_CONNECT;\n                _context5.next = 8;\n                return _regeneratorRuntime.awrap(this.userAgent.start());\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }\n\n        return init$;\n      }(), null, this, null, Promise);\n    }\n\n    return init;\n  }();\n\n  VoIPUser.create = function () {\n    function create(config, mediaRenderer) {\n      var voip;\n      return _regeneratorRuntime.async(function () {\n        function create$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                voip = new VoIPUser(config, mediaRenderer);\n                _context6.next = 3;\n                return _regeneratorRuntime.awrap(voip.init());\n\n              case 3:\n                return _context6.abrupt(\"return\", voip);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }\n\n        return create$;\n      }(), null, null, null, Promise);\n    }\n\n    return create;\n  }()\n  /**\n   * Public method called from outside to register the SIP UA with call server.\n   * @remarks\n   */\n  ;\n\n  _proto.register = function () {\n    function register() {\n      var _this$registerer;\n\n      this._opInProgress = Operation.OP_REGISTER;\n      (_this$registerer = this.registerer) === null || _this$registerer === void 0 ? void 0 : _this$registerer.register({\n        requestDelegate: this\n      });\n    }\n\n    return register;\n  }()\n  /**\n   * Public method called from outside to unregister the SIP UA.\n   * @remarks\n   */\n  ;\n\n  _proto.unregister = function () {\n    function unregister() {\n      var _this$registerer2;\n\n      this._opInProgress = Operation.OP_UNREGISTER;\n      (_this$registerer2 = this.registerer) === null || _this$registerer2 === void 0 ? void 0 : _this$registerer2.unregister({\n        all: true,\n        requestDelegate: this\n      });\n    }\n\n    return unregister;\n  }()\n  /**\n   * Public method called from outside to accept incoming call.\n   * @remarks\n   */\n  ;\n\n  _proto.acceptCall = function () {\n    function acceptCall(mediaRenderer) {\n      var videoInvite, body, invitationAcceptOptions;\n      return _regeneratorRuntime.async(function () {\n        function acceptCall$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (mediaRenderer) {\n                  this.mediaStreamRendered = mediaRenderer;\n                } // Call state must be in offer_received.\n\n\n                if (!(this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE)) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                this._callState = 'ANSWER_SENT'; // Somethingis wrong, this session is not an instance of INVITE\n\n                if (this.session instanceof Invitation) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('Session not instance of Invitation.');\n\n              case 5:\n                /**\n                 * It is important to decide when to add video option to the outgoing offer.\n                 * This would matter when the reinvite goes out (In case of hold/unhold)\n                 * This was added because there were failures in hold-unhold.\n                 * The scenario was that if this client does hold-unhold first, and remote client does\n                 * later, remote client goes in inconsistent state and hold-unhold does not work\n                 * Where as if the remote client does hold-unhold first, this client can do it any number\n                 * of times.\n                 *\n                 * Logic below works as follows\n                 * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n                 * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n                 * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n                 * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n                 *\n                 */\n                videoInvite = !!this.config.enableVideo;\n                body = this.session.body;\n\n                if (body && body.indexOf('m=video') === -1) {\n                  videoInvite = false;\n                }\n\n                invitationAcceptOptions = {\n                  sessionDescriptionHandlerOptions: {\n                    constraints: {\n                      audio: true,\n                      video: !!this.config.enableVideo && videoInvite\n                    }\n                  }\n                };\n                return _context7.abrupt(\"return\", this.session.accept(invitationAcceptOptions));\n\n              case 10:\n                throw new Error('Something went wront');\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }\n\n        return acceptCall$;\n      }(), null, this, null, Promise);\n    }\n\n    return acceptCall;\n  }()\n  /**\n   * Public method called from outside to reject a call.\n   * @remarks\n   */\n  ;\n\n  _proto.rejectCall = function () {\n    function rejectCall() {\n      if (!this.session) {\n        throw new Error('Session does not exist.');\n      }\n\n      if (this._callState !== 'OFFER_RECEIVED') {\n        throw new Error(\"Incorrect call State = \" + this.callState);\n      }\n\n      if (!(this.session instanceof Invitation)) {\n        throw new Error('Session not instance of Invitation.');\n      }\n\n      return this.session.reject();\n    }\n\n    return rejectCall;\n  }()\n  /**\n   * Public method called from outside to end a call.\n   * @remarks\n   */\n  ;\n\n  _proto.endCall = function () {\n    function endCall() {\n      return _regeneratorRuntime.async(function () {\n        function endCall$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (this.session) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new Error('Session does not exist.');\n\n              case 2:\n                if (!(this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD')) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Incorrect call State = \" + this.callState);\n\n              case 4:\n                // When call ends, force state to be revisited\n                this.emit('stateChanged');\n                _context8.t0 = this.session.state;\n                _context8.next = _context8.t0 === SessionState.Initial ? 8 : _context8.t0 === SessionState.Establishing ? 11 : _context8.t0 === SessionState.Established ? 14 : _context8.t0 === SessionState.Terminating ? 15 : _context8.t0 === SessionState.Terminated ? 16 : 17;\n                break;\n\n              case 8:\n                if (!(this.session instanceof Invitation)) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.session.reject());\n\n              case 10:\n                throw new Error('Session not instance of Invitation.');\n\n              case 11:\n                if (!(this.session instanceof Invitation)) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.session.reject());\n\n              case 13:\n                throw new Error('Session not instance of Invitation.');\n\n              case 14:\n                return _context8.abrupt(\"return\", this.session.bye());\n\n              case 15:\n                return _context8.abrupt(\"break\", 18);\n\n              case 16:\n                return _context8.abrupt(\"break\", 18);\n\n              case 17:\n                throw new Error('Unknown state');\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }\n\n        return endCall$;\n      }(), null, this, null, Promise);\n    }\n\n    return endCall;\n  }()\n  /**\n   * Public method called from outside to mute the call.\n   * @remarks\n   */\n  ;\n\n  _proto.muteCall = function () {\n    function muteCall(muteState) {\n      return _regeneratorRuntime.async(function () {\n        function muteCall$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.session) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error('Session does not exist.');\n\n              case 2:\n                if (!(this._callState !== 'IN_CALL')) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Incorrect call State = \" + this.callState);\n\n              case 4:\n                this.handleMuteUnmute(muteState);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }\n\n        return muteCall$;\n      }(), null, this, null, Promise);\n    }\n\n    return muteCall;\n  }()\n  /**\n   * Public method called from outside to hold the call.\n   * @remarks\n   */\n  ;\n\n  _proto.holdCall = function () {\n    function holdCall(holdState) {\n      return _regeneratorRuntime.async(function () {\n        function holdCall$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this.session) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('Session does not exist.');\n\n              case 2:\n                if (!(this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD')) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Incorrect call State = \" + this.callState);\n\n              case 4:\n                this.handleHoldUnhold(holdState);\n\n              case 5:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }\n\n        return holdCall$;\n      }(), null, this, null, Promise);\n    }\n\n    return holdCall;\n  }()\n  /* CallEventDelegate implementation end */\n  ;\n\n  _proto.isReady = function () {\n    function isReady() {\n      return this.state.isReady;\n    }\n\n    return isReady;\n  }()\n  /**\n   * This function allows to change the media renderer media elements.\n   */\n  ;\n\n  _proto.switchMediaRenderer = function () {\n    function switchMediaRenderer(mediaRenderer) {\n      if (this.remoteStream) {\n        this.mediaStreamRendered = mediaRenderer;\n        this.remoteStream.init(mediaRenderer.remoteMediaElement);\n        this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n        this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n        this.remoteStream.play();\n      }\n    }\n\n    return switchMediaRenderer;\n  }();\n\n  _proto.setWorkflowMode = function () {\n    function setWorkflowMode(mode) {\n      this.mode = mode;\n\n      if (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n        this.queueInfo = new QueueAggregator();\n      }\n    }\n\n    return setWorkflowMode;\n  }();\n\n  _proto.setMembershipSubscription = function () {\n    function setMembershipSubscription(subscription) {\n      var _this$queueInfo;\n\n      if (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n        return;\n      }\n\n      (_this$queueInfo = this.queueInfo) === null || _this$queueInfo === void 0 ? void 0 : _this$queueInfo.setMembership(subscription);\n    }\n\n    return setMembershipSubscription;\n  }();\n\n  _proto.getAggregator = function () {\n    function getAggregator() {\n      return this.queueInfo;\n    }\n\n    return getAggregator;\n  }();\n\n  _proto.getRegistrarState = function () {\n    function getRegistrarState() {\n      var _this$registerer3;\n\n      return (_this$registerer3 = this.registerer) === null || _this$registerer3 === void 0 ? void 0 : _this$registerer3.state.toString().toLocaleLowerCase();\n    }\n\n    return getRegistrarState;\n  }();\n\n  _proto.clear = function () {\n    function clear() {\n      var _this$userAgent;\n\n      (_this$userAgent = this.userAgent) === null || _this$userAgent === void 0 ? void 0 : _this$userAgent.stop();\n    }\n\n    return clear;\n  }();\n\n  _createClass(VoIPUser, [{\n    key: \"callState\",\n    get: function () {\n      return this._callState;\n    }\n  }, {\n    key: \"callerInfo\",\n    get: function () {\n      if (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD') {\n        if (!this._callerInfo) {\n          throw new Error('[VoIPUser callerInfo] invalid state');\n        }\n\n        return {\n          state: this.callState,\n          caller: this._callerInfo,\n          userState: this._userState\n        };\n      }\n\n      return {\n        state: this.callState,\n        userState: this._userState\n      };\n    }\n  }, {\n    key: \"operationInProgress\",\n    get: function () {\n      return this._opInProgress;\n    }\n  }, {\n    key: \"userState\",\n    get: function () {\n      return this._userState;\n    }\n    /* Media Stream functions begin */\n\n    /** The local media stream. Undefined if call not answered. */\n\n  }, {\n    key: \"localMediaStream\",\n    get: function () {\n      var _this$session7;\n\n      var sdh = (_this$session7 = this.session) === null || _this$session7 === void 0 ? void 0 : _this$session7.sessionDescriptionHandler;\n\n      if (!sdh) {\n        return undefined;\n      }\n\n      if (!(sdh instanceof SessionDescriptionHandler)) {\n        throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n      }\n\n      return sdh.localMediaStream;\n    }\n  }]);\n\n  return VoIPUser;\n}(Emitter);","map":{"version":3,"sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protol details.\n */\n\nimport { Emitter } from '@rocket.chat/emitter';\nimport {\n\tUserAgent,\n\tUserAgentOptions,\n\t// UserAgentDelegate,\n\tInvitation,\n\tInvitationAcceptOptions,\n\tSession,\n\tSessionState,\n\tRegisterer,\n\tSessionInviteOptions,\n\tRequestPendingError,\n} from 'sip.js';\nimport { OutgoingByeRequest, OutgoingRequestDelegate, URI } from 'sip.js/lib/core';\nimport { SessionDescriptionHandler, SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\n\nimport { IQueueMembershipSubscription } from '../../../definition/IVoipExtension';\nimport { CallStates } from '../../../definition/voip/CallStates';\nimport { ICallerInfo } from '../../../definition/voip/ICallerInfo';\nimport { Operation } from '../../../definition/voip/Operations';\nimport { UserState } from '../../../definition/voip/UserState';\nimport { IMediaStreamRenderer, VoIPUserConfiguration } from '../../../definition/voip/VoIPUserConfiguration';\nimport { VoIpCallerInfo, IState } from '../../../definition/voip/VoIpCallerInfo';\nimport { VoipEvents } from '../../../definition/voip/VoipEvents';\nimport { WorkflowTypes } from '../../../definition/voip/WorkflowTypes';\nimport { toggleMediaStreamTracks } from './Helper';\nimport { QueueAggregator } from './QueueAggregator';\nimport Stream from './Stream';\n\nexport class VoIPUser extends Emitter<VoipEvents> implements OutgoingRequestDelegate {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate session: Session | undefined;\n\n\tprivate remoteStream: Stream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _callState: CallStates = 'IDLE';\n\n\tprivate _callerInfo: ICallerInfo | undefined;\n\n\tprivate _userState: UserState = UserState.IDLE;\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD') {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\tprivate _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.on('connected', () => {\n\t\t\tthis.state.isReady = true;\n\t\t});\n\n\t\tthis.on('connectionerror', () => {\n\t\t\tthis.state.isReady = false;\n\t\t});\n\t}\n\n\t/* UserAgentDelegate methods end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprivate setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis.emit('callestablished');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream undefiend.');\n\t\t}\n\n\t\tthis.remoteStream = new Stream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\t/* UserAgentDelegate methods begin */\n\t\t\t\tonConnect: (): void => {\n\t\t\t\t\tthis._callState = 'SERVER_CONNECTED';\n\n\t\t\t\t\tthis.emit('connected');\n\t\t\t\t\t/**\n\t\t\t\t\t * There is an interesting problem that happens with Asterisk.\n\t\t\t\t\t * After websocket connection succeeds and if there is no SIP\n\t\t\t\t\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t\t\t\t\t *\n\t\t\t\t\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t\t\t\t\t * This problem could be solved in multiple ways. One is that\n\t\t\t\t\t * whenever disconnect happens make sure that the socket is connected back using\n\t\t\t\t\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t\t\t\t\t * every 30 seconds till we send register message.\n\t\t\t\t\t *\n\t\t\t\t\t * Another approach is to send SIP OPTIONS just to tell server that\n\t\t\t\t\t * there is a UA using this socket. This is implemented below\n\t\t\t\t\t **/\n\n\t\t\t\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\t\t\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\t\t\t\tif (outgoingMessage) {\n\t\t\t\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.userAgent) {\n\t\t\t\t\t\tthis.registerer = new Registerer(this.userAgent);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonDisconnect: (error: any): void => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.emit('connectionerror', error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\tawait this.userAgent.start();\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: this,\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Somethingis wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wront');\n\t}\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'OFFER_RECEIVED') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'ANSWER_SENT' && this._callState !== 'IN_CALL' && this._callState !== 'ON_HOLD') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis.userAgent?.stop();\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"59c9dd5ec3aba5f7bf0ab7e63bab9258f1d63793"}
